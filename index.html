<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Corn the blog</title><meta property="og:type" content="blog"><meta property="og:title" content="Corn the blog"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="Corn the blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://yoursite.com/images/avatar.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="images/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"Corn the blog","image":["http://yoursite.com/images/avatar.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-23T07:22:27.000Z" title="2020-08-23T07:22:27.000Z">2020-08-23</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/Swift/">Swift</a></span><span class="level-item">10 minutes read (About 1446 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/23/Embrace-Swift-type-inference/">Embrace Swift type inference</a></h1><div class="content"><blockquote>
<p><a href="https://developer.apple.com/videos/play/wwdc2020/10165/">WWDC 2020</a></p>
</blockquote>
<p>스위프트는 코드의 안전성을 훼손하지 않고 간결한 코드를 작성하기 위해 <strong>타입 추론(Type inference)</strong>을 광범위하게 사용한다.</p>
<p>이 영상을 통해 우리는 다음의 것들을 살펴볼 것이다. </p>
<ol>
<li>타입 추론을 활용하는 법</li>
<li>컴파일러에서 타입 추론이 어떻게 동작하는지 </li>
<li>타입 추론에 의해 발생할 수 있는 에러의 원인과 이를 해결하는 방법 </li>
</ol>
<p><strong>What is type inference?</strong></p>
<p>먼저 타입 추론이 무엇인지 간단하게 알아보자. </p>
<p>타입 추론은 프로퍼티에 타입을 명시적으로 선언하지 않아도 컴파일러가 문맥에 따라 타입을 추론하는 것을 말한다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/1.png" alt="img"></p>
<p>위의 코드에서 <code>String</code>을 명시적으로 선언하지 않아도 컴파일러는 이를 <code>String</code>으로 추론한다. 좀 더 복잡한 예제 코드로 타입 추론을 활용하고, 컴파일러에서 타입 추론이 어떻게 동작하는지를 살펴보자. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/2.png" alt="img"></p>
<p>위의 코드에서 <code>FilteredList</code>는 주어진 데이터를 리스트 형태로 보여주고 필터링 기능을 제공하는 재사용 가능한 뷰다. 이 <code>FilteredList</code>는 재사용 가능해야 하므로 기본적으로 생성자 인자들은 제네릭 해야 한다. 위의 코드에서 <code>FilteredList</code>를 사용하면서 따로 타입을 명시해 주지 않고 있다. 이는 컴파일러가 타입 추론을 하기 때문에 가능한 일인데, 이를 좀 더 알아보기 위해 <code>FilteredList</code>가 어떻게 정의되어 있는지 코드로 살펴보도록 하자</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/3.png" alt="img"></p>
<p><code>Element</code>, <code>FilterKey</code> 그리고 <code>RowContent</code>는 <code>FileteredList</code>가 생성될 때 실제 타입, 즉 Concrete 타입으로 대체된다. 이제 선언부와 호출부를 나란히 두고 비교해보자.</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/4.png" alt="img"></p>
<p>제네릭 타입으로 인해 복잡한 선언부와 비교했을 때 호출부는 훨씬 깔끔한 코드임을 확인할 수 있다. 이는 컴파일러가 주어진 값들로 타입 추론을 하기 때문에 가능한 일인데, 타입 추론이 아닌 명시적으로 타입을 명시한다면 아래와 보다 복잡한 코드를 작성해야 한다.</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/5.png" alt="글"></p>
<p>그렇다면 컴파일러는 어떻게 타입 추론을 하는 것일까? 타입 추론은 일종의 퍼즐이라고 할 수 있다. 우린 퍼즐을 하면서 하나의 조각이 맞춰질 때 다음 조각을 자연스럽게 유추할 수 있다. 하나의 퍼즐이 맞춰질 때마다 다음 조각에 대한 단서를 우린 유추할 수 있다. 컴파일러는 이렇게 퍼즐을 풀 듯이 우리의 코드에서 단서를 찾아 퍼즐을 하나씩 맞춰가며 타입을 추론한다. </p>
<p>위의 코드를 사용해서 컴파일러가 어떻게 퍼즐을 맞춰가는지 살펴보자. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/6.png" alt="img"></p>
<p>먼저 첫 번째로 인자로 넘기는 <code>smoothies</code>라는 단서를 통해 <code>Element</code>의 타입을 추론할 수 있다. <code>smoothies</code>는 <code>[Smoothie]</code> 타입으로 <code>Element</code>는 <code>Smoothie</code> 타입으로 대체된다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/7.png" alt="img"></p>
<p>우린 <code>Element</code>라는 퍼즐 조각을 맞췄기 때문에 이를 통해 또 다른 단서를 얻을 수 있다. 바로 <code>FilterKey</code>다. <code>\.title</code>은 <code>\Smoothe.title</code>로 대체되고 <code>Smoothie</code>의 <code>title</code> 프로퍼티는 <code>String</code>이란 것을 알 수 있기 때문에 <code>FilterKey</code>는 <code>String</code>으로 대체된다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/8.png" alt="img"></p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/9.png" alt="img"></p>
<p><code>RowContent</code> 역시 <code>ViewBuilder</code> 클로저 안에서 <code>SmoothieRowView</code>가 반환되기 때문에 <code>SmoothieRowView</code>로 대체될 수 있다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/10.png" alt="img"></p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/11.png" alt="img"></p>
<p>이런 식으로 컴파일러는 이전 단계의 단서를 통해 하나씩 타입을 추론해 나간다. 하지만 이렇게 얻은 이전 단계의 퍼즐 조각(단서)이 맞지 않는다면 소스 코드에 에러가 발생했다는 것을 의미한다. 즉 맞지 않은 타입이 들어갔기 때문에 컴파일러는 더 이상 타입 추론을 진행할 수 없다.</p>
<p><code>Smoothie.title</code>이 아닌 <code>Bool</code> 타입의 <code>Smoothie.isPopular</code>로 바꿔보자</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/12.png" alt="img"></p>
<p>그렇다면 컴파일러는 <code>Bool</code> 타입을 <code>FilterKey</code>의 조각으로 사용할 것이다. 하지만 <code>Bool</code> 타입은 <code>hasSubString(_:)</code> 메서드가 없기 때문에 이후의 타입 추론을 진행할 수 없고, 에러를 뱉는다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/13.png" alt="img"></p>
<p>이렇게 스위프트 컴파일러는 추후에 에러 메시지를 출력할 때 사용하기 위해 에러 추적 기능을 타입 추론에 통합시켰다. 컴파일러는 타입 추론을 진행하면서 직면한 에러를 기록한다. 그리고 컴파일러는 에러를 고치고 타입 추론을 계속 진행하기 위해 <a href="https://ko.wikipedia.org/wiki/휴리스틱_이론">휴리스틱</a>을 사용한다.</p>
<p>그리고 타입 추론이 끝나면 컴파일러는 타입 추론을 진행하면서 수집한 에러를 actionable한 에러 메시지(자동으로 코드를 수정할 수 있는)나 에러를 발생시킨 실제 타입에 대한 메시지와 함께 개발자에게 알린다.</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/14.png" alt="img"></p>
<p>이렇게 통합된 에러 추적 시스템은 Xcode11.4의 스위프트 5.2에선 많은 오류 메시지에 도입되었고, Xcode12의 스위프트 5.3에선 모든 에러 메시지에 적용되었다. Embrace Swift type inference</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-26T08:37:48.000Z" title="2020-07-26T08:37:48.000Z">2020-07-26</time><span class="level-item"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></span><span class="level-item">14 minutes read (About 2029 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/26/GeometryReader-in-SwiftUI/">GeometryReader in SwiftUI</a></h1><div class="content"><p>SwiftUI를 공부하다 보면 자연스레 등장하는 개념이 바로 <code>GeometryReader</code>다. 어렴풋이 이해하고 있던 개념을 포스팅을 통해 정리해보려 한다. </p>
<h2 id="What-is-GeometryReader"><a href="#What-is-GeometryReader" class="headerlink" title="What is GeometryReader"></a>What is GeometryReader</h2><p><code>GeometryReader</code>란 무엇인가? </p>
<p>SwiftUI에선 UIKit으로 레이아웃을 작성할 때와 달리 뷰 객체에 직접 접근할 수 없다. 뷰 객체에 직접 접근해 뷰 정보(size, position 등)에 알 수 있었던 것과 달리 SwiftUI에서 뷰 객체는 일시적인(<em>transient</em>) 객체로 프레임워크가 뷰를 그리고 난 후 객체는 사라지기 때문에 UIKit과 같은 방식으론 뷰에 관한 정보를 알 수 없다.</p>
<p>그렇다고 모든 뷰에 <code>.frame(width:, height)</code> 변경자를 사용해 직접 고정 값을 넣을 수도 없는 일이다. 이를 위해 등장한 개념이 <code>GeometryReader</code>로 상위 뷰의 <em>Geometry</em> 정보를 하위 뷰에 제공하는 역할을 한다. </p>
<blockquote>
<p>보다 정확히는 상위 뷰가 제안한 <em>Geometry</em> 정보</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">    	<span class="comment">// proxy를 통해 뷰 정보에 접근.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GeometryReader</code>에 대해 더 자세히 살펴보기 전에 아직은 완성되지 않은 듯한 애플 공식 문서가 설명하고 있는 <code>GeometryReader</code>를 살펴보자. </p>
<p><em>A container view that defines its content as a function of its own size and coordinate space.</em></p>
<p><em>컨텐츠를 자신의 크기 및 좌표 공간의 함수로 정의하는 컨테이너 뷰</em> </p>
<p>이 설명을 통해 자세히는 아니지만 몇 가지 키워드로 힌트는 얻을 수 있다. </p>
<ul>
<li>컨테이너 뷰 </li>
<li>자신의 크기 및 좌표 공간</li>
</ul>
<h3 id="Layout-Process"><a href="#Layout-Process" class="headerlink" title="Layout Process"></a>Layout Process</h3><p><code>GeometryReader</code>를 이해하고 올바르게 사용하려면, SwiftUI에서 레이아웃을 그리는 세 단계에 대해 반드시 이해해야 할 필요가 있다. </p>
<blockquote>
<p><a href="https://protocorn93.github.io/2020/02/15/SwiftUI-under-the-hood/">이전 글</a>을 참고하셔도 좋습니다.</p>
</blockquote>
<p>이 세 단계를 간단히 요약하자면 아래와 같다.</p>
<ol>
<li>부모 뷰가 자식 뷰의 사이즈를 제안한다. </li>
<li>자식 뷰는 제안받은 사이즈를 이용해 자신의 사이즈를 결정한다. (<code>(언제나 제안받은 사이즈 == 자신의 사이즈) == false</code>)</li>
<li>부모 뷰는 결정된 자식 뷰를 적절히 위치시킨다. </li>
</ol>
<p><strong><code>GeometryReader</code>는 상위 뷰에서 제안한 사이즈를 자신의 사이즈로 사용 및 반환한다.</strong> 가능한한 최대한 확장한다고 생각하면 된다.</p>
<h2 id="GeometryProxy"><a href="#GeometryProxy" class="headerlink" title="GeometryProxy"></a>GeometryProxy</h2><p><code>GeometryReader</code>는 컨테이너 뷰의 한 종류이며, 다른 컨테이너 뷰의 <code>ViewBuilder</code>와는 다르게 인자를 하나 받는데 그것이 바로 <code>GeometryProxy</code> 객체다. 실제로 상위 뷰의 정보는 이 객체를 통해 접근이 가능하다. 기본적으로 위에서 살펴보았듯이 <code>GeometryProxy</code>는 <code>size</code> 프로퍼티를 갖고 있다. </p>
<p>이외에도 <code>.frame(in: )</code>라는 메서드가 있으며, 서브스크립트도 지원한다. </p>
<h3 id="frame-in"><a href="#frame-in" class="headerlink" title=".frame(in:)"></a>.frame(in:)</h3><p><code>GeometryReader</code>를 통해 <code>size</code>뿐만 아니라 <code>.frame</code> 메서드를 통해 <code>CGRect</code>에 접근해, 좌표값도 알 수 있다. </p>
<p>이 좌표값은 지정한 좌표평면 공간에 따라 달라질 수 있다. </p>
<ul>
<li><code>.local</code> - 자신이 속한 컨테이너 뷰 안에서의 좌표를 반환한다.</li>
<li><code>.global</code> - 전체 스크린에서의 좌표를 반환한다. </li>
<li><code>.named(_:)</code> - 지정한 좌표평면에서의 좌표를 반환한다. <ul>
<li><code>.coordinateSpace(name:</code> 을 통해 사용자 정의 좌표평면을 지정할 수 있다. </li>
</ul>
</li>
</ul>
<p><code>.frame(in:)</code> 메서드를 통해 UIKit에서 <code>convert</code> 메서드를 사용해 좌표를 변환하던 작업이 보다 수월해졌다. </p>
<p><img src="/2020/07/26/GeometryReader-in-SwiftUI/frame.png" alt=""></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">            <span class="type">HStack</span>(spacing: <span class="number">0.0</span>) &#123;</span><br><span class="line">              ...</span><br><span class="line">                    <span class="type">ZStack</span>(alignment: .topLeading) &#123;</span><br><span class="line">                      ...</span><br><span class="line">                        <span class="type">GeometryReader</span> &#123; innerProxy <span class="keyword">in</span></span><br><span class="line">                            <span class="type">Rectangle</span>()</span><br><span class="line">                                .foregroundColor(<span class="type">Color</span>.pink)</span><br><span class="line">                                .onTapGesture &#123;</span><br><span class="line">                                    <span class="keyword">let</span> local = innerProxy.frame(<span class="keyword">in</span>: .local)</span><br><span class="line">                                    <span class="keyword">let</span> global = innerProxy.frame(<span class="keyword">in</span>: .global)</span><br><span class="line">                                    <span class="keyword">let</span> named = innerProxy.frame(<span class="keyword">in</span>: .named(<span class="string">"OuterGeometry"</span>))</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"[local] minX : \(local.origin.x), minY : \(local.origin.y)"</span>)</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"[global] minX : \(global.origin.x), minY : \(global.origin.y)"</span>)</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"[named] minX : \(named.origin.x), minY : \(named.origin.y)"</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;.frame(width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.coordinateSpace(name: <span class="string">"OuterGeometry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[RESULT]</span><br><span class="line">[local] minX : 0.0, minY : 0.0</span><br><span class="line">[global] minX : 112.5, minY : 20.0</span><br><span class="line">[named] minX : 112.5, minY : 0.0</span><br></pre></td></tr></table></figure>



<h3 id="subscript-Anchor-gt-T"><a href="#subscript-Anchor-gt-T" class="headerlink" title="subscript(Anchor) -&gt; T"></a>subscript(Anchor) -&gt; T</h3><p><code>GeometryProxy</code>의 서브스크립트를 이해하기 위해선 <code>Anchor</code>와 함께 <strong>Preferences</strong>에 대한 이해가 있어야 한다. 그러므로 이는 추후 <strong>Preferences</strong>에 대한 포스팅에서 함께 다뤄볼 예정이다. </p>
<blockquote>
<p><strong>Preferences</strong>는 <code>GeometryReader</code>와 함께 SwiftUI에서 중요한 개념 중 하나로, 하위 뷰에서 상위 뷰로 정보를 전달하는데 사용된다. </p>
</blockquote>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>그럼 우린 <code>GeometryReader</code>를 어떻게 사용할 수 있을까? 위에서 언급했듯이 기본적으로 상위 뷰와 비례해 하위 뷰의 사이즈를 조정할 때 사용할 수 있다.</p>
<p>추가로 위에서 언급했던 <strong>“<code>GeometryReader</code>는 상위 뷰에서 제안한 사이즈를 자신의 사이즈로 사용 및 반환한다.”</strong> 특성을 이용하여  Preferences와 함께 사용될 때 하위 뷰의 <em>geometry</em> 정보를 상위 뷰에 전달할 때도 유용하게 사용할 수 있다.  </p>
<p><img src="/2020/07/26/GeometryReader-in-SwiftUI/usage.png" alt=""></p>
<p>위의 결과 화면은 <code>VStack</code> 내부의 <code>Text</code>들 중 가장 너비가 큰 값을 이용해 <code>Text</code> 각각의 <code>background</code>에 <code>Circle</code>을 위치시킨 결과다. 그럼 <code>Circle</code>의 적절한 너비와 높이 값이 정해져야 하는데 이 정보는 어떻게 알 수 있으며 어떻게 지정해야 할까?</p>
<p>Preferences에 관한 포스팅에서도 더 자세히 살펴볼 코드지만 그중 일부만 살펴보자. </p>
<blockquote>
<p>그전에 <a href="https://swiftui-lab.com/geometryreader-to-the-rescue/">이 글</a>을 참고하면 조금이나마 코드를 이해하는데 도움이 될 수 있습니다. </p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">  .padding()</span><br><span class="line">  .fixedSize()</span><br><span class="line">  .background(<span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">    <span class="type">Color</span>.clear.preference(key: <span class="type">SizePreferenceKey</span>.<span class="keyword">self</span>,</span><br><span class="line">                           value: [proxy.size])</span><br><span class="line">    &#125;)</span><br><span class="line">  .frame(width: size?.width, height: size?.width)</span><br><span class="line">  .background(</span><br><span class="line">    <span class="type">Circle</span>()</span><br><span class="line">      .fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p><code>background</code>안에 투명한 <code>Color</code> 뷰를 넣어 해당 <code>Text</code>의 <code>size</code> 값을 알 수 있다.</p>
<p>그 이유를 이해하기 위해선 역시 Layout Process에 대한 이해가 필요한데, 기본적으로 <code>background</code>는 caller의 사이즈를 그대로 인자로 들어가는 뷰에 제안한다. 그리고 <code>GeometryReader</code>는 제안받은 사이즈를 자신의 사이즈로 반환하기 때문에 위의 코드에서 <code>proxy</code>의 사이즈가 곧 <code>Text</code>의 <code>size</code>가 된다. </p>
<p>이렇게 알아낸 <code>Text</code>의 사이즈를 상위 뷰로 전달하고 상위 뷰는 이렇게 취합된 <code>Text</code>들의 사이즈 중 가장 큰 사이즈로 <code>Text</code>들의 너비를 조정해 파란색 <code>Circle</code>에 올바른 사이즈를 제안할 수 있게 된다. </p>
<h3 id="Bugs🐛"><a href="#Bugs🐛" class="headerlink" title="Bugs🐛"></a>Bugs🐛</h3><hr>
<p>사실 버그라고 해야 할지, 단순히 버전 차이에 따른 차이인지 정확하게는 알 수 없다. 하지만 iOS 13.x 버전과 iOS 14 버전에서의 <code>GeometryReader</code>의 동작 방식에는 차이가 있다. </p>
<p>바로 <code>GeometryReader</code> 하위 뷰들의 정렬 차이인데, 아래의 이미지를 통해 그 차이를 살펴보자.</p>
<p><img src="/2020/07/26/GeometryReader-in-SwiftUI/Differences.png" alt=""></p>
<p>코드의 구조는 대략 아래와 같다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123; </span><br><span class="line">  <span class="type">GeometryReader</span> &#123; </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"…"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">Text</span>(<span class="string">"…"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.x 버전에선 <code>GeometryReader</code>가 <code>Text</code>를 기본적으로 가운데 위치시키지만, iOS 14 버전에선 <code>Text</code>를 왼쪽 상단 모서리에 위치시킨다. 구글링을 해보았지만, 딱히 명확한 이유를 알 수 없었다..😇</p>
<blockquote>
<p>이에 대해 알고 있는 부분이 있으시다면 댓글 부탁드립니다 </p>
</blockquote>
<p>.</p>
<p>.</p>
<p>.</p>
<p><strong>[는 하루만에 이유를 찾았다.] 😅</strong></p>
<p>그 이유는 <a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-12-beta-release-notes">Xcode 12 beta 3 release note</a>에서 찾을 수 있었다.</p>
<blockquote>
<p>Resolved in Xcode 12 beta</p>
<ul>
<li>Rebuilding against the iOS 14, macOS 11, watchOS 7, and tvOS 14 SDKs changes uses of <a href="https://developer.apple.com/documentation/swiftui/geometryreader"><code>GeometryReader</code></a> to reliably top-leading align the views inside the <a href="https://developer.apple.com/documentation/swiftui/geometryreader"><code>GeometryReader</code></a>. This was the previous behavior, <em>except</em> when it wasn’t possible to detect a single static view inside the <a href="https://developer.apple.com/documentation/swiftui/geometryreader"><code>GeometryReader</code></a>. (59722992) (FB7597816)</li>
</ul>
</blockquote>
<p>즉 <strong>top-leading 정렬이 정상 동작</strong>이며, <code>GeometryReader</code>가 단일 정적 뷰를 내부 뷰로 가져갈 경우 이를 감지 못하던 이슈(가운데 정렬시키던)가 해결되었다고 언급하고 있다. </p>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://www.hackingwithswift.com/books/ios-swiftui/understanding-frames-and-coordinates-inside-geometryreader">Understanding frames and coordinates inside GeometryReader</a></li>
<li><a href="https://swiftui-lab.com/geometryreader-to-the-rescue/">GeometryReader to the Rescue</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-19T10:36:32.000Z" title="2020-07-19T10:36:32.000Z">2020-07-19</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></span><span class="level-item">11 minutes read (About 1601 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/19/App-essentials-in-SwiftUI/">App essentials in SwiftUI</a></h1><div class="content"><blockquote>
<p> WWDC 2020을 통해 SwiftUI에선 <code>App</code>과 <code>Scene</code> 개념이 추가됐다. 이를 소개하고 있는 <a href="https://developer.apple.com/videos/play/wwdc2020/10040/">App essentials in SwiftUI</a> 세션을 보고 간단히 정리해보았다. </p>
</blockquote>
<p>새롭게 등장한 <code>App</code>, <code>Scene</code> 개념으로 UIKit 없이 순수 SwiftUI로만 앱을 만들 수 있게 됐다. </p>
<h2 id="Views-scenes-and-apps"><a href="#Views-scenes-and-apps" class="headerlink" title="Views, scenes and apps"></a>Views, scenes and apps</h2><p><img src="/2020/07/19/App-essentials-in-SwiftUI/1.png" alt=""></p>
<p>화면에 보이는 모든 뷰가 하나의 앱에 속하는 것이 아니기 때문에, 하나의 앱이 전체 화면에 대해 완벽히 제어할 수 없다. 나누어진 영역에서 앱이 보여지는 방법은 플랫폼이 제어한다. SwiftUI에선 이렇게 화면 안에 구분된 영역을 <code>Scene</code>이라 부른다. </p>
<p>윈도우는 화면에 보여지는 <code>Scene</code>의 컨텐츠를 보여주는 가장 흔한 방법이다. iPadOS와 같은 플랫폼은 다수의 윈도우를 나란히 보여줄 수 있다. iOS나 watchOS 그리고 tvOS는 각각의 앱에 대해서 하나의 꽉 찬 단일 윈도우를 선호한다. macOS는 <code>Scene</code>의 컨텐츠가 얼마나 다양한 방법으로 보여질 수 있는가를 나타내는 좋은 예다. </p>
<p>macOS에선 아래와 같이 다수의 윈도우로 개별 <code>Scene</code>을 보여주거나 탭으로 여러 <code>Scene</code>을 묶어 보여줄 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/2.png" alt=""><br><img src="/2020/07/19/App-essentials-in-SwiftUI/3.png" alt=""></p>
<p>이렇게 다수의 <code>Scene</code>은 <code>App</code>을 구성하고 <code>App</code>, <code>Scene</code> 그리고 <code>View</code>는 하나의 계층 구조를 이룬다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/4.png" alt=""></p>
<p>아래의 앱과 코드를 살펴보자. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/5.png" alt=""></p>
<p><code>ReadingListViewer</code>는 <code>View</code>로 <code>Scene</code>의 한 종류인 <code>WindowGroup</code>에 속한다. 그리고 <code>WindowGroup</code>은 <code>App</code> 프로토콜을 따르는 <code>BookClubApp</code>의 <code>Scene</code>으로 사용된다. 코드에서 확인할 수 있는 계층구조와 우리가 위에서 살펴본 계층구조가 일치하는 것을 확인할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/6.png" alt=""></p>
<p>그리고 <code>BookClubApp</code>과 <code>ReadingListViewer</code>가 선언된 코드 구조도 유사한 것을 확인할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/7.png" alt=""></p>
<ul>
<li><code>App</code>과 <code>View</code>, 둘 모두 Data Dependency를 선언할 수 있다. <ul>
<li><code>BoolClubApp</code> - <code>@StateObject</code><ul>
<li><code>@StateObject</code>는 이번에 새로 등장한 개념으로 이는 추후에 살펴보도록 하자</li>
</ul>
</li>
<li><code>ReadingListViewer</code> - <code>@ObservedObject</code></li>
</ul>
</li>
<li><code>App</code>과 <code>View</code>, 둘 모두 <code>body</code> 프로퍼티를 통해 사용자 인터페이스를 표시한다. <ul>
<li><code>BookClubApp</code> - <code>var body: some Scene</code></li>
<li><code>ReadingListViewer</code> - <code>var body: some View</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>세션의 주제와 별개로 Swift 5.3부터 등장한 <code>@main</code>이 선언되어 있는 것을 확인할 수 있다. 이는 프로그램의 시작점을 의미한다. 기본적으로 스위프트 프로그램은 <code>main.swift</code>를 필요로 하는데 <code>@main</code>을 통해 <code>App</code> 프로토콜을 따르고 있는 구조체에 해당 책임을 위임할 수 있다. </p>
</blockquote>
<h2 id="Understanding-Scenes"><a href="#Understanding-Scenes" class="headerlink" title="Understanding Scenes"></a>Understanding Scenes</h2><h3 id="WindowGroup"><a href="#WindowGroup" class="headerlink" title="WindowGroup"></a>WindowGroup</h3><p><code>WindowGroup</code>을 통해 다수의 윈도우를 독립적으로 관리할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/8.png" alt=""></p>
<p>그리고 이렇게 독립된 윈도우는 서로 독립된 상태를 갖는데 이것이 SwiftUI에서 <code>Scene</code>의 가장 중요한 특징이라고 할 수 있다. </p>
<p>각각의 독립된 윈도우는 서로의 상태에 영향을 주지 않는다. <code>App</code>은 각 <code>Scene</code>이 사용할 수 있는 Shared Model을 제공할 수 있지만, 각 <code>Scene</code>의 뷰들의 상태는 서로 독립적이다. </p>
<p>그리고 위와 같이 앱 스위처에서 보여지는 타이틀을 뷰 변경자를 통해 윈도우별로 다르게 지정할 수 있다. 이는 부모 <code>Scene</code>의 상태에 영향을 줄 수 있는 변경자 중 하나이다. </p>
<p>macOS에선 <code>WindowGroup</code>을 사용해 아래의 기능들을 제공할 수 있다.</p>
<ul>
<li>다중 윈도우</li>
<li>파일 메뉴에 새 윈도우 생성 메뉴 아이템 추가<ul>
<li>단축키 지원 (<code>Command + N</code>)</li>
</ul>
</li>
<li>윈도우 메뉴<ul>
<li>개별 윈도우를 위한 메뉴 아이템(윈도우 타이틀)</li>
<li>다수의 윈도우를 하나의 탭 인터페이스로 통합하는 기능을 지원하는 메뉴 아이템</li>
</ul>
</li>
</ul>
<p>이 모든 것들은 부가적인 코드 없이 SwiftUI가 자동으로 지원하는 기능들이다. </p>
<p><code>Scene</code>의 생명주기는 실행되고 있는 플랫폼에 의해 관리된다. macOS에선 새 윈도우가 필요하면 <code>WindowGroup</code>은 새 자식 <code>Scene</code>을 생성한다. 이처럼 macOS나 iPadOS와 같이 다중 윈도우를 지원하는 플랫폼에선 <code>WindowGroup</code>은 다수의 자식 <code>Scene</code>을 생성할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/9.png" alt=""></p>
<p>각각의 윈도우는 사용자 인터페이스 정의를 공유하지만 모두 독립된 상태를 갖는다. 그렇기 때문에 하나의 윈도우에서의 변화는 다른 윈도우에 영향을 주지 않는다.</p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/10.png" alt=""></p>
<p>플랫폼이 <code>Scene</code> 생명주기 관리에 책임이 있기 때문에, 각 뷰의 상태를 관리할 수 있는 새 프로퍼티 래퍼인 <code>@SceneStorage</code>라는 개념이 새로 등장했다.</p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/11.png" alt=""></p>
<p>이는 고유 키 값을 이용해 저장될 상태를 식별한다. 그리고 상태는 SwiftUI에 의해 적절한 타이밍에 저장되고 복원된다. </p>
<h2 id="Customizing-Apps"><a href="#Customizing-Apps" class="headerlink" title="Customizing Apps"></a>Customizing Apps</h2><h3 id="Document-based-App"><a href="#Document-based-App" class="headerlink" title="Document based App"></a>Document based App</h3><p>지금까지 살펴본 <code>BookClubApp</code>은 Data-Driven 앱으로 Shared Model을 기반으로 하는 형태의 앱이었다. </p>
<p>이런 형태의 앱뿐만 아니라, 문서 기반의 앱도 존재한다. 이런 형태의 앱에선 <code>DocumentGroup</code>을 사용할 수 있다. </p>
<p><code>DocumentGroup</code>은 열기, 편집, 저장과 같이 문서 기반의 앱을 관리하는데 필요한 기능을 제공하는 <code>Scene</code>의 한 종류다.</p>
<h3 id="Preferences-Window"><a href="#Preferences-Window" class="headerlink" title="Preferences Window"></a>Preferences Window</h3><p>설정 윈도우(<em>Preferences Window</em>)는 macOS 앱들이 제공하는 공통적인 기능 중 하나이다. </p>
<p>이를 위해 macOS에는 새로운 <code>Scene</code> 타입인  <code>Settings</code> 타입이 추가되었다. 이는 기본적인 설정 윈도우와 관련 단축키도 제공한다.</p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/12.png" alt=""></p>
<p>그리고 우린 기본 단축키 이외의 단축키도 새 변경자 API를 통해 지원할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/13.png" alt=""></p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/14.png" alt=""></p>
<hr>
<p>해당 세션을 통해 앱과 관련하여 새로 추가된 기능 및 API들에 대해 간단히 알아볼 수 있었다. 길지 않은 세션이기 때문에 출,퇴근길에 간단하게 시청할 수 있는 세션이었다. </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-15T08:26:52.000Z" title="2020-02-15T08:26:52.000Z">2020-02-15</time><span class="level-item"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></span><span class="level-item">23 minutes read (About 3398 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/15/SwiftUI-under-the-hood/">SwiftUI under the hood</a></h1><div class="content"><p>요즘 SwiftUI를 공부하면서 느낀 점은 마냥 쉽지만은 않다는 것이다. 흔히 SwiftUI를 소개할 때 매우 쉽게 UI를 그릴 수 있는 프레임워크로 소개하곤 하는데, 완전히 틀린 말은 아니지만 그렇다고 완전히 맞는 말도 아닌 것 같다. SwiftUI를 공부하면서 처음 iOS를 공부했을 때, 더 나아가 처음 프로그래밍을 공부했을 때가 종종 생각나곤 한다. </p>
<p>당시 처음으로 프로그래밍 언어를 가르쳐 주신 강사님으로부터 기본적인 C 언어 문법을 배우고 모든 걸 배운 것처럼 기세등등했던 적이 있다. 자신감이 한없이 하늘을 찌르고 있을 때 강사님은 다음과 같은 말씀을 해주셨다. </p>
<p>*”원래 처음 프로그래밍을 배우고 기본 문법을 마친 사람들이 프로그래밍을 매우 쉽다고 생각하고 자만하게 됩니다. 하지만 공부를 하면 할수록 어렵게 느껴지고 자신감이 떨어질 수 있는 공부가 프로그래밍입니다.”*</p>
<blockquote>
<p>비단 프로그래밍에만 국한되는 이야기는 아닌 것 같다.</p>
</blockquote>
<p>당시에는 이해가 가질 않았으나, 본격적으로 학부 공부를 시작하고 취업 준비를 하면서 저 말이 계속해서 떠올랐고 자신감이 자주 떨어지곤 했다. SwiftUI를 공부하면서도 마찬가지였다. 처음 <code>VStack</code>, <code>List</code> 등을 사용하면서 그 간편함에 놀라고 매우 쉽다고 생각했다. 하지만 데이터의 흐름과 레이아웃이 결정되는 방식 등 깊게 파고들면 파고들수록 머릿속은 여러 개념들이 완전하지 않은 채  뒤엉키게 되었다. 그렇게 혼란스러워하던 중 한 컨퍼런스에서 Chris Eidhof가 “SwiftUI under the hood”란 주제로 발표한 영상을 보고 복잡하고 산발되어 있던 개념들이 어느 정도 정리가 되면서 여러 개념들의 존재 이유와 목적에 대해 감을 잡을 수 있었다. 오늘은 그 영상의 내용을 요약 및 정리해보는 시간을 가지려 한다. </p>
<blockquote>
<p>영상 : <a href="https://youtu.be/GuK6wwX8M0E">Chris Eidhof - SwiftUI under the hood</a></p>
</blockquote>
<p>영상에서 다루는 큰 주제는 레이아웃 알고리즘이다. 즉 SwiftUI가 어떤 방식으로 레이아웃을 그리는지에 대해 다룬다. 이를 설명하면서 <code>GeometryReader</code>, <code>Preference</code> 등 중요한 개념들이 자연스럽게 등장하며 설명을 돕는다.</p>
<p>서론이 너무 길었다. 바로 시작해보자.</p>
<hr>
<h3 id="Layout-Algorithm"><a href="#Layout-Algorithm" class="headerlink" title="Layout Algorithm"></a>Layout Algorithm</h3><p>파란색 배경의 원 안에 텍스트가 존재하는 뷰를 만든다고 상상해보자. 원이 아닌 다양한 도형이 될 수 있다. 즉 매우 흔한 상황이다. 우리가 원하는 결과물은 다음과 같을 것이다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/0.5.png" alt=""></p>
<p>매우 쉬워 보인다! 그럼 코드로 이를 만들어보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">	.background(</span><br><span class="line">    <span class="type">Circle</span>()</span><br><span class="line">    .fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>기대하던 모습이 나올까? 그렇지 않다. 그 모습은 우리가 기대하던 모습과 거리가 멀다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/1.png" alt=""></p>
<p>이유가 무엇일까? 그 이유를 알기 위해선 SwiftUI의 레이아웃 알고리즘에 대한 이해가 있어야 한다. 모든 레이아웃은 다음 4가지 단계를 통해 그려진다. </p>
<ol>
<li>컨테이너 뷰(직계 상위 뷰)가 사이즈를 제안한다. </li>
<li>하위 뷰가 자신의 사이즈를 결정한다. (하위 뷰는 상위 뷰가 제안한 사이즈를 그대로 사용하거나, 본인이 자신의 사이즈를 결정하기도 한다.)</li>
<li>하위 뷰가 컨테이너 뷰에 자신의 사이즈를 알린다. (2단계에서 결정된 사이즈로 컨테이너 뷰의 사이즈가 정해진다.)</li>
<li>컨테이너 뷰가 하위 뷰를 가운데 정렬 시킨다. (<code>alignment</code>)</li>
</ol>
<p>이는 아주 기본적인 절차이고 여러 값들의 재정의를 통해 변경될 수 있다. 그럼 이 알고리즘을 바탕으로 위의 코드를 분석해보자. 먼저 위의 코드로 그려진 뷰의 계층을 뷰 디버깅을 통해 살펴보고 아래 설명을 따라가면서 이해해보자.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/3.png" alt=""></p>
<ol>
<li><p>먼저 루트 뷰(root view)가 화면 전체 사이즈를 <code>background</code>에게 제안한다. 그리고 <code>background</code>는 이를 다시 <code>Text</code>에게 전달한다. </p>
<blockquote>
<p>Modifier는 새로운 뷰를 만들고 이전 뷰를 감싸서 반환한다는 것을 기억한다면 <code>background</code>가 <code>Text</code>를 감싸고 있다는 것을 이해할 수 있다. </p>
</blockquote>
</li>
<li><p>하지만 <code>Text</code>는 자신이 담고 있는 내용만큼만 필요하기 때문에 <code>&quot;Reset&quot;</code>만큼만 사용할 것을 <code>backgroud</code>에 알린다. </p>
</li>
<li><p>그럼 다시 <code>background</code>는 이를 하위 뷰인 <code>ShapeView</code>에 알리고 <code>ShapeView</code>는 이를 <code>Circle</code>에게 알린다. (<code>ShapeView</code>와 <code>Text</code>는 형제-자매(sibling) 관계다.) <code>Circle</code>는 받은 크기(<code>Text</code>의 크기)를 그대로 사용해서 그 크기에 딱 맞는 원을 그린다.</p>
</li>
<li><p>그리고 이를 <code>background</code>에게 전달하고 <code>background</code>는 다시 이 크기를 루트 뷰에 전달하고 루트 뷰는 해당 뷰를 가운데 정렬한다.</p>
</li>
</ol>
<p>뷰 계층과 알고리즘을 따라가보면 왜 우리가 원하는 레이아웃이 나오지 않았는지에 대해 이해할 수 있다. 그럼 우리가 원하는 레이아웃을 그리기 위해선 어떻게 해야 할까?</p>
<p>가장 먼저 떠오르는 생각은 <code>frame</code> 변경자를 사용하는 것이다. 사용하기에 앞서 <code>frame</code> 변경자의 특징을 알아야 한다. <strong><code>frame</code> 변경자는 상위 뷰에서 오는 크기 정보나, 하위 뷰에서 알려주는 크기 정보를 모두 무시하고 자신의 인자로 넘어온 크기 정보만 사용한다.</strong> 이 점을 기억하고 아래 코드를 살펴보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line"><span class="comment">//.frame(width: 75, height: 75) // --- 1</span></span><br><span class="line">	.background(</span><br><span class="line">    <span class="type">Circle</span>()</span><br><span class="line">    	.fill(<span class="type">Color</span>.blue)</span><br><span class="line"><span class="comment">//    .frame(width: 75, height: 75) // --- 2</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">//.frame(width: 75, height: 75) // --- 3</span></span><br></pre></td></tr></table></figure>

<p><code>frame</code> 연산자를 1, 2번 두 곳 중 한 곳에만 위치시켜도 원하는 레이아웃을 그릴 수 있다. 하지만 두 곳 모두 문제점을 갖고 있다. </p>
<ol>
<li><p>위에서 언급했듯이 <code>frame</code>은 하위 뷰에서 알려준 크기 정보도 무시한다. 즉 <code>Text</code>가 정한 크기도 무시한다는 뜻이다. 그렇기 때문에 이곳에 <code>frame</code>을 위치시면 길어진 문자열 크기를 <code>Text</code>가 아무리 <code>frame</code>에 알려도 <code>frame</code>은 자신의 정보로 크기를 결정하기 때문에 문자열은 75x75 영역 안에서 벗어날 수 없고, 해당 영역 안에 표시되지 못한 부분은 말 줄임표(<code>...</code>)로 나타나게 된다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/5.png" alt=""></p>
</li>
<li><p><code>frame</code> 영역은 <code>Circle</code>에만 영향을 주기 때문에 문자열이 길어지면 원의 영역을 벗어난다. </p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/6.png" alt=""></p>
</li>
</ol>
<p><code>frame</code>을 3번에 위치시키면 어떻게 될까? <code>frame</code>이 이 크기 정보(75x75)를 <code>background</code>에게 <code>background</code>가 다시 <code>Text</code>에 전달하지만 <code>Text</code>는 자신이 담고 있는 내용만큼만 사용한다고 <code>background</code>에 알리고 <code>background</code>는 이 정보를 다시 <code>Circle</code>에 전달하기 때문에 결과적으로 위에서 봤던 레이아웃과 동일한 것을 육안으로 확인할 수 있다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/4.png" alt=""></p>
<p>육안으로 확인한 레이아웃이 같다고 실제로 그 둘이 같은 것은 아니다. 전체를 감싸고 있는 뷰의 크기 차이가 존재한다(파란 테두리가 감싸고 있는 영역). 그 이유는 위에서 언급했듯이 <code>frame</code>은 하위 뷰에서 보낸 정보도 무시하기 때문에 자신의 크기 정보(75x75)를 사용한다. 그렇기 때문에 전체를 감싸고 있는 뷰의 크기에 차이가 생기는 것이다.</p>
<p>문제를 해결하기 위해선 <code>frame</code> 안에 들어갈 값은 문자열의 길이에 따라 동적으로 변경되어야 한다. 정확히는 <code>Text</code>의 크기에 따라 변경되어야 한다. 그럼 <code>Text</code>의 크기는 어떻게 알 수 있을까? UIKit을 사용할 땐 객체에 직접 접근해 값을 가져올 수 있었다. 하지만 SwiftUI에선 불가능하다. 우리는 이 문제점을 <code>GeometryReader</code>를 사용해 해결해보려 한다. </p>
<h3 id="GeometryReader"><a href="#GeometryReader" class="headerlink" title="GeometryReader"></a>GeometryReader</h3><p><code>GeometryReader</code>는 SwiftUI에서 중요한 개념이지만 이번 포스팅에선 현재 상황에서 <code>GeometryReader</code>가 해결할 수 있는 부분에 대해서만 간단하게 설명해보고자 한다. </p>
<p><code>GeometryReader</code>는 컨테이너 뷰의 한 종류로 자신의 직계 상위 뷰의 기하학(Geometry) 정보(좌표, 크기 등)를 자신이 포함하는 자식 뷰에게 제공하는 역할을 한다. 그럼 바로 사용해보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">	.padding()</span><br><span class="line">	.fixedSize()</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span> </span><br><span class="line">    	<span class="comment">// proxy.size.width == Text("Reset")'s width               </span></span><br><span class="line">		&#125;</span><br><span class="line">  )</span><br><span class="line">	.frame(width: <span class="number">75</span>, height: <span class="number">75</span>)</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">Circle</span>()</span><br><span class="line">    	.fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>fixedSize</code> 변경자는 <code>Text</code>에만 존재하는 변경자로 아무리 문자열이 길어져도 1줄에 보여주도록 강제한다. 이를 사용하면 위에서 보았던 이미지처럼 주어진 크기 안에서 문자열이 길어질 때 여러 줄과 함께 말 줄임표로 보여주는 것이 아니라 영역을 벗어나더라도 문자열을 1줄에 보여줄 수 있다.</p>
</blockquote>
<p>단순히 직계 상위 뷰의 정보를 받아온다고 생각하지 말고 위에서 살펴보았던 레이아웃 결정 과정을 대입해서 생각해보자.</p>
<ol>
<li><code>background</code>는 루트 뷰로부터 크기를 제안받는다. </li>
<li><code>background</code>는 그 크기를 <code>Text</code>에게 제안한다.</li>
<li><code>Text</code>는 자신이 포함하는 내용만을 담을 수 있는 크기를 사용하기로 결정하고 이를 <code>background</code>에게 알린다.</li>
<li><code>background</code>는 그 정보를 <code>GeometryReader</code>에게 알린다. </li>
</ol>
<p>이런 순서로 <code>GeometryReader</code>는 직계 상위 뷰의 정보를 받아올 수 있는 것이다. 정확히 표현하자면 <code>Text</code>에 의해 결정된 크기를 사용하는 <code>background</code>의 크기 정보를 받아온 것이다. 그럼 우린 이 크기 정보를 사용하면 된다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> width: <span class="type">CGFloat?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">	.padding()</span><br><span class="line">	.fixedSize()</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span> </span><br><span class="line">      <span class="keyword">self</span>.width = proxy.size.width</span><br><span class="line">		&#125;</span><br><span class="line">  )</span><br><span class="line">	.frame(width: <span class="keyword">self</span>.width, height: <span class="keyword">self</span>.width)</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">Circle</span>()</span><br><span class="line">    	.fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>위와 같이 코드를 작성할 수 있을 것 같지만 실제로 이렇게 작성하면 에러가 발생한다. 왜냐하면 <code>GeometryReader</code>는 생성자로 <code>@ViewBuilder</code>를 받기 때문에 <code>self.width = proxy.size.width</code>와 같은 코드는 <code>@ViewBuilder</code> 안에 작성할 수 없다.</p>
<p>우린 이 시점에서 프록시(<code>GeometryProxy</code>)에 담긴 크기 정보를 바로 <code>width</code> 프로퍼티에 할당할 수 없다. 우린 이 정보를 뷰 계층 위로 전달해야 한다. 이렇게 하위 뷰에서 상위 뷰로 정보를 전달하기 위해서 사용하는 것이 바로 <code>Preference</code>다.</p>
<h3 id="Preference"><a href="#Preference" class="headerlink" title="Preference"></a>Preference</h3><p><code>Preference</code> 역시 <code>GeometryReader</code>와 마찬가지로 굉장히 중요한 개념 중 하나이다. 하지만 마찬가지로 현재 상황에서 <code>Preference</code>가 해결할 수 있는 부분에 대해서만 간단하게 설명해보고자 한다. </p>
<p><code>Preference</code>는 키-밸류 메커니즘으로 하위 뷰 정보를 상위 뷰에 전달할 수 있는 수단이다. 이를 위해선 먼저 <code>PreferenceKey</code> 프로토콜을 따르는 키를 정의해주어야 한다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SizeKey</span>: <span class="title">PreferenceKey</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">reduce</span><span class="params">(value: <span class="keyword">inout</span> CGFloat?, nextValue: <span class="params">()</span></span></span> -&gt; <span class="type">CGFloat?</span>) &#123;</span><br><span class="line">    value = nextValue()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>간단하게 설명하자면 <code>reduce</code> 메소드는 <code>SizeKey</code>를 사용하는 하위 뷰들을 순회하면서 상위 뷰가 접근할 수 있는 값을 만들기 위해 이들의 값(<code>SizeKey</code>를 사용하는 하위 뷰의 값) 취합하는 역할을 한다.</p>
<blockquote>
<p>이번 포스팅에선 단순히  <code>PreferenceKey</code>의 기능만을 소개하지만 추후 포스팅에서 더욱 자세히 다룰 예정이다. 하지만 당장 궁금하다면 <a href="https://swiftui-lab.com/communicating-with-the-view-tree-part-1/">이 글</a>을 참고하면 좋을 것이다.</p>
</blockquote>
<p>그리고 간단한 트릭(?)을 사용해서 우린 뷰 계층 위로 <code>proxy</code> 정보를 전달할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> width: <span class="type">CGFloat?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">    .padding()</span><br><span class="line">    .fixedSize()</span><br><span class="line">    .background(</span><br><span class="line">      <span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">				<span class="type">Color</span>.clear.preference(key: <span class="type">SizeKey</span>.<span class="keyword">self</span>, value: proxy.size.width) <span class="comment">// --- 1</span></span><br><span class="line">			&#125;</span><br><span class="line">    )</span><br><span class="line">    .frame(width: <span class="keyword">self</span>.width, height: <span class="keyword">self</span>.width)</span><br><span class="line">    .background(</span><br><span class="line">      <span class="type">Circle</span>()</span><br><span class="line">      .fill(<span class="type">Color</span>.blue)</span><br><span class="line">    )</span><br><span class="line">    .onPreferenceChange(<span class="type">SizeKey</span>.<span class="keyword">self</span>) &#123; value <span class="keyword">in</span> <span class="comment">// --- 2</span></span><br><span class="line">			<span class="keyword">self</span>.width = value</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Color</code>도 <code>View</code> 프로토콜을 따른다. 그렇기 때문에 사용자는 볼 수 없는 <code>Color.clear</code>에 <code>preference</code>를 통해 <code>proxy.size.width</code>를 전달하고 있다. </li>
<li>상위 뷰(<code>Text</code>)에선 하위 뷰에서 전달한 정보를 <code>onPreferenceChange</code>를 통해 받을 수 있다. </li>
</ol>
<p>이제 진짜 우리가 원하던 레이아웃을 확인할 수 있을 것이다. </p>
<hr>
<h3 id="정리하며"><a href="#정리하며" class="headerlink" title="정리하며"></a>정리하며</h3><p>간단한 레이아웃(?)을 그려보면서 SwiftUI를 관통하는 여러 개념들을 자연스럽게 접해볼 수 있던 영상이었다. SwiftUI가 레이아웃을 그리는 알고리즘에 대해 이해하고 나니 왜 그렇게 그려지는지 이해가 가지 않았던 부분들이 어느정 도 머릿속에 정리가 되는 시간이었다.</p>
<blockquote>
<p>영상 말미에 한 가지 과제(?)를 주는데 이 부분은 <a href="https://github.com/ehdrjsdlzzzz/SwiftUI-practice/tree/master/SwiftUIUnderTheHood">github</a>에 올려놓았습니다.</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-08T11:16:48.000Z" title="2020-01-08T11:16:48.000Z">2020-01-08</time><span class="level-item"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></span><span class="level-item">6 minutes read (About 967 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/08/SwiftUI%EC%97%90%EC%84%9C-%EC%97%AC%EB%9F%AC-%ED%83%80%EC%9E%85%EC%9D%98-%EB%B7%B0-%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0/">SwiftUI에서 여러 타입의 뷰 반환하기</a></h1><div class="content"><p>지난 포스팅에서 불투명 타입(Opaque Type)에 대해 공부했었다. </p>
<blockquote>
<p>글 : <a href="https://ehdrjsdlzzzz.github.io/2019/12/12/Opaque-Types-in-Swift/">Opaque Types in Swift</a></p>
</blockquote>
<p>당시 우리는 불투명 타입을 반환할 땐 타입 정체성(Identity)를 잃지 않기 위해 한 가지 타입만 반환해야 한다고 공부했다. 하지만 개발을 하다 보면 여러 예외 상황을 마주하게 되는데 이는 불투명 타입도 마찬가지다. </p>
<p>먼저 SwiftUI로 프로젝트를 생성했을 때 마주하게 되는 기본 <code>ContentView</code> 코드를 살펴보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>body</code> 프로퍼티는 <code>some View</code> 타입이기 때문에 한 가지 타입만 반환할 수 있다. 그래서 뷰 계층을 작성할 때 우리는 아래와 같은 구조에 익숙하다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    ...<span class="type">View</span> &#123; </span><br><span class="line">    	...<span class="type">View</span> &#123; </span><br><span class="line">        ...<span class="type">View</span> &#123; </span><br><span class="line">          ...<span class="type">View</span> &#123; </span><br><span class="line">          </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>some View</code>를 반환해야 하기 때문에 위와 같은 구조의 코드에 익숙하다. 하지만 조건에 따라 다른 타입의 뷰를 보여주어야 한다면 어떻게 해야 할까?</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">  	<span class="keyword">if</span> isLogIn &#123; </span><br><span class="line">      <span class="type">Image</span>(<span class="string">"User-Avatar"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Please Login"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 코드를 작성하면 우리는 <code>Function declares an opaque return type, but has no return statements in its body from which to infer an underlying type</code>와 같은 에러 메시지를 볼 수 있다. </p>
<p>하지만 언제나 방법은 있다! 게다가 두 가지씩이나! 그럼 그 두 가지를 살펴보자. </p>
<h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><p> <strong><code>Group</code>은 어떠한 레이아웃 특성도 지니지 않는다.</strong> <code>Group</code> 안에서는 위와 같이 조건 분기를 통한 두 가지 타입을 반환할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="type">Group</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> isLogIn &#123; </span><br><span class="line">        <span class="type">Image</span>(<span class="string">"User-Avatar"</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Please Login"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>오늘의 주제와 별개로 <code>Group</code>의 사용 예를 한 가지 더 들어보자면 기본적으로 뷰 빌더 안에는 최대 10개 뷰만 들어갈 수 있다. 10개가 넘어가면 에러 메시지를 출력하는데, 이때 우리는 <code>Group</code>을 사용해 레이아웃을 해치지 않으면서 10개 이상의 뷰를 추가할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="type">VStack</span> &#123; </span><br><span class="line">      <span class="type">Group</span> &#123; </span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="type">Group</span> &#123; </span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="AnyView"><a href="#AnyView" class="headerlink" title="AnyView"></a>AnyView</h3><p><code>Group</code> 말고도 우린 <code>AnyView</code>를 통해 두 가지 타입의 뷰를 반환할 수 있다. 정확하게는 타입을 지워(Type erase) 하나의 타입이 반환되는 것처럼 보이게 하는 것이다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> isLogIn &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="type">AnyView</span>(<span class="type">Image</span>(<span class="string">"User-Avatar"</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="type">AnyView</span>(<span class="type">Text</span>(<span class="string">"Please Login"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만 <code>AnyView</code>는 성능 비용이 높기 때문에 사용하는 것을 지양한다. <code>AnyView</code>의 공식 문서에는 다음과 같은 내용이 있다. </p>
<p><strong><em>Whenever the type of view used with an <code>AnyView</code> changes, the old hierarchy is destroyed and a new hierarchy is created for the new type</em></strong></p>
<blockquote>
<p><code>AnyView</code>와 함께 사용된 뷰가 변할 때마다 이전 뷰 계층을 파괴하고 새로 만들기 때문에 이 부분에서 성능 비용이 높다고 설명하는 것 같다. </p>
</blockquote>
<p>하지만 또 이 부분에 대해 <a href="https://medium.com/swlh/swiftui-performance-battle-anyview-vs-group-55bf852158df"><code>Group</code>과 성능 비교를 한 글</a>도 확인할 수 있었다. 이 비교 실험 글에 따르면 사실상 큰 차이는 없다고 나온다. 또한 이 글에선 <code>body</code>에서 뷰 상태의 바인딩을 최소한으로 하는 것이 성능 향상에 더 도움이 된다고 언급하고 있다. </p>
<blockquote>
<p>상태에 의존하는 뷰가 많을수록 rebuild 횟수가 증가할 가능성이 크기 때문에 이렇게 말하고 있는 것으로 생각된다.</p>
</blockquote>
<hr>
<p>오늘은 SwiftUI에서 여러 타입의 뷰를 반환하는 두 가지 방법에 대해 알아보았다. </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-03T12:27:18.000Z" title="2020-01-03T12:27:18.000Z">2020-01-03</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">9 minutes read (About 1323 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/03/Property-Wrappers-in-Swift/">Property Wrappers in Swift</a></h1><div class="content"><p>Property wrapper는 프로퍼티를 정의하는 코드(<em>code that defines a property</em>)와 프로퍼티가 어떻게 저장되는지를 관리하는 코드(<em>code that manages how a property is stored</em>) 사이의 계층(<em>layer</em>)이다.</p>
<p><img src="/2020/01/03/Property-Wrappers-in-Swift/property_wrapper.png" alt=""></p>
<p>Property wrapper를 사용하면 정의할 때 관리 코드(management code)를 한 번만 작성하고 여러 프로퍼티에 <strong>재사용</strong>할 수 있다. 사실 이런 wrapper 개념은 이번에 갑자기 나타난 것이 아니다. <code>lazy</code>나 <code>@NSCopying</code> 같은 키워드도 wrapper의 한 종류다. 하지만 Swift 5.1에선 개발자가 이런 wrapper를 직접 만들 수 있게 되었다.</p>
<p>Property wrapper를 이해하기 위해선 Property wrapper가 어떤 문제를 해결할 수 있는지를 보면 된다. 객체 안의 프로퍼티에 값이 할당될 때마다 로그를 출력해주어야 한다고 가정해보자. 우린 다음과 같이 코드를 작성할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; _x &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      _x = newValue</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"New value is \(newValue)"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="type">Bar</span>()</span><br><span class="line">bar.x = <span class="number">1</span> <span class="comment">// Prints 'New value is 1'</span></span><br></pre></td></tr></table></figure>

<p>가장 직관적인 방법이다. 하지만 객체 안에 <code>x</code>뿐만 아니라 수많은 프로퍼티가 존재하고 이런 프로퍼티 모두가 값이 할당될 때마다 로그를 출력해주어야 한다면 상황은 달라진다. </p>
<p>이런 상황을 해결하기 위해 우린 새로운 타입을 정의해줄 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = wrappedValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; </span><br><span class="line">      value = newValue</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"New value is \(newValue)"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 기존의 <code>Bar</code> 구조체를 아래와 같이 <code>ConsoleLogged</code> 타입을 사용해 바꿀 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _x = <span class="type">ConsoleLogged</span>&lt;<span class="type">Int</span>&gt;(wrappedValue: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; _x.wrappedValue &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; _x.wrappedValue = newValue &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="type">Bar</span>()</span><br><span class="line">bar.x = <span class="number">1</span> <span class="comment">// Prints 'New value is 1'</span></span><br></pre></td></tr></table></figure>

<p>이렇게 <code>ConsoleLogged</code> 타입을 사용해 중복 코드를 줄일 수 있다. Swift 5.1에선 이런 패턴을 Property wrapper라는 <em>Syntatic Sugar</em>로 제공한다. 사용 방법은 매우 간단하다. 기존의 <code>ConsoleLogged</code>에 <code>@propertyWrapper</code>만 붙이면 된다. <code>@propertyWrapper</code>를 타입(<code>struct</code>, <code>class</code>, <code>enum</code>) 앞에 붙이고 <code>wrappedValue</code>만 정의해주면 된다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = wrappedValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; </span><br><span class="line">      value = newValue</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"New value is \(newValue)"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>프로퍼티가 어떻게 저장되는지를 관리하는 코드(<em>code that manages how a property is stored</em>) </p>
</blockquote>
<p>이렇게 선언한 Property wrapper는 사용하기도 쉽다. 아래와 같이 두 가지 방법으로 Property wrapper를 사용할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123; </span><br><span class="line">  @<span class="type">ConsoleLogged</span> <span class="keyword">var</span> x = <span class="number">0</span> <span class="comment">// 1</span></span><br><span class="line">  @<span class="type">ConsoleLogged</span>(wrappedValue: <span class="number">2</span>) <span class="keyword">var</span> y <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>프로퍼티를 정의하는 코드(<em>code that defines a property</em>)</p>
</blockquote>
<p>Property wrapper 안에는 <code>wrappedValue</code>와 같이 프로퍼티뿐만 아니라 메소드도 정의할 수 있다. 하지만 안에 정의된 메소드를 사용할 땐 스코프(<em>scope</em>)에 주의할 필요가 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Foo"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 Property wrapper안에 <code>foo</code>라는 메소드를 정의했다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HasWrapper</span> </span>&#123;</span><br><span class="line">    @<span class="type">Wrapper</span> <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; _x.foo() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그럼 당연히 <code>Wrapper</code>를 Property wrapper로 사용하는 객체 내부에선 <code>foo</code> 메소드를 사용할 수 있다. (<code>_x.foo()</code>)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">HasWrapper</span>()</span><br><span class="line">a._x.foo() <span class="comment">// ❌ '_x' is inaccessible due to 'private' protection level</span></span><br></pre></td></tr></table></figure>

<p>하지만 위와 같이 외부에서의 접근은 불가능하다. 이유는 <code>private</code> 수준의 접근 제어를 갖기 때문이다. 물론 외부에서 접근할 수 있는 방법은 존재한다. <code>projectedValue</code>를 사용하면 된다. </p>
<p>우리는 <code>projectedValue</code>를 통해 부수적인 API를 외부에 노출시킬 수 있다. <code>wrappedValue</code>와 다르게 <code>projectedValue</code>는 타입의 제한이 없다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> projectedValue: <span class="type">Wrapper</span>&lt;<span class="type">T</span>&gt; &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Foo"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 우리는 <code>projectedValue</code>를 <code>x</code>에 <code>$</code>을 붙여 접근할 수 있다.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">HasWrapper</span>()</span><br><span class="line">a.$x.foo() <span class="comment">// Prints 'Foo'</span></span><br></pre></td></tr></table></figure>

<p>SwiftUI엔 <code>@State</code>, <code>@Binding</code>과 같은 빌트인 Property wrapper가 존재한다. 이에 대해선 추후 다루게 될 SwiftUI 포스팅에서 하나씩 살펴보도록 하자. </p>
<p>이번 포스팅에선 간단한 예로 <code>UserDefaults</code>를 Property wrapper를 통해 보다 간편하게 사용할 수 있는 예제를 살펴보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserDefault</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> key: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> initialValue: <span class="type">T</span></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123; <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: key) &#125;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="type">UserDefaults</span>.standard.object(forKey: key) <span class="keyword">as</span>? <span class="type">T</span> ?? initialValue &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>먼저 <code>UserDefault</code>라는 Property wrapper를 위와 같이 정의했다. <code>initialValue</code>를 통해 값이 존재하지 않을 때 초기값을 제공할 수 있다. 그리고 아래와 같이 사용할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">  @<span class="type">UserDefault</span>(key: <span class="string">"isCheatModeEnabled"</span>, initialValue: <span class="literal">false</span>) <span class="keyword">static</span> <span class="keyword">var</span> isCheatModeEnabled: <span class="type">Bool</span></span><br><span class="line">  @<span class="type">UserDefault</span>(key: <span class="string">"highestScore"</span>, initialValue: <span class="number">10000</span>) <span class="keyword">static</span> <span class="keyword">var</span> highestScore: <span class="type">Int</span></span><br><span class="line">  @<span class="type">UserDefault</span>(key: <span class="string">"nickname"</span>, initialValue: <span class="string">"cloudstrife97"</span>) <span class="keyword">static</span> <span class="keyword">var</span> nickname: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">UserPreferences</span>.isCheatModeEnabled = <span class="literal">true</span></span><br><span class="line"><span class="type">UserPreferences</span>.highestScore = <span class="number">25000</span></span><br><span class="line"><span class="type">UserPreferences</span>.nickname = <span class="string">"squallleonhart"</span></span><br></pre></td></tr></table></figure>

<p>물론 Property wrapper로 선언된 프로퍼티에도 한계가 존재한다. </p>
<ul>
<li>하위 클래스에서 오버라이딩될 수 없다. </li>
<li><code>lazy</code>, <code>weak</code>, <code>@NSCopying</code>과 같이 사용할 수 없다. </li>
<li>커스텀 <code>set</code>, <code>get</code>을 사용할 수 없다.</li>
<li>프로토콜이나 익스텐션에서 선언될 수 없다. </li>
</ul>
<p>오늘은 Swift 5.1에 새로 추가된 Property wrapper에 대해 매우 간단히 알아보았다. 이후에는 SwiftUI에서 사용되고 있는 Property wrapper들에 대해서 소개해보려 한다. </p>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://devsday.ru/blog/details/3752">The Complete Guide to Property Wrappers in Swift5</a></li>
<li><a href="https://medium.com/swlh/understanding-property-wrappers-in-swift-by-examples-604206022b5c">Understanding Property Wrappers in Swift By Examples</a></li>
<li><a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html">Swift Docs</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-26T12:10:52.000Z" title="2019-12-26T12:10:52.000Z">2019-12-26</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></span><span class="level-item">19 minutes read (About 2789 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/26/SwiftUI-Essentials-2/">SwiftUI Essentials (2)</a></h1><div class="content"><h2 id="Building-custom-views"><a href="#Building-custom-views" class="headerlink" title="Building custom views"></a>Building custom views</h2><p>SwiftUI로 커스텀 뷰를 만드는 방식에 대해 이야기 해보자. </p>
<p>주문 내역을 보여주는 <code>OrderHistory</code>를 살펴보자.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/1.png" alt=""></p>
<p>위의 코드에서 먼저 살펴볼 부분은 바로 <code>View</code> 프로토콜을 따르고 있는 <code>OrderHistory</code>가 구조체로 선언되어 있다는 점이다.</p>
<p>일반적으로 UIKit으로 뷰를 만들면 프로토콜을 따르는 구조체가 아닌 공통 부모 클래스로부터 상속받는 클래스를 작성하곤 한다. <code>OrderHistory</code>를 UIKit으로 만든다면 다음과 같은 상속 관계를 가질 것이다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/2.png" alt=""></p>
<p><code>UIView</code>는 <code>alpha</code>나 <code>backgroundColor</code> 같은 공통된 저장 프로퍼티(stored property)를 갖고 있다. <code>OrderHistory</code>는 자신의 <code>previousOrders</code> 프로퍼티와 더불어 부모 클래스의 프로퍼티까지 갖고 있게 된다. 반면에 SwiftUI는 어떨까? </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/3.png" alt=""></p>
<p>SwiftUI는 이런 공통된 저장 프로퍼티를 분리된 변경자로 관리하고 각각의 변경자는 자신들만의 뷰를 생성하게 된다. 그러므로 공통된 저장 프로퍼티는 뷰 계층 전반에 걸쳐 분산된다. 이러한 방식으로 뷰를 더 가볍게 해서 각 뷰의 고유 목적에 맞게 최적화한다.</p>
<p>이러한 방식 때문에 SwiftUI에서 뷰가 프로토콜이 된다고 할 수 있는 것이다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/4.png" alt=""></p>
<p>그럼 뷰는 무엇을 하는 것일까?</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/5.png" alt=""></p>
<p>뷰는 단지 UI의 한 조각을 정의할 뿐이고 우린 이런 뷰들을 이용하고 재사용하여 뷰 계층을 구성하는 것이다. <code>View</code> 프로토콜의 살펴보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/6.png" alt=""></p>
<p>위의 코드를 보고 있으면 어떤 생각이 드는가? 재귀적이지 않은가? </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/7.png" alt=""></p>
<p>하나의 뷰가 있고 그 뷰의 <code>body</code>가 다른 뷰를 나타내고 그 뷰의 <code>body</code>가 또 다른 뷰를 나타내는 이런 구조를 보일 수 있다고 생각할 수 있는데 이는 지속되지 않는다. 그 이유는 SwiftUI가 스스로 컨텐츠를 갖지 않고 다른 뷰를 구성하는 아토믹(atomic)한 뷰인 원시 뷰(primitive view)를 제공하고 위와 같은 <code>body</code> 사슬의 끝은 결국 이런 원시 뷰이기 때문이다.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/8.png" alt=""></p>
<p>우리가 위에서 보았던 <code>Text</code>나 <code>Image</code>와 더불어 드로잉에 사용되는 <code>Color</code>와 <code>Shape</code>, 레이아웃에 사용되는 <code>Spacer</code>와 같은 다양한 원시 뷰를 제공한다. </p>
<p>다시 <code>OrderHistory</code>로 돌아와 클래스가 아닌 구조체로 정의된 것에 주목해보자. 클래스로 정의한 것이 아니기 때문에 <code>OrderHistory</code>는 더 이상 이벤트 기반으로 동작하는 명령형 코드로 갱신되는 영구적인 객체가 아니다.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/9.png" alt=""></p>
<p>대신 뷰는 Input에 따라 결과가 달라지는 함수와 같이 선언형 코드로 정의된다. 이 말은 Input이 변경되면 SwiftUI가 <code>body</code> 프로퍼티를 다시 호출해서 뷰를 갱신한다.</p>
<p>만일 이벤트 기반의 명령형 코드였다면 Input의 변경(삭제, 삽입 등)에 따른 갱신 코드를 작성해주어야 했는데, SwiftUI에서는 선언형 코드로 인풋이 변경되면 SwiftUI가 내부적으로 이전 데이터와 새 데이터를 비교해서 무엇이 변경되었는지를 비교 후 효율적으로 뷰를 갱신하게 된다.</p>
<p><code>OrderHistory</code> 코드를 계속해서 살펴보자. 조건에 따라 뷰의 유무를 표시할 때 우리는 다음과 같이 뷰 빌더 클로저 안에 조건문을 통해 이를 구현할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/10.png" alt=""></p>
<p>하지만 이런 조건문도 상황에 따라 제대로 사용해야 한다. 다음 상황의 코드를 살펴보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/11.png" alt=""></p>
<p><code>flipped</code> 값에 따라 아이콘의 각도를 다르게 보여주고 싶을 때 위와 같이 작성할 수 있다. 하지만 이는 잘못된 방법이다. 이런 코드는 부자연스러운 애니메이션을 만들게 된다. 이 코드는 SwiftUI에게 서로 다른 뷰 중 하나를 선택하게 하는 것이고 이는 곧 뷰의 추가와 삭제를 의미한다. 뷰의 추가와 삭제는 fade 애니메이션이 적용되기에 부자연스러운 애니메이션을 보게 되는 것이다. </p>
<p>우리가 원하는 자연스러운 애니메이션을 위해선 다음과 같이 코드를 작성해야 한다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/12.png" alt=""></p>
<p>여기서 얻을 수 있는 교훈은 이런 조건에 따라 다른 값에 의한 뷰의 변화를 부드러운 애니메이션을 통해 제공하기 위해선 최대한 이를 변경자 내부에 위치시켜 SwiftUI가 변화를 감지하여 보다 부드러운 애니메이션을 제공하도록 해야 한다는 것이다.</p>
<p>또한 비대해진 <code>OrderHistory</code>를 우린 더 작은 뷰로 나누어 관리할 수도 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/13.png" alt=""></p>
<p>만일 <code>OrderHistory</code>에 조건에 따라 또 다른 뷰가 추가되어야 한다면 코드를 어떻게 작성해야할까</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/14.png" alt=""></p>
<p>위와 같은 방법은 확장성이 매우 떨어진다. 우리는 이런 상황에서 <code>ForEach</code> 뷰를 사용할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/15.png" alt=""></p>
<p><code>ForEach</code>는 하나의 뷰로 <code>List</code>와 마찬가지로 콜렉션 데이터 타입을 인자로 받는다. 그리고 뷰 빌더 클로저 안에 뷰를 나열하는데 이때 나열된 뷰는 <code>ForEach</code>에 추가되지 않고 <code>ForEach</code>의 상위 뷰에 추가된다.</p>
<p>지금까지 작성된 코드들을 보면 우리가 직접 작성하지 않고도 SwiftUI가 스스로 그리고 반응하며 갱신하는 것을 확인할 수 있었다. 이것이 바로 선언형 코드의 장점이라 할 수 있다.</p>
<h2 id="Composing-Controls"><a href="#Composing-Controls" class="headerlink" title="Composing Controls"></a>Composing Controls</h2><p>아보카도 토스트 주문을 넣는 화면을 다시 살펴보자. 이는 우리가 알고 있는 화면과 많이 다르다. 정확히 말하자면 정형화되지 않은 상태다. 이 뷰를 아래와 같이 우리가 익숙한 형태의 뷰로 변경해보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/16.png" alt=""></p>
<p>둘의 가장 큰 차이점은 컨테이너가 다르다는 것이다. </p>
<p>기존 뷰(왼쪽)의 컨테이너가 <code>VStack</code>이라면 우리가 익숙한 오른쪽 뷰의 컨테이너는 <code>Form</code>이다. <code>Form</code> 역시 뷰 컨테이너의 한 종류다. <code>VStack</code>과의 차이점에는 헤더, 섹션 등이 있어 보다 정형화된 그룹 스타일의 UI를 보다 쉽게 만들 수 있다.</p>
<p>그리고 이렇게 컨테이너가 바뀜에 따라 그 안에 속하는 컨트롤(버튼, 토글 등)도 그 모습이나 속성이 컨테이너에 따라 변한다. 또한 <code>Form</code>을 사용하면 서로 다른 플랫폼에서 다양한 룩앤필(Look and Feel)을 제공할 수 있다. 이렇게 SwiftUI가 UI를 그리기 때문에 우리는 기능에 보다 집중할 수 있다.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/17.png" alt=""></p>
<p>위의 화면에서 <code>Button</code>을 예로 들면 뷰 컨테이너가 바뀌면서 <code>Button</code>의 <code>padding</code>, <code>alignment</code> 등이 바뀐 것을 확인할 수 있다. </p>
<p>이번엔 <code>Button</code> 코드를 살펴보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/18.png" alt=""></p>
<p>위의 단일 코드로 여러 플랫폼에서 다양한 룩앤필을 제공할 수 있다. </p>
<p><code>Button</code>은 눌렸을 때 액션을 인자로 넣어주고 버튼의 상태와 목적을 나타내는 <code>label</code>을 뷰 빌더 클로저를 통해 제공해줄 수 있다. 그리고 앞에서 봐왔듯이 여러 변경자들을 통해 보다 쉽게 커스터마이징을 할 수 있다. 이를 통해 우리는 다양한 플랫폼의 다양한 버튼을 사용자에게 제공해줄 수 있다.</p>
<p>그렇기 때문에 SwiftUI에서 컨트롤은 적응형(adaptive) 컨트롤이라 할 수 있다. 적응형 컨트롤은 다음과 같은 특성을 갖는다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/19.png" alt=""></p>
<p>컨트롤은 그 자체로 모양이 아닌 역할을 나타낸다. 이렇게 컨트롤이 역할을 의미하기 때문에 여러 플랫폼에 거쳐 재사용될 수 있는 것이다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/20.png" alt=""></p>
<p>이렇게 컨트롤들은 역할이 있고 이런 역할은 목적에 의해 생겨나기 때문에 <code>Toggle</code>이나 <code>Button</code>들은 그들 각자의 목적이 존재한다. 그리고 이들은 사람이 읽을 수 있는 레이블을 포함하기 때문에 기본적으로 VoiceOver 기능을 지원한다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/21.png" alt=""></p>
<p>그리고 레이블이 <code>Text</code>가 아니라 <code>Image</code>어도 <code>Image</code>에 설명을 위한 <code>Text</code>를 함께 제공하여 VoiceOver 기능을 제공할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/22.png" alt=""></p>
<p>또한 커스텀 뷰는 <code>accessbility</code> 변경자를 통해 이런 기능을 제공할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/23.png" alt=""></p>
<p>이렇게 컨트롤은 플랫폼에 따라 모양은 다를 수 있지만 본연의 목적을 수행하는 데 이는 SwiftUI의 핵심이라고 할 수 있다. SwiftUI는 한 번만 작성하고 어디에서나 실행할 수 있는 수단 일뿐만 아니라 이러한 핵심 개념을 배우고 다양한 컨텍스트와 플랫폼에서 사용할 수 있는 프레임 워크다.</p>
<p>그리고 우리가 뷰에서처럼 컨트롤에서도 변경자를 사용할 수 있다. 그리고 이는 뷰에서와 동일한 특성을 갖는다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/24.png" alt=""></p>
<p>예를 들어 다음과 같이 컨트롤 계층 전반에 걸쳐 변경자를 공유할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/25.png" alt=""></p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/26.png" alt=""></p>
<p>다음으로 살펴볼 것은 환경(Environment)이다. 이는 일종의 모든 뷰에서 접근할 수 있는 특성의 집합으로 볼 수 있다. 그리고 자식 뷰는 부모 뷰의 환경 특성을 상속 받는다. 물론 필요에 따라 자식 뷰에서 이를 오버라이딩할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/27.png" alt=""></p>
<p>그리고 이 환경은 프리뷰에서 유용하게 사용되는데, 동일한 UI를 여러 문맥에 따라 다르게 보여주는 기능을 제공한다. 이를 통해 환경, 문맥에 따라 UI가 어떻게 바뀌는지 쉽게 확인할 수 있다. </p>
<h2 id="Navigating-your-app"><a href="#Navigating-your-app" class="headerlink" title="Navigating your app"></a>Navigating your app</h2><p>iOS에선 기본적으로 <code>NavigationView</code>를 통해 기본 내비게이션 스타일을 사용할 수 있으며 <code>navigationBarTitle</code> 변경자를 통해 타이틀을 지정할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/28.png" alt=""></p>
<p><code>navigationBarTitle</code>은 다른 변경자와 같이 아래를 향하지 않고 위를 향하는 특성을 갖는다. <code>OrderForm</code>에 변경자를 적용했지만, <code>NavigationView</code>에 반영된다는 것을 의미한다. </p>
<p>그리고 <code>NavigationButton</code>를 목적지와 함께 만들어 실질적인 화면 전환을 구현할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/30.png" alt=""></p>
<p><code>TabbedView</code>를 통해 성격이 다른 두 뷰를 탭 뷰로 묶어 관리할 수도 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/31.png" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-21T12:55:57.000Z" title="2019-12-21T12:55:57.000Z">2019-12-21</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></span><span class="level-item">17 minutes read (About 2490 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/21/SwiftUI-Essentials-1/">SwiftUI Essentials (1)</a></h1><div class="content"><h2 id="Views-and-modifiers"><a href="#Views-and-modifiers" class="headerlink" title="Views and modifiers"></a>Views and modifiers</h2><p><code>View</code>들은 UI를 구성하는 가장 기본적인 블록이다. UIKit의 <code>UIView</code>나 AppKit의 <code>NSView</code>와 같이 UI를 구성하는 기본적인 단위라고 할 수 있다. </p>
<p>다음 앱의 UI를 계층 구조로 살펴보자. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ViewHierarchy.png" alt=""></p>
<p>이 계층을 SwiftUI로 작성하면 다음과 같다.</p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/CodeHierarchy.png" alt=""></p>
<p>SwiftUI는 이러한 뷰의 계층을 코드로 표현한다. 왼쪽의 코드 구조는 오른쪽의 뷰 계층 구조와 상당히 흡사한 것을 확인할 수 있다. </p>
<p>또한 코드에서 살펴볼 수 있듯이 뷰 계층을 표현하는데 <code>addSubview</code>와 같은 메소드를 사용하지 않는다. SwiftUI는 하나의 계층 구조를 각 뷰 조각들로 구성하는 것이 아니라 계층 전체를 하나의 완전한 구조로 생성한다. 왜냐하면 <strong>SwiftUI는 뷰를</strong> 명령형(imperatively)과 반대인 <strong>선언형(declaratively)으로 정의</strong>하고 있기 때문이다. </p>
<p>명령형과 선언형의 차이점을 살펴보자. </p>
<ul>
<li>명령형 코드 : 명시적인 명령(explicit commands)을 통해 결과를 구성</li>
<li>선언형 코드 : 묘사(describing) 통해 결과를 구성. 단 이를 어떻게 생성할지는 다른 주체에 의해 결정</li>
</ul>
<p>둘의 차이가 정의로만은 부족할 수 있다. 상황을 예를 들어 둘의 차이를 살펴보자. </p>
<p>명령형 코드는 친구에게 아보카도 토스트를 만드는 방법을 알려주는 것과 같다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ImperativeToast1.png" alt=""></p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ImperativeToast2.png" alt=""></p>
<p>선언형 코드는 아보카도 토스트를 만드는 요리사에게 토스트 주문을 하는 것과 같다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/DeclarativeToast.png" alt=""></p>
<p>친구에게 토스트 만드는 방법을 설명할 때는 <code>7. 아보카도의 중심을 제거해라.</code>와 같이 내가 직접 단계별로 필요한 결과를 전달한다. </p>
<p>반면, 요리사에게는 내가 원하는 토스트의 모습을 묘사하여 전달하고 그것을 어떻게 만드는지는 전적으로 요리사의 몫이다. 그리고 요리사가 전문가라면 우리는 항상 최상의 품질을 보장받을 수 있다.</p>
<blockquote>
<p>이 두 상황을 통해 명령형 코드와 선언형 코드의 차이점을 보다 쉽게 이해할 수 있었다.</p>
</blockquote>
<p>SwiftUI가 요리사의 역할을 하는 것이다. 그럼 이제 SwiftUI의 요소들을 하나씩 살펴보자. </p>
<h3 id="View-Container-Syntax"><a href="#View-Container-Syntax" class="headerlink" title="View Container Syntax"></a>View Container Syntax</h3><p>뷰 컨테이너는 여러 다른 컨텐트 뷰(Content View)들로 구성되어 있다. 뷰 컨테이너에는 <code>VStack</code>, <code>HStack</code> 등이 존재한다. 뷰 컨테이너의 일반적인 문법은 다음과 같다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ViewContainerSyntax.png" alt=""></p>
<p><code>VStack</code>을 다음과 같이 사용할 수 있는 것과 같다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123; </span><br><span class="line">  <span class="type">Imgae</span>(...)</span><br><span class="line">  <span class="type">Text</span>(...)</span><br><span class="line">  <span class="type">Text</span>(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Image</code>, <code>Text</code>와 같은 컨텐트 뷰들은 뷰 빌더(View Builder)라는 클로저 안에 나열된다. 그리고 뷰 컨테이너의 생성자는 이 뷰 빌더 클로저를 인자로 받는다. <code>addSubview</code>와 같은 함수를 호출하는 대신 이 클로저 블록 안에 원하는 뷰를 순서대로 나열만 해주면 된다.</p>
<p>실제로 뷰 빌더가 내부적으로 어떻게 동작하는지 확인하기 위해 <code>VStack</code> API를 살펴보자. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ViewContainerSyntaxDetail.png" alt=""></p>
<p>생성자 인자 중 <code>content</code>에 <code>@ViewBuilder</code> 속성(attribute)이 붙어있는 것을 확인할 수 있다. 스위프트 컴파일러는 <code>@ViewBuilder</code> 속성이 붙어 있으면 해당 클로저를 우리가 나열한 컨텐트 뷰들이 포함된 단일 뷰를 반환하는 클로저로 변환한다. </p>
<p>이런 특수한 클로저를 뷰 컨테이너의 생성자에 전달해줌으로써 뷰 컨테이너와 컨텐트 뷰들은 들여 쓰기로 자연스레 구분될 수 있다. </p>
<p>또한 <code>VStack</code>은 <code>alignment</code>나 <code>spacing</code>과 같은 인자를 추가로 받아 정렬이나 간격을 조정해줄 수 있다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ExampleAppCode.png" alt=""></p>
<p>SwiftUI에서 <code>VStack</code>, <code>HStack</code>과 같이 컨트롤(Control)도 뷰 컨테이너의 종류로 다른 뷰를 컨텐트 뷰로 포함할 수 있다. <code>Control</code>에는 <code>Button</code>, <code>Toggle</code> <code>Slider</code> 등이 있다. 위의 코드에서처럼 <code>Text</code>뿐만 아니라 다른 뷰도 컨텐트 뷰로 포함할 수 있다.</p>
<blockquote>
<p>컨트롤은 사용자와 상호작용할 수 있는 요소들을 말한다. <a href="https://developer.apple.com/documentation/swiftui/views_and_controls">공식 문서</a>를 통해 컨트롤에 어떤 것들이 있는지 알 수 있다. </p>
</blockquote>
<p>컨트롤과 뷰 컨테이너는 추후에 더 자세히 살펴보도록 하고 이젠 <strong><code>$</code></strong> 싸인에 주목해보자. </p>
<h3 id="Binding-Syntax"><a href="#Binding-Syntax" class="headerlink" title="Binding Syntax"></a>Binding Syntax</h3><p><code>Stepper</code>를 선언하는 코드를 살펴보자. <code>order.quantity</code>를 넘기는데 <code>$</code> 싸인이 앞에 붙었다. 이는 단순히. <code>order.quantity</code> <strong>값</strong>을 넘기는 것이 아닌 <strong>바인딩</strong>을 넘기는 것이다. 그럼 여기서 말하는 바인딩이란 뭘까?</p>
<p>영상의 예제 앱에서 <code>Stepper</code>는 <code>OrderForm</code>이란 뷰에 포함되어 있다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/BindingSyntax.png" alt=""></p>
<p><code>OrderForm</code>은 현재 순서를 추적하기 위해 <code>Order</code> 타입에 의존하고 있다. 이 프로퍼티를 살펴보면 <code>@State</code>란 속성이 붙어있는 것을 확인할 수 있다. <code>@State</code> 속성이 붙어있으면 SwiftUI는 이를 보고 내부적으로 지속성 있는 상태(persistent state)를 생성하고 관리하며 상태의 값을 이 프로퍼티를 통해 접근하도록 한다.</p>
<p>우린 이 프로터티에 접근해 상태의 값을 읽거나 쓸 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Quantity: \(order.quantity)"</span>)</span><br></pre></td></tr></table></figure>

<p><code>Stepper</code>는 정적인 뷰가 아닌 컨트롤이다. 그 말은 사용자가 <code>Stepper</code>의 버튼을 누르면 그 상태가 변경될 수 있다는 의미다. 이를 위해선 단순히 읽기 전용인 값을 전달하는 것이 아니라 바인딩을 전달해야 한다. </p>
<p>바인딩은 일종의 관리되는 참조(managed reference)로 이를 통해 하나의 뷰가 다른 뷰의 상태를 변경할 수 있다. 이 예제에선 <code>Stepper</code>가 <code>OrderForm</code>의 상태를 <code>$order.quantity</code>를 통해 변경하고 있는 것이다. </p>
<blockquote>
<p>SwiftUI에서의 데이터 흐름에 대한 자세한 내용은 <a href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=2ahUKEwjF6tvttsbmAhVRJaYKHXDyBggQwqsBMAB6BAgKEAQ&url=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2019%2F226%2F&usg=AOvVaw0HLHjam6QvNklY9QlJyvIA">Data Flow Through SwiftUI</a> 영상을 참고하자. </p>
</blockquote>
<p>다시 예제 앱으로 돌아와 우리가 아직 살펴보지 못한 문법을 살펴보자. </p>
<h3 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h3><p><img src="/2019/12/21/SwiftUI-Essentials-1/ModifierText.png" alt=""></p>
<p><code>Text(&quot;Avocado Toast&quot;)</code>에서 우린 <code>font(.title)</code>과 같은 메소드를 호출할 수 있다. 이 메소드가 하는 작업은 간단하다. 호출한 뷰로부터 새 뷰를 만들어내는 것이다. SwiftUI에서 이런 메소드를 변경자(Modifier)라 부른다. </p>
<p>이런 변경자에 의해 뷰 계층이 어떻게 변경되는지 살펴보자.  <code>Text(&quot;Avocado Toast&quot;)</code>을 포함하는 <code>VStack</code>은 다음과 같은 계층 구조를 가진다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/NoModifierViewHierarchy.png" alt=""></p>
<p>하지만 여기에 <code>font(.title)</code> 변경자를 적용하면 뷰 계층은 다음과 같이 변경된다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ModifierViewHierarchy.png" alt=""></p>
<p>이렇게 변경자로 생성된 뷰는 기존의 뷰를 감싸고 뷰 계층에 포함된다. 이런 변경자는 다수의 변경자들과 함께 체이닝될 수 있다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/MultipleModifierViewHierarchy.png" alt=""></p>
<p>이렇게 변경자를 추가하게 되면 계층 구조는 빠른 속도로 비대해진다. 우리는 이전까지 이렇게 뷰 계층이 비대해지면 성능 이슈에 대해서 고민하곤 했다. 기존의 뷰 계층은 최대한 작고 가벼워야 했다.</p>
<p>하지만 SwiftUI는 이러한 부분에 대한 걱정을 덜어도 된다. 위에서 언급했듯이 우리는 선언형 코드를 작성한다. 우리는 단지 원하는 모습을 묘사할 뿐이고, SwiftUI가 이를 최적화한다. 우리가 아무리 많은 변경자를 사용해 <code>Text</code>를 여러 뷰로 감싸도 SwiftUI가 이를 보다 효율적인 자료구조로 최적화한다. 그리고 이렇게 최적화된 자료구조는 렌더링 시스템이 렌더링 하는데 사용한다. </p>
<p>이렇게 변경자 체이닝 문법은 성능 이슈에 대해 걱정할 필요 없이 많은 이점을 제공한다. 그중 하나로 변경자 체이닝은 시각적 요소의 직관적인 순서를 강제한다. 즉 체이닝에 참여하는 변경자의 순서에 따라 최종 렌더링 되는 모습이 달라진다는 것이다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/PaddingLast.png" alt=""></p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/PaddingFirst.png" alt=""></p>
<p>만약 이런 속성들을 변경자 체이닝으로 변경하는 것이 아닌 <code>Text</code>의 내부에 포함된 속성이라고 가정해보자. 우린 시행착오와 문서 없이는 각각의 속성들이 어떤 순서로 적용되는지 알 수 없을 것이다. 이런 속성들을 변경자를 통해 적용함으로써 우린 순서를 명시적으로 지정할 수 있다. </p>
<p>또한 이런 변경자들은 여러 뷰들에서 공유될 수 있다.</p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ModifierWithoutSharing.png" alt=""></p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ModifierWithSharing.png" alt=""></p>
<p>이렇게 변경자를 공유함으로써 각각의 뷰들은 보다 단순해질 수 있고 자신들만의 인터페이스에 집중할 수 있다. 이것이 SwiftUI의 기본 원칙이다.</p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/SwiftUIPrinciple.png" alt=""></p>
<p>더 작고 단일 목적의 뷰라는 원칙을 따름으로써 우리는 보다 이해하기 쉽고, 유지 보수가 쉬운 뷰를 만들 수 있다. </p>
<blockquote>
<p>재사용성 역시 증가한다.</p>
</blockquote>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/SwiftUIPrinciple2.png" alt=""></p>
<p>그리고 이렇게 각자의 역할별로 작게 나누어진 뷰들을 통해 보다 큰 뷰를 효과적으로 구성할 수 있다. </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-12T11:59:12.000Z" title="2019-12-12T11:59:12.000Z">2019-12-12</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">16 minutes read (About 2450 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/12/Opaque-Types-in-Swift/">Opaque Types in Swift</a></h1><div class="content"><p>오늘은 Swift 5.1에서 처음 소개된 <strong>불투명 타입(Opaque Type)</strong>에 대해 공부해보고 기록해보려 한다. 사실 SwiftUI를 본격적으로 공부하려다 <code>some</code> 키워드에 막혀 이게 무엇인지 알아보려다 여기까지 오게 되었다. </p>
<blockquote>
<p> 이렇게 SwiftUI는 다시금 뒤로 미뤄졌다.🙄 진짜 제대로 시작해야 하는데..</p>
</blockquote>
<p>불투명 타입을 공부하면서 명확하게 이해가 된 부분도 있지만, 아직은 불투명하게 다가온 부분도 있었다. 그 이유는 아무래도 어느 문법을 공부해도 마찬가지겠지만, 직접 프로젝트에 사용하여 필요성을 느껴보지 못해서 그런 것 같다. </p>
<blockquote>
<p>@escaping 클로저를 처음 배웠을 때도 이와 비슷한 느낌이었다. </p>
</blockquote>
<p>오늘은 단순히 문법적 이해를 위한 기록으로 작성하고 추후 기회가 된다면 직접 사용해보고 이 문법이 왜 도입되었고, 언제 사용하면 좋을지 다른 사람들이 소개한 케이스가 아닌 내가 경험한 케이스를 소개해보려 한다. </p>
<hr>
<h3 id="Type-Identity"><a href="#Type-Identity" class="headerlink" title="Type Identity"></a>Type Identity</h3><p>불투명 타입을 소개하기 전 가장 먼저 본인이 불투명 타입을 공부하면서 헷갈렸던 부분을 먼저 소개해보려 한다. 스위프트 공식 문서나 여러 해외 블로그들을 읽다 보면 불투명 타입을 설명하는 데 있어 <strong>정체성(Identity)</strong>를 자주 언급하는 것을 확인할 수 있다. 정확하게 말하면 <strong>타입 정체성(Type Identity)</strong>이다.</p>
<p>타입 정체성이란 무엇일까? 몇 개의 글과 함께 예제 코드를 보고서야 조금은 감을 잡을 수 있었다. 내가 이해한 타입 정체성은 다음과 같다. </p>
<p>우린 스위프트에서 프로토콜을 타입으로써 사용할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Analytics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirebaseAnalytics</span>: <span class="title">Analytics</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlurryAnalytics</span>: <span class="title">Analytics</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnalyticsManager</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> analytics: <span class="type">Analytics</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> analytics: <span class="type">Analytics</span>) &#123; </span><br><span class="line">    <span class="keyword">self</span>.analytics = analytics</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">sendLog</span><span class="params">()</span></span> &#123; </span><br><span class="line">    analytics.log()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager1 = <span class="type">AnalyticsManager</span>(<span class="type">FirebaseAnalytics</span>())</span><br><span class="line"><span class="keyword">let</span> manager2 = <span class="type">AnalyticsManager</span>(<span class="type">FlurryAnalytics</span>())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>전적으로 예제를 위한 예제 코드다. </p>
</blockquote>
<p><code>AnalyticsManager</code>는 어떤 애널리틱스 툴을 사용해도 로그만 전송하면 된다. 우리는 보통 이런 경우 위와 같이 프로토콜을 만들고 행위를 정의한다. 그리고 행위를 구현한 구현체를 프로토콜 타입으로써 주입해준다. </p>
<p><code>AnalyticsManager</code>가 <code>sendLog</code>를 호출할 때 <code>AnalyticsManager</code>는 <code>FirebaseAnalytics</code>나 <code>FlurryAnalytics</code>가 아닌 단지 <code>Analytics</code> 타입으로 <code>analytics</code> 프로퍼티를 사용한다. 이렇게 프로토콜 타입은 사용되는 시점에 자신의 실제 타입에 대한 정체성을 잃게 된다.</p>
<p>“잃게 된다”라는 어감(?) 때문인지 부정적으로 다가올 수 있지만 이게 프로토콜 타입을 사용하는 이유다.</p>
<blockquote>
<p>추상화의 의미를 생각해보면 정체성을 잃는다는 것을 보다 쉽게 받아들일 수 있다.</p>
</blockquote>
<p>그리고 이런 프로토콜 타입은 프로그램에 유연성을 제공해주기 때문에 의존성 주입 등 코드 작성 전반에 걸쳐 유용하게 사용된다. </p>
<p>하지만 이러한 유연성이 때로는 코드 복잡성을 야기할 수 있다. 일반적인 프로토콜 타입에는 해당하지 않지만 <code>associatedtype</code>이나 <code>Self</code>를 사용하는 프로토콜 타입은 타입으로써 반환되거나, 파라미터로 전달, 프로퍼티로 사용될 수 없다. 만일 그렇게 사용하면 우린 굉장히 익숙한 에러 메세지를 볼 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol &#39;SomeProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements</span><br></pre></td></tr></table></figure>

<p>너무 돌아왔다. 결국 <strong>프로토콜 타입은 타입 정체성을 잃고 유연성을 제공</strong>한다는 것에 주목하자!</p>
<hr>
<h3 id="Opaque-Types"><a href="#Opaque-Types" class="headerlink" title="Opaque Types"></a>Opaque Types</h3><p>불투명 타입의 사용법은 간단하다. 반환되는 프로토콜 타입 앞에 <code>some</code> 키워드를 붙여주면 끝이다. 하지만 단순히 문법의 사용법만 가지곤 문법을 활용할 수 없다. 언제 불투명 타입을 사용할 수 있고, 불투명 타입을 왜 사용하는지에 대해 알아보았다. </p>
<p>이를 위해 불투명 타입이 없던 Swift 5.1 이전으로 돌아가 보자. 결제수단을 제공하는 프레임워크를 작성한다고 가정해보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">favoriteCreditCard</span><span class="params">()</span></span> -&gt; <span class="type">CreditCard</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같은 방식으로 사용자가 최근에 사용한 카드를 사용자가 선호하는 카드로 반환해줄 수 있다. 하지만 이러한 과정에서 우리는 굳이 사용자가 알 필요 없고, 알아서는 안되는 <code>CreditCard</code>라는 타입을 노출시킨다. </p>
<p>우리는 이런 문제를 프로토콜을 사용하여 해결하려 한다.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PaymentType</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CreditCard</span>: <span class="title">PaymentType</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ApplePay</span>: <span class="title">PaymentType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">favoritePaymentType</span><span class="params">()</span></span> -&gt; <span class="type">PaymentType</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> likesApplyPay &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="type">ApplePay</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>얼핏 보면 해결된 것처럼 보일 수 있지만 사용자가 <code>PaymentType</code>을 비교해야 한다면 얘기는 달라진다.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PaymentType</span>: <span class="title">Equatable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Equatable</code> 타입은 내부적으로 <code>Self</code>를 사용한다.</p>
</blockquote>
<p>이렇게 결제수단의 비교를 위해 <code>Equatable</code>을 사용하면 타입 정체성에서 언급한 에러 메세지를 보게 된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Protocol &#39;PaymentType&#39; can only be used as a generic constraint because it has Self or associated type requirements</span><br></pre></td></tr></table></figure>

<p>물론 이런 문제를 제네릭과 타입 제거 기법(type erasure techniques)을 통해 해결할 수 있다. 하지만 이는 프레임워크의 사용을 더욱 어렵게 만들며 역시 의도치 않게 내부 타입을 노출시킬 수 있다. </p>
<p>불투명 타입이 이런 문제를 해결할 수 있다. 방법은 매우 간단하다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">favoriteCreditCard</span><span class="params">()</span></span> -&gt; some <span class="type">PaymentType</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>물론 방법이 매우 간단한 만큼 한계도 존재한다. 불투명 타입을 반환하는 함수는 오로지 하나의 타입만 반환할 수 있다. 위의 코드에서 함수의 반환 타입은 <code>CreditCard</code>다. 하지만 컴파일러가 이를 <code>PaymentType</code>인 것 마냥 다룬다. 내부적으론 실제 타입을 반환하는 것이기 때문에 실제 타입으로 할 수 있는 모든 것들은 할 수 있다. 즉 <strong>타입 정체성이 보장</strong>된다는 것이다. 타입의 정체성이 보장되기 때문에 <code>associatedtype</code>이나 <code>Self</code>를 사용하는 프로토콜도 반환 타입으로 바로 사용할 수 있다.</p>
<p>물론 불투명 타입의 한계도 존재한다. 이런 타입의 정체성을 보장하기 위해 하나의 타입만을 반환할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">favoritePaymentType</span><span class="params">()</span></span> -&gt; some <span class="type">PaymentType</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> likesApplyPay &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="type">ApplePay</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>즉 위와 같은 코드는 사용할 수 없다는 뜻이다. </p>
<p>다시 불투명 타입을 사용하면 어떤 점이 좋은지 이야기해보자. 위에서 언급했듯이 불투명 타입은 모듈 내부의 타입을 노출시키지 않을 수 있다. 이게 단순히 하나의 타입을 노출시키지 않는다는 것을 의미하기도 하지만, 타입이 내부적으로 어떤 타입들로 구성되어 있는지도 숨길 수 있다. </p>
<p>SwiftUI를 예로 들어보자. SwiftUI 프로젝트를 생성하면 하나의 템플릿 코드를 확인할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>바로 내가 SwiftUI 공부를 멈추고 불투명 타입을 공부하기 시작하게 된 코드다. </p>
</blockquote>
<p>이 코드에서 <code>some</code> 키워드를 사용한 이유가 뭘까? <code>some</code> 키워드를 지우면 컴파일이 되지 않는 걸까? 그렇지 않다. <code>some</code> 키워드가 없이도 충분히 프로그램을 만들 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: <span class="type">Text</span> &#123; </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>some</code> 키워드를 사용하지 않고 SwiftUI로 화면을 만들어보자. SwiftUI에선 <code>VStack</code>을 이용해 스택 뷰의 형태를 구현할 수 있다. 그리고 SwiftUI에서 이런 컨테이너 타입들은 모두 제네릭 타입이다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Image</span>)&gt;&gt; &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"video.fill"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.</p>
<p>.</p>
<p>🤔</p>
<p>자자..! 일단 계속 만들어보자. 하나의 텍스트를 더 추가해보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Text</span>, <span class="type">Image</span>)&gt;&gt; &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">          	<span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"My name is Corn"</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"video.fill"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>좀 더 복잡한 레이아웃을 그려보자!</p>
<p>.</p>
<p>.</p>
<p><img src="https://i.ytimg.com/vi/-2Z0Y3Kk8nU/maxresdefault.jpg" alt=""></p>
<p>.</p>
<p>.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">List</span>&lt;<span class="type">Never</span>, <span class="type">TupleView</span>&lt;(<span class="type">HStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Text</span>)&gt;&gt;, <span class="type">Text</span>)&gt;&gt;, <span class="type">HStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Text</span>)&gt;&gt;, <span class="type">Text</span>)&gt;&gt;)&gt;&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">      .....</span><br><span class="line">      ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자 완성했다! 근데 중간 어디쯤에 있는 <code>Text</code>를 <code>Image</code>로 바꾸려 한다! 그러면…🤯</p>
<p>이쯤 되면 왜 불투명 타입이 필요한지 절실히 깨달을 수 있다. 우린 단지 <code>body</code>가 <em>어떤(some)</em> <code>View</code> 타입을 반환한다 정도만 알고 싶은 것이다. 그리고 그 정도의 정보만 필요하다. </p>
<p>우린 <code>some</code> 키워드로 <code>body</code>는 단지 <code>View</code> 타입을 반환한다는 사실을 명시해줄 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      .....</span><br><span class="line">      ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>아직은 내가 직접 작성한 모듈 혹은 프로젝트에서 불투명 타입을 사용해보진 못했다. 하지만 이젠 불투명 타입의 존재와 언제 사용하면 좋을지에 대해 훑어보았기 때문에 다음에 기회가 왔을 때 불투명 타입 사용을 고려해볼 수 있게 되었다. </p>
<blockquote>
<p>SwiftUI 공부도 다시 시작할 수 있다!</p>
</blockquote>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://medium.com/@PhiJay/whats-this-some-in-swiftui-34e2c126d4c4">What’s this “some” in SwiftUI</a></li>
<li><a href="https://swiftrocks.com/understanding-opaque-return-types-in-swift.html">Understanding Opaque Return Types in Swift</a></li>
<li><a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html">Opaque Types</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-25T12:53:20.000Z" title="2019-11-25T12:53:20.000Z">2019-11-25</time><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">20 minutes read (About 3016 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/25/Universal-Link-Custom-URL-Scheme/">Universal Link &amp; Custom URL Scheme</a></h1><div class="content"><p>커스텀 스킴과 유니버셜 링크에 대해 알아보도록 하자. </p>
<p>이 둘에 대해 얼핏 많이 들어보았을 것이다. 단순히 말해 모두 딥링크를 지원하는 방법이다. 그렇다면 이 둘의 차이점은 무엇일까? 그리고 딥링크의 역할은 무엇이며 딥링크를 통해 우리는 어떤 이점을 얻을 수 있을까. 이것도 함께 알아보도록 하자. </p>
<h3 id="딥-링크란"><a href="#딥-링크란" class="headerlink" title="딥 링크란?"></a>딥 링크란?</h3><p>위키피디아의 정의에 따르면 딥링크는 <strong>특정 페이지에 도달할 수 있는 링크</strong>를 말한다. 링크란 단어는 실생활 대화에서도 많이 사용하고 실제로 링크도 많이 사용한다. </p>
<p>*”야~ 내가 링크 보냈어 확인해봐”*</p>
<p>우리는 실생활에서 이런 말을 자주 하곤 한다. 그렇다면 위의 말에 담긴 뜻은 무엇일까? 그것은 바로 정보 전달이다. 정보 전달로는 부족하다. 편리한 정보 전달이다. 그럼 여기서 편리하다는 것은 무엇을 의미할까?</p>
<p>상대방이 내가 알려준 정보, 컨텐츠를 스스로 키워드를 이용하여 검색을 통해 접하는 것이 아닌 링크로 하여금 상대방에게 내가 전달하고자 하는 정보, 컨텐츠를 바로 노출시키는 것이 나는 <strong>편리한 정보 전달의 수단</strong>으로써의 링크라고 생각한다.</p>
<p>위의 *”야~ 내가 링크 보냈어 확인해봐”*의 링크가 딥링크다. 이 딥링크는 단순히 웹 브라우저 상에서만 존재하는 수단이 아니다. 우린 이런 딥링크를 이용해 특정 앱의 특정 컨텐츠를 상대방에게 편리하게 전달할 수 있다. </p>
<p>이렇게 우리는 딥링크를 통해 사용자에게 우리 앱의 컨텐츠를 <strong>Seamless</strong>하게 노출시킬 수 있다. </p>
<hr>
<h3 id="커스텀-URL-스킴이란"><a href="#커스텀-URL-스킴이란" class="headerlink" title="커스텀 URL 스킴이란?"></a>커스텀 URL 스킴이란?</h3><p>커스텀 스킴은 iOS에서 딥링크를 지원하는 방법 중 하나이다.</p>
<blockquote>
<p>현재는 애플에서 유니버셜 링크를 사용하도록 강력하게 추천하고 있다. </p>
<p>Universal links are strongly recommended as a best practice.</p>
<p>이 이유에 대해선 밑에서 천천히 살펴보도록 하자. </p>
</blockquote>
<p>공식 문서에서 커스텀 URL 스킴을 <u>앱 내의 자원에 접근할 수 있는 방법을 제공할 수 있는 방법</u>이라고 설명하고 있다. 애플은 시스템 앱들에 대해 미리 정의된 앱 스킴을 제공한다. <code>mailto</code>, <code>tel</code> 그리고 <code>facetime</code>이 그것들이다.</p>
<p>커스텀 URL 스킴을 지원하는 방법은 어렵지 않다. </p>
<ol>
<li><p>앱의 URL 포맷을 정의한다. </p>
</li>
<li><p>스킴을 등록해 시스템이 정의된 URL에 따라 알맞는 앱으로 사용자를 보낼 수 있도록 한다. </p>
<p><img src="https://docs-assets.developer.apple.com/published/3dcc25d414/8239bd2e-1dd6-414e-9754-63f9ac3b0633.png" alt=""></p>
</li>
<li><p>앱이 열린 URL을 적절히 처리해야 한다. </p>
</li>
</ol>
<p>URL은 반드시 정의된 커스텀 스킴 이름으로 시작해야 하며 파라미터를 함께 넘겨 이에 따른 별도의 동작을 처리하게 할 수도 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"myphotoapp:Vacation?index=1"</span>)</span><br><span class="line">       </span><br><span class="line"><span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(url!) &#123; (result) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> result &#123;</span><br><span class="line">       <span class="comment">// The URL was delivered successfully!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 정의된 커스텀 스킴은 문서에서도 중복되지 않게 작성하라고 권고하고 있다. 그럼에도 불구하고 커스텀 스킴은 중복이 발생할 수 있다. 그리고 이렇게 중복된 스킴을 갖고 있는 두 앱이 존재한다면 시스템은 사용자가 의도하지 않은 다른 앱을 실행시키게 될 수 있다. </p>
<p>또한 앱이 설치되어 있지 않다면 스킴은 동작하지 않는다. <a href="https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl"><code>canOpenURL(_:)</code></a>를 통해 스킴에 해당하는 URL을 열 수 있는지를 검사할 수 있지만 앱이 설치되어 있지 않았을 때 우리가 원하는 궁극적인 행동은 커스텀 URL 스킴으로는 한계가 있다. </p>
<p>그렇다면 여기서 “우리가 궁극적인 행동”이란 무엇일까? </p>
<p>우리는 다른 앱에서 우리의 컨텐츠를 그대로 보여주는 것이 아닌 사용자가 우리 앱에서 우리의 컨텐츠를 소비할 수 있도록 이동시키고 싶을 것이다. (사파리를 통해 미디움의 컨텐츠를 보는 것보다, 미디움 앱을 통해 컨텐츠를 보는 것이 보다 쾌적한 사용자 경험을 제공할 수 있다.)</p>
<p>하지만 앱이 설치되어 있지 않았을 때 단순히 이동시키지 못하는 것에 그치지 않고 최소한 우리 앱을 설치할 수 있는 앱 스토어로 이동이라도 시켜준다면 우리 앱으로의 유입은 앞의 상황보다 더욱 나아질 수 있다. </p>
<p>위의 내용을 통해 우리는 커스텀 URL 스킴의 두 가지 단점을 알 수 있었다.</p>
<ol>
<li>중복이 일어나 다른 앱을 실행시킬 수 있다.</li>
<li>앱이 설치되어 있지 않을 때 충분한 조치를 취할 수 없다. </li>
</ol>
<p>그리고 1번의 이유는 치명적인 보안 이슈의 여부도 있기 때문에 애플은 이러한 커스텀 URL 스킴의 단점을 보완하고자 유니버셜 링크라는 것을 만들었다.</p>
<blockquote>
<p><strong>중요</strong></p>
<p>iOS 9.0 이상의 앱에선 열고자 하는 앱의 커스텀 스킴을 <code>Info.plist</code>의 <code>LSApplicationQueriesSchemes</code>키의 값으로 반드시 등록을 해야 한다. 그렇지 않으면 설령 해당 스킴의 앱이 설치되어 있다 하더라도 <code>canOpenURL(_:)</code> 메소드는 항상 <code>false</code>를 반환할 것이다.</p>
</blockquote>
<hr>
<h3 id="유니버셜-링크란"><a href="#유니버셜-링크란" class="headerlink" title="유니버셜 링크란?"></a>유니버셜 링크란?</h3><p>유니버셜 링크도 커스텀 URL 스킴과 동일하게 모바일 환경에서 딥링크를 지원하기 위한 수단이다. 하지만 유니버셜 링크는 앱이 설치되어 있지 않으면 웹 페이지를 통해 컨텐츠를 보여준다는 것이다. (물론 앱이 설치되어 있다면 바로 해당 앱을 실행시켜 컨텐츠를 보여준다.) 그렇기 때문에 유니버셜 링크는 표준 HTTP, HTTPS 링크다.</p>
<blockquote>
<p>앱이 설치되어 있지 않을 경우 유니버셜 링크를 통해 컨텐츠를 웹을 통해 노출시키는 방법과 앱 스토어로 사용자를 보내는 방법이 있다.</p>
</blockquote>
<p>서비스에 유니버셜 링크를 지원하기 위해선 웹 서버에서의 별도의 작업을 필요로 한다. 앱의 번들 ID와 앱이 열어야 할 경로(path)를 포함하는 <strong>AASA(Apple-App-Site-Association</strong> 파일이 웹 서버에 등록되어 있어야 한다. </p>
<p>AASA 파일을 서버에 등록해야 하기 때문에 해당 도메인 소유자가 아닌 이상 등록을 할 수가 없다. 그렇기 때문에 고유하고 안전하게 딥링크를 지원할 수 있다. </p>
<p>AASA 파일은 JSON 형태로 다음과 같이 작성되어야 한다. </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"applinks"</span>: &#123;</span><br><span class="line">        <span class="attr">"apps"</span>: [],</span><br><span class="line">        <span class="attr">"details"</span>: [&#123;</span><br><span class="line">            <span class="attr">"appID"</span>: <span class="string">"D3KQX62K1A.com.example.photoapp"</span>,</span><br><span class="line">            <span class="attr">"paths"</span>: [<span class="string">"/albums"</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="attr">"appID"</span>: <span class="string">"D3KQX62K1A.com.example.videoapp"</span>,</span><br><span class="line">            <span class="attr">"paths"</span>: [<span class="string">"/videos"</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>appID: <team identifier>.<bundle identifier>의 포맷의 값으로 앱의 식별자를 의미하는 값. </p>
</li>
<li><p>paths: 앱에서 처리할 수 있는 링크 경로의 배열</p>
<blockquote>
<p>와일드카드 문자를 사용해 보다 다양한 경로를 간편하게 지원할 수 있다. </p>
<p><code>/videos/samples/201?/*</code> : <code>videos/sample</code>에서 2010년대(<code>201?</code>)의 하위 모든 경로를 의미한다.  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>이미 웹 브라우저를 통해 컨텐츠를 즐기고 있던 사용자가 웹 브라우저 컨텐츠 내부의 유니버셜 링크를 클릭하면 웹 브라우저를 통해 계속해서 컨텐츠를 즐기수 있도록 한다. 계속해서 웹 브라우저에서 컨텐츠를 즐기던 사용자를 앱으로 보내버리는 것은 오히려 사용자 경험을 해칠 수 있기 때문이다.</p>
</blockquote>
<p>사용자가 유니버셜 링크를 클릭하여 링크가 활성화되면 iOS는 앱을 실행시키고 <a href="https://developer.apple.com/documentation/foundation/nsuseractivity"><code>NSUserActivity</code></a> 객체에 정보를 담아보낸다. 그리고 사용자는 <code>AppDelegate</code> 메소드인 <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623072-application">application(_:continue:restorationHandler:)</a>를 오버라이딩하여 처리한다.</p>
<p>유니버셜 링크 활성화를 통해 전달된 <code>NSUserActivity</code>의 <code>activityType</code>은 <a href="https://developer.apple.com/documentation/foundation/nsuseractivitytypebrowsingweb"><code>NSUserActivityTypeBrowsingWeb</code></a>이다. 또한 <code>NSUserActivity</code> 객체의 <a href="https://developer.apple.com/documentation/foundation/nsuseractivity/1418086-webpageurl"><code>webpageURL</code></a> 프로퍼티는 사용자가 클릭한 URL을 포함하고 있다. 그리고 <a href="https://developer.apple.com/documentation/foundation/nsurlcomponents"><code>NSURLComponents</code></a>를 통해 URL의 경로나 파라미터를 추출해낼 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">continue</span> userActivity: NSUserActivity,</span></span></span><br><span class="line"><span class="function"><span class="params">                 restorationHandler: @escaping <span class="params">([<span class="keyword">Any</span>]?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">guard</span> userActivity.activityType == <span class="type">NSUserActivityTypeBrowsingWeb</span>,</span><br><span class="line">  <span class="keyword">let</span> incomingURL = userActivity.webpageURL,</span><br><span class="line">  <span class="keyword">let</span> components = <span class="type">NSURLComponents</span>(url: incomingURL, resolvingAgainstBaseURL: <span class="literal">true</span>),</span><br><span class="line">  <span class="keyword">let</span> path = components.path,</span><br><span class="line">  <span class="keyword">let</span> params = components.queryItems <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"path = \(path)"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> albumName = params.first(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.name == <span class="string">"albumname"</span> &#125; )?.value,</span><br><span class="line">  <span class="keyword">let</span> photoIndex = params.first(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.name == <span class="string">"index"</span> &#125;)?.value &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"album = \(albumName)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"photoIndex = \(photoIndex)"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Either album name or photo index missing"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="번외"><a href="#번외" class="headerlink" title="번외"></a>번외</h3><p>일반적인 딥링크가 아닌 <strong>디퍼드 딥링크(Deferred)</strong>라는 개념이 존재한다. 그럼 디퍼드 딥링크는 기존의 딥링크와 다른 점은 무엇일까? </p>
<p>기존의 딥링크를 통해 우리가 할 수 있는 최선의 행동은 웹을 통해 컨텐츠를 보여주던지, 혹은 앱스토어로 사용자를 보내는 것에 불과하다. 디퍼드 딥링크를 굳이 번역해보자면 <strong>지연된 딥링크</strong> 정도로 해석해볼 수 있을 것이다. 그렇다면 여기서 무엇이 지연되었다는 것일까? </p>
<p>상황을 가정해보자. 앱이 설치되어 있지 않은 상태에서 기존의 딥링크를 통해 앱스토어까지 사용자를 보냈고 사용자가 앱을 설치했다. 딥링크의 궁극적인 목표는 앱의 설치가 아니라 특정 컨텐츠로 사용자를 보내는 것이다. 그렇기 때문에 현재 상황에서 딥링크 본연의 목적을 달성했다고 보기는 힘들다. 여기서 디퍼드 딥링크가 이런 문제를 해결해 줄 수 있다.</p>
<p>디퍼드 딥링크를 사용하면 링크를 통해 앱스토어로 보내진 사용자가 앱을 설치하고 최초로 앱을 실행시켰을 때 최초 링크를 통해 보여주었어야 할 컨텐츠로 사용자를 이동시킨다. 이렇게 앱스토어 &gt; 앱 설치 &gt; 앱 실행이라는 지연된 과정을 거쳐 컨텐츠를 사용자에게 보여줄 수 있는 기능의 딥링크를 디퍼드 딥링크라고 한다.</p>
<p>그렇다면 링크를 통해 앱을 설치하고 최초로 실행한 사용자와 일반적으로 앱 스토어에서 바로 앱을 설치하여 최초로 실행한 사용자를 어떻게 구분하여 컨텐츠를 보여줄까? 이 부분에 대해서 정확하게 설명된 내용을 찾기 힘들었지만 큰 그림에서 설명해준 글에선 이를 다음과 같이 설명하고 있다. </p>
<p> <em>Historically <strong>this has been done through fingerprinting.</strong> Fingerprinting works by generating a “fingerprint” of a web user <strong>consisting of a device’s IP address and user-agent (operating system, operating system version, and other device specific parameters)</strong> and generating another fingerprint when a user opens the app. Recent techniques like Branch’s People Based Attribution model have moved beyond fingerprinting to using an unique Identity Graph that matches a device’s unique browser identifier to its unique app identifier, tying it back to the actual user across web and app to achieve true cross platform attribution, giving better matching between link licks and app opens.</em></p>
<hr>
<p><strong>참고자료</strong></p>
<ol>
<li><a href="https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content">Allowing Apps and Websites to Link to Your Content</a></li>
<li><a href="https://medium.com/@abhimuralidharan/universal-links-in-ios-79c4ee038272">Universal links in iOS</a></li>
<li><a href="https://branch.io/glossary/deferred-deep-linking/">Deferred Deep Linking</a></li>
</ol>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block line-height-inherit">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/protocorn93" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/RxSwift/"><span class="level-start"><span class="level-item">RxSwift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/"><span class="level-start"><span class="level-item">WWDC</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/WWDC/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-23T07:22:27.000Z">2020-08-23</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/23/Embrace-Swift-type-inference/">Embrace Swift type inference</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/Swift/">Swift</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-26T08:37:48.000Z">2020-07-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/26/GeometryReader-in-SwiftUI/">GeometryReader in SwiftUI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-19T10:36:32.000Z">2020-07-19</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/19/App-essentials-in-SwiftUI/">App essentials in SwiftUI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-15T08:26:52.000Z">2020-02-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/15/SwiftUI-under-the-hood/">SwiftUI under the hood</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-01-08T11:16:48.000Z">2020-01-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/01/08/SwiftUI%EC%97%90%EC%84%9C-%EC%97%AC%EB%9F%AC-%ED%83%80%EC%9E%85%EC%9D%98-%EB%B7%B0-%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0/">SwiftUI에서 여러 타입의 뷰 반환하기</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/03/"><span class="level-start"><span class="level-item">March 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Binding/"><span class="tag">@Binding</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/State/"><span class="tag">@State</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ABI-Stability/"><span class="tag">ABI Stability</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AnyView/"><span class="tag">AnyView</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App/"><span class="tag">App</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Thinning/"><span class="tag">App Thinning</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bitcode/"><span class="tag">Bitcode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Custom-URL-Scheme/"><span class="tag">Custom URL Scheme</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GeometryReader/"><span class="tag">GeometryReader</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Group/"><span class="tag">Group</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Opaque-Type/"><span class="tag">Opaque Type</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OptionSet/"><span class="tag">OptionSet</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PreferenceKey/"><span class="tag">PreferenceKey</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Property-Wrappers/"><span class="tag">Property Wrappers</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxSwift/"><span class="tag">RxSwift</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scene/"><span class="tag">Scene</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift5/"><span class="tag">Swift5</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SwiftUI/"><span class="tag">SwiftUI</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Universal-Links/"><span class="tag">Universal Links</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/View/"><span class="tag">View</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC/"><span class="tag">WWDC</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC19/"><span class="tag">WWDC19</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WindowGroup/"><span class="tag">WindowGroup</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/enum/"><span class="tag">enum</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS-13/"><span class="tag">iOS 13</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/some/"><span class="tag">some</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%9D%B4%EC%A7%81/"><span class="tag">이직</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Corn the blog" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>