<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Corn the blog</title><meta property="og:type" content="blog"><meta property="og:title" content="Corn the blog"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="Corn the blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://yoursite.com/images/avatar.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="images/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"Corn the blog","image":["http://yoursite.com/images/avatar.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="ca-pub-3144516292555438" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-10-07T12:34:21.000Z" title="2020-10-07T12:34:21.000Z">2020-10-07</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/WidgetKit/">WidgetKit</a></span><span class="level-item">34 minutes read (About 5035 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/">Add configuration and intelligence to your widgets</a></h1><div class="content"><p>영상 링크 → <a href="https://developer.apple.com/videos/play/wwdc2020/10194/">링크</a></p>
<p>Meet WidgetKit 정리 → <a href="https://protocorn93.github.io/2020/09/20/Meet-WidgetKit/">링크</a></p>
<p>함께 보면 좋은 문서 → <a href="https://developer.apple.com/documentation/widgetkit/making-a-configurable-widget">Making a Configurable Widget</a></p>
<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>이 영상에선 위젯을 Configurable하게 만드는 방법과 Configurable한 위젯이 어떻게 시스템을 더욱 영리한 방식으로 작동하는데 도움을 줄 수 있는지에 대해 알아볼 것이다. </p>
<p>다음은 영상에서 살펴볼 예제 앱이다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/1.png" alt=""></p>
<p>카드별 결제 내역을 보여주는 앱으로 <code>최근 결제 내역</code>, <code>납부일 및 납부해야 할 총 금액</code>을 나타내는 두 가지 위젯을 제공한다.</p>
<p>이번 영상에서 다룰 주제의 목차는 다음과 같다. </p>
<ol>
<li>The Basics </li>
<li>Types of data entry </li>
<li>Configuration experience </li>
<li>System intelligence </li>
</ol>
<p>제일 먼저 위젯에 설정을 추가하는 방법을 살펴볼 것이다. 그 다음으로 사용자에게 입력하도록 요청할 수 있는 정보의 유형에 대해 설명하고, 앱의 데이터로 인터페이스를 채울 수 있는 방법을 살펴볼 것 이다. </p>
<p>이후엔 어떻게 위젯의 제목, 설명을 지정하고 배경색을 설정할 수 있는지에 대해 살펴볼 것이다. 마지막으론 스마트 스택에서 시스템이 여러분이 개발한 위젯이 노출되어야 할 시간을 보다 더 정확하게 예측할 수 있도록 설정을 추가하는 방법에 대해 살펴볼 예정이다.</p>
<h2 id="The-Basics"><a href="#The-Basics" class="headerlink" title="The Basics"></a>The Basics</h2><p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/2.png" alt=""></p>
<p>위젯이 설정 가능하다면 위젯 뒷면에 사용자에게 입력을 요청할 수 있는 옵션들을 지정할 수 있고, 시스템은 이를 사용자에게 보여줄 것이다. 이런 옵션, 즉 사용자가 정보를 입력할 수 있는 요소들을 <strong>파라미터</strong>라고 한다.</p>
<p>예제 앱에선 <code>Card</code> 파리미터와 <code>Category</code> 파라미터를 지정하여 사용자가 원하는 카드의 원하는 카테고리의 최근 결제 내역을 위젯에 보여줄 수 있다.</p>
<p>이런 파라미터를 정의하기 위해 <code>Siri</code>와 <code>Shortcut</code>에서 사용하고 있는 <code>Intent</code>를 사용한다. <code>Intent</code>에 추가한 파라미터는 위젯에 하나의 행으로 사용자에게 보여진다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/3.png" alt=""></p>
<p>Xcode에서 Intent Definition 파일을 통해 <code>Intent</code>를 선언할 수 있다. 이 파일에는 <code>Intent</code>와 더불어 그들의 파라미터 등도 포함된다. 이 파일을 통해 시스템은 <code>Intent</code>의 정보를 읽을 수 있다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/4.png" alt=""></p>
<p><code>Intent</code>를 정의하면 Xcode는 정의한 <code>Intent</code>와 이에 포함되는 파라미터를 프로퍼티로 갖는 클래스를 생성한다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/5.png" alt=""></p>
<p>이 클래스의 인스턴스는 런타임 중 위젯 익스텐션에 전달되며 이를 통해 위젯은 사용자가 무엇을 설정했고 사용자에게 무엇을 보여주어야 하는지를 알 수 있다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/6.png" alt=""></p>
<h2 id="Types-of-data-entry"><a href="#Types-of-data-entry" class="headerlink" title="Types of data entry"></a>Types of data entry</h2><p>위젯 설정에선 다양한 데이터 타입을 지원한다.</p>
<p><code>String</code> 타입의 파라미터를 지정하면 설정 화면은 텍스트 필드를 보여줄 것이고, <code>Boolean</code> 타입의 파라미터는 스위치를 보여줄 것이다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/7.png" alt=""></p>
<p>그리고 숫자는 <code>Int</code> 타입의 파라미터는 스테퍼를, <code>Decimal</code> 타입의 파라미터는 슬라이더를 지원한다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/8.png" alt=""></p>
<p>또한 설정 화면은 연락처 선택과 <code>Location</code> 타입의 파라미터를 위한 위치 선택 UI도 제공한다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/9.png" alt=""></p>
<p>설정 화면은 열거형도 지원하는데, 정적 열거형과 동적 열거형을 통해 이를 활용할 수 있다. 여기서 동적 열거형이란 사용자마다 차이가 있을 수 있는 앱의 사용자 데이터를 의미한다. (사용자가 추가한 카드(<code>Card</code>)는 앱을 사용하는 사용자마다 달라질 수 있다.) 동적 옵션은 아래에서 더 자세히 살펴보도록 하자.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/10.png" alt=""></p>
<p>설정 화면은 위에서 언급한 것들 말고도 다수의 타입을 각각의 고유한 UI로 지원한다.</p>
<ul>
<li>Date components</li>
<li>Duration</li>
<li>URL</li>
<li>Measurement</li>
<li>Currency amount</li>
<li>Payment method</li>
</ul>
<p>또한 파라미터는 다수의 값을 가질 수 있으며, iOS 14에서 Intent는 고정된 크기의 배열을 지원한다. 이를 통해 정의된 갯수만큼의 아이템만 배열에 들어갈 수 있게 지정할 수 있다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/11.png" alt=""></p>
<p> 그리고 위젯의 크기에 따라 이 갯수를 별도로 지정해줄 수 있다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/12.png" alt=""></p>
<blockquote>
<p>영상의 <a href="https://developer.apple.com/videos/play/wwdc2020-10194/?time=401">06:43</a> ~ <a href="https://developer.apple.com/videos/play/wwdc2020-10194/?time=575">09:39</a> 구간에선 기본적으로 Intent Definition 파일에 Intent와 그의 파라미터를 입력하는 방법을 보여주고 있다.</p>
</blockquote>
<h3 id="Dynamic-Options-and-Search"><a href="#Dynamic-Options-and-Search" class="headerlink" title="Dynamic Options and Search"></a>Dynamic Options and Search</h3><p><strong>Dynamic Options</strong></p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/13.png" alt=""></p>
<p>많은 경우, 위에서 언급한 사용자가 등록한 카드와 같이 위젯 설정에서 보여주고 싶은 데이터는 사용자마다 달라질 수 있다. 그리고 이런 유형의 데이터는 Intent Definition 파일에서 지정해줄 수 없다. </p>
<p>대신 Intent Definition 파일에서 <code>Dynamic Options</code> 체크박스를 체크하면 동적 옵션을 활성화할 수 있다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/14.png" alt=""></p>
<p>이렇게 동적 옵션을 활성화하면 위젯 설정 화면에서 원하는 값을 직접 입력할 수 있는 대신 사용자가 선택할 수 있는 값을 검색하기 위해 앱에 요청해야 한다는 사실을 시스템에 알리게 된다. 이렇게 동적 옵션을 활성화하면 두 가지가 발생한다. </p>
<p>첫째, 위젯의 뒷면(설정 화면)의 동적 옵션이 활성화된 파라미터의 UI가 옵션의 목록을 보여주는 모달을 여는 버튼 모영으로 변경된다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/15.png" alt=""></p>
<p>둘째, 여러분의 앱에서 구현해야 할 두 가지 메서드가 생성되는데, 하나는 선택 가능한 옵션을 제공하는 메서드, 나머지 하나는 기본 값을 제공하는 메서드이다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/16.png" alt=""></p>
<p>이 메서드들은 Xcode가 생성해주는 Intent Handler 프로토콜의 일부이다. 여러분은 앱이나 <code>Intent</code> 익스텐션에서 이 프로토콜을 채택하는 클래스를 생성해야 한다. 이 클래스는 사용자가 위젯을 설정할 때 선택 가능한 옵션을 제공하기 위해 시스템에 의해 사용된다.</p>
<p>예제 앱에선 아래와 같이 선택 가능한 카드의 목록과 기본 선택 카드를 위의 메서드 구현을 통해 제공하고 있다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/17.png" alt=""></p>
<p>선택 가능한 옵션을 제공하는 메서드를 사용하면 단순 리스트 형태로 옵션을 제공하거나 그룹화된 리스트 형태로 옵션을 제공할 수 있다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/18.png" alt=""></p>
<p>아래는 그룹화된 리스트 형태로 옵션을 제공한 모습이다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/19.png" alt=""></p>
<p><strong>Search</strong></p>
<p>기본적으로 상단의 검색 바는 여러분이 제공한 옵션을 필터링하는 역할을 한다. 몇몇의 경우 옵션이 리스트에 한번에 보이지 않을 정도로 많을 때 검색을 활용할 수 있다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/22.png" alt=""></p>
<p>이를 위해 <code>Intent handler provides search results as the user types</code> 체크박스를 활성화해야 한다. 또한 <code>Prompt Label</code>(검색에 도움을 줄 수 있는?)을 제공할 수도 있다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/23.png" alt=""></p>
<p><code>Intent handler provides search results as the user types</code> 체크박스를 활성화하면 선택 가능한 옵션을 제공하는 메서드는 <code>searchTerm</code> 파라미터를 추가로 받게 된다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/24.png" alt=""></p>
<p>처음 사용자가 리스트를 마주하면 이 메서드가 호출될 때 <code>searchTerm</code>은 <code>nil</code>로 전달된다. 그리고 이후에 사용자가 타이핑을 하기 시작하면 이 메서드는 입력된 문자열과 함께 다시 호출될 것이다.</p>
<blockquote>
<p>영상의 <a href="https://developer.apple.com/videos/play/wwdc2020-10194/?time=742">12:23</a> ~ <a href="https://developer.apple.com/videos/play/wwdc2020-10194/?time=911">15:11</a> 구간에선 동적 옵션을 구현하는 방법을 직접 시현을 통해 소개하고 있다.</p>
</blockquote>
<h2 id="Configuration-experience"><a href="#Configuration-experience" class="headerlink" title="Configuration experience"></a>Configuration experience</h2><p>이번엔 위젯의 설정 화면의 외형을 커스터마이징 해보자. </p>
<p>먼저 설정 화면의 제목과 설명을 <code>configurationDisplayName</code> 변경자와 <code>description</code> 변경자를 이용해 각각 지정해줄 수 있다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/25.png" alt=""></p>
<p>background와 accent 색상 역시 별도로 지정해줄 수 있다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/26.png" alt=""></p>
<p>이를 위해선 먼저 위젯 익스텐션의 에셋 카탈로그에 색상의 이름과 함께 색상을 추가해야 한다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/27.png" alt=""></p>
<p>그리고 이렇게 추가된 색상과 색상의 이름을 위젯 익스텐션의 build settings에서 각각 <code>Global Accent Color Name</code>과 <code>Widget Background Name</code>에 지정해주면 된다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/28.png" alt=""></p>
<p>그리고 설정 화면에서 특정 파라미터의 값을 기반으로 다른 파라미터를 보여주거나 숨기고 싶을 수 있는 경우가 생길 수 있다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/29.png" alt=""></p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/30.png" alt=""></p>
<p>위의 예제를 통해 두 파라미터의 관계를 살펴보면 <code>Mirror Calendar App</code>을 끄면, <code>Calendar</code> 파라미터가 나타나 어떤 캘린더가 보여야 하는지 수동으로 선택할 수 있어야 한다.</p>
<p>이를 위해 Intent Definition 파일</p>
<p>에서 <code>Calendar</code> 파라미터를 선택 후 <code>Mirror Calendar App</code> 파라미터를 <code>Parent Parameter</code>로 지정해주면 된다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/31.png" alt=""></p>
<p>그리고 <code>Mirror Calendar App</code>이 <code>false</code>일 때만 <code>Calendar</code>가 보여야 하기 때문에 <code>Show If Parent</code>를 <code>has exact value</code>로, <code>Value</code>를 <code>False</code>로 지정해야 한다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/32.png" alt=""></p>
<h2 id="System-intelligence"><a href="#System-intelligence" class="headerlink" title="System intelligence"></a>System intelligence</h2><p>위젯은 단순히 하나만 배치할 수도 있지만 스택안에서 여러 위젯을 관리할 수 있다. 그리고 이 스택을 통해 적절한 타이밍에 특정 위젯을 최상단으로 올려 사용자에게 매번 적절한 위젯을 보여줄 수 있다. 이렇게 시스템이 적절한 타이밍과 위젯을 고르는데 영향을 미치는 것이 바로 intelligence, 즉 지능이다.</p>
<p>이번 챕터에선 다음의 두 가지 물음에 대해 살펴볼 예정이다. </p>
<ul>
<li><strong>How do stacks behave intelligently?</strong></li>
<li><strong>How can i appear at just the right time?</strong></li>
</ul>
<p>첫 스택 지능을 구현하는 기본 설계 원리를 살펴보고 여러분이 개발한 앱을 이번에 새롭게 등장한 홈 스크린 경험(스택)의 일부에 포함시키기 위해선 어떻게 새 API들을 구현해야 하는지를 살펴볼 것이다.</p>
<h3 id="How-do-stacks-behave-intelligently"><a href="#How-do-stacks-behave-intelligently" class="headerlink" title="How do stacks behave intelligently?"></a>How do stacks behave intelligently?</h3><p>어떤 것이 좋은 스마트 스택을 만들수 있을까? </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/20.png" alt=""></p>
<p>스택은 사용자에게 분명한 가치를 적절한 타이밍에 한눈에 볼 수 있는 정보를 제공해야 한다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/21.png" alt=""></p>
<p>예를 들어 뇌우가 오고 있다는 사실을 앱이 안다면 사용자에게 단순히 온도를 주기적으로 갱신해주는 것보다 뇌우가 오고 있다는 사실을 알려주는 것이 더 직관적이다. </p>
<p>시스템은 위젯을 올릴 때 두 가지 요인에 기반한다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/33.png" alt=""></p>
<p>첫 번째는 사용자 행동 기반(behavior-based)이다. 시스템은 사용자가 특정 시간에 주로 찾는 정보를 제공하는 위젯을 해당 시간에 위로 올린다. 날씨 앱을 자주 들여다보는 사용자에겐 날씨 앱을 위로 올려 사용자가 이를 통해 날씨 정보를 빠르게 찾을 수 있도록 한다.</p>
<p>두 번째는 여러분의 앱이 제공하는 관련성 정보(relevant information)이다. 예를 들어 날씨 앱의 경우 뇌우가 왔을 때 위젯이 이를 시스템에 매우 관련성이 높은 정보가 있음을 알릴 수 있으며, 스택은 이를 통해 위젯을 위로 올릴지를 결정한다. </p>
<h3 id="How-can-i-appear-at-just-the-right-time"><a href="#How-can-i-appear-at-just-the-right-time" class="headerlink" title="How can i appear at just the right time?"></a><strong>How can i appear at just the right time?</strong></h3><p>시스템이 위젯을 올리는데 필요한 정보를 제공하는데 사용할 수 있는 API들에 대해 살펴보도록 하자. </p>
<p><strong>Behavior-based</strong></p>
<p>먼저 행동 기반 요인에 영향을 줄 수 있는 API에 대해 살펴보자. </p>
<p>iOS 12에서 등장한 Shortcuts와 사용자 정의 Intent donations를 통해 여러분의 앱에서 사용자가 무엇을 했는지 시스템에 알릴 수 있게 되었다. 그리고 시스템은 이 정보를 바탕으로 Spotlight에서 그 다음 행동을 예측 및 추천할 수 있다. iOS 14에서 시스템은 동일한 정보를 바탕으로 언제 여러분의 위젯을 위로 올릴 것인지를 결정한다. </p>
<p>예제 앱에서 사용자가 앱에서 특정 카드를 확인했을 때 이 사실을 시스템에 알릴 건데, 이를 Intent donation을 통해 시스템에 알릴 것이다. 내부적으로 이게 어떻게 동작하는지 알아보기 전에 먼저 이를 위한 세팅을 하는 법에 대해 살펴보자. </p>
<p>먼저 기존의 Intent Definition 파일에서 <code>Intent is elligible for Siri Suggestions</code> 항목을 활성화한다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/34.png" alt=""></p>
<p>해당 항목이 활성화되면 아래 <code>Suggestions</code> 필드가 추가된다. 우린 사용자가 앱에서 특정 카드를 확인했을 때 해당 카드의 내역을 보여주도록 구성된 위젯을 상단으로 올려야 하기 때문에 <code>Supported Combinations</code>에 <code>card</code> 파라미터를 추가해야 한다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/35.png" alt=""></p>
<p>이렇게 설정을 마쳤고, 앱에서 사용자가 카드를 확인했을 때 이 사실을 시스템에 알릴 수 있도록(donate) 코드를 작성해주어야 한다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/36.png" alt=""></p>
<p>예제 앱에서 사용되는 <code>ViewRecentPurchasesIntent</code>를 생성하고 여기에 현재 사용자가 확인한 <code>Card</code> 인스턴스를 담아 이를 <code>donate</code>하는 코드이다. 위에서 <code>Supported Combinations</code>에 <code>Card</code> 파라미터만 추가했기 때문에 <code>Category</code> 파라미터를 추가해도 시스템은 <code>Card</code>만 고려한다. </p>
<p>그럼 시스템이 이를 통해 어떻게 동작하는지를 살펴보도록 하자. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/37.png" alt=""></p>
<p>사용자가 식료품 가게에선 정오에 AcmeCard로 주로 결제하고 저녁은 주로 SoupPay로 결제한다고 했을 때 donate된 정보를 바탕으로 시스템은 각각 AcmeCard는 정오에, SoupPay는 저녁에 사용된다는 사실을 알 수 있기 때문에 카테고리에 상관없이 AcmeCard로 구성된 위젯을 정오에 위로 올릴 것이다. </p>
<p>만약에 <code>Supported Combinations</code>에 <code>Category</code>를 추가하고 <code>Intent</code>에 <code>Category</code>를 함께 donate한다면 시스템은 사용자가 명확하게 AcmeCard와 Groceries 카테고리로 설정한 위젯만 위로 올릴 것이다. 즉 <code>Supported Combinations</code>은 시스템과 소통하는 방법이다. </p>
<p>위의 과정을 요약하자면 아래와 같다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/38.png" alt=""></p>
<p><strong>Relevant Information</strong></p>
<p>이번에 살펴볼 API는 앱에서 중요하고 관련된 정보가 생겼을 때 시스템이 해당 위젯을 위로 올리는데 사용되는 API다.</p>
<p>먼저 Timeline을 간략하게 살펴보면, WidgetKit을 사용하여 다양한 시점에서 위젯의 모양을 결정하는 Timeline을 제공할 수 있다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/39.png" alt=""></p>
<p>또한 최근 구매 내역과 같이 구매가 발생했을 때 각각에 해당하는 entry를 제공함으로써 위젯이 이를 사용해 실시간으로 새 정보에 반응할 수 있다. </p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/40.png" alt=""></p>
<p>예제 앱에서 사용자가 $50 이상의 구매가 발생하면 알람을 받기 원한다고 가정했을 때, 어떻게하면 시스템에게 예제 앱 위젯이 관련성 높은 정보($50 이상의 구매가 발생)를 갖게 되었다고 알릴 수 있을까? </p>
<p><code>TimelineEntryRelevance</code> 객체를 <code>TimelineEntry</code>와 함께 제공함으로써 이런 정보를 시스템에 전달할 수 있다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/41.png" alt=""></p>
<p><code>TimelineEntry</code>는 세 가지 요소로 이루어져 있다. <code>Date</code>는 이 entry가 언제 랜더링되어야 하는지를 나타내고, <code>View</code>는 랜더링되어야 할 뷰를 의미한다. 그리고 이 entry의 연관성을 나타내는 <code>Relevance</code>는 <code>TimelineEntryRelevance</code> 객체로 <code>score</code>와 <code>duration</code> 프로퍼티를 갖는다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/42.png" alt=""></p>
<p><code>score</code>를 먼저 살펴보자면, <code>score</code>는 과거에 제공된 모든 entry들과 비교했을 때 이 entry가 얼마나 연관되어 있는지를 나타낸다. 시스템은 다른 entry들과 관련하여 <code>score</code>만을 고려하기 때문에 범위와 스케일은 정의하기에 달려 있다. 예외적으로 0과 그 이하의 <code>score</code>는 시스템에게 현재 위젯이 관련 정보를 갖고 있지 않고, 위로 올라오지 말아야 한다고 알리는데 사용된다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/43.png" alt=""></p>
<p>예제 앱으로 돌아와서 우리가 의도한대로 동작하기 위해 $50 이상의 구매가 발생했을 때는 1, 최근 구매 내역이 없으면 0 그리고 이외의 구매 내역은 0.1로 <code>score</code>로 지정해보자. 이렇게 <code>score</code>를 지정하면 사소한 구매 내역에 대해선 위젯이 올라올 수 있는 기회가 적지만 대신 굵직한 구매 내역은 확실한 우선순위를 갖을 수 있다.</p>
<p>다른 위젯들이 제공하는 <code>score</code>는 상관없음을 기억하자. score는 오로지 여러분이 제공한 <code>score</code>랑만 비교된다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/44.png" alt=""></p>
<p>이번엔 결제 금액을 <code>score</code>로 사용해보자. 이를 통해 특정 금액을 넘는지 아닌지가 아닌 결제 금액에 따른 우선순위가 정해진다. </p>
<p><code>score</code>를 살펴보았고 이제 <code>duration</code>을 살펴보자.</p>
<p><code>duration</code>은 잘 정의된 일정 시간동안 관련성 점수(<code>score</code>)를 고정할 때 사용된다. 그렇지 않으면 <code>duration</code>을 0으로 두면 된다. 이는 관련성 점수가 다음 <code>TimelineEntryRelevance</code>가 수신될 때 까지만 지속된다는 것을 의미한다.</p>
<p>다은 <code>duration</code>을 활용한 예제이다.</p>
<p><img src="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/45.png" alt=""></p>
<p>농구 게임의 진행 상태를 알려주는 위젯으로 게임 시작 전에는 <code>score</code>를 0으로 지정하고 게임이 시작하면 <code>score</code>를 1로 지정하고 이를 게임이 진행되는 동안 고정하기 위해 <code>duration</code>을 3시간으로 지정하였다. </p>
<p>그리고 게임이 진행되는동안 관련성 점수에 영향을 미치지 않도록 <code>TimelineEntryRelevance</code>를 <code>nil</code>로 두고 <code>TimelineEntry</code>를 갱신할 수 있다. </p>
<p>스택의 지능(intelligence)에  정리해보자. </p>
<p>우린 스마트 스택을 이용해 특정 위젯을 스택의 최상단으로 올릴 수 있는 기회를 갖는다. 이를 가능하게 하는 방법은 다음 두 가지다. </p>
<ul>
<li>Donate <code>INIntents</code> that match your configuration intent (User behavior-based)</li>
<li>Provide <code>TimelineEntryRelevance</code> for important information (Relevance information)</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-09-20T05:29:20.000Z" title="2020-09-20T05:29:20.000Z">2020-09-20</time><span class="level-item">9 minutes read (About 1275 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/">Stacks, Grids, and Outlines in SwiftUI</a></h1><div class="content"><p><a href="https://developer.apple.com/videos/play/wwdc2020/10031/">링크</a></p>
<p>SwiftUI은 기본 레이아웃 요소들은 Compositional 하게 사용 되도록 설계되었다. 이들 각각을 사용, 조합하여 원하는 레이아웃을 구성할 수 있다. </p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/1.png" alt=""></p>
<h2 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h2><p>우린 <code>VStack</code>과 <code>HStack</code>의 조합으로 아래와 같은 갤러리 레이아웃을 구성할 수 있다. 그리고 이들 Stack만으로는 스크롤이 불가능하기 때문에 <code>ScrollView</code> 안에 이들을 구성하였다.</p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/2.png" alt=""></p>
<p>하지만 갤러리 이미지가 많아질수록 그 모든 이미지를 한 번에 불러오는 데 있어 문제가 발생한다. 이는 반응성을 저해하는 요소가 될 수 있다. </p>
<p>이를 위해 Lazy 하게 컨텐츠를 불러올 수 있는, 즉 처음 랜더링될 때 필요한 컨텐츠만 불러오고 이후 필요할 때 나머지를 컨텐츠를 불러올 수 있는 <code>LazyVStack</code>과 <code>LazyHStack</code>이 새로 생겼다.</p>
<p>이들을 통해 메모리 공간이 불필요하게 커지는 것을 방지할 수 있다. 사용법은 매우 간단하다.</p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/3.png" alt=""></p>
<p>위의 갤러리 레이아웃에서 별점을 위한 <code>HStack</code>도 존재하는데, 이들 역시 Lazy 하게 구성해야 할까? </p>
<p>정답은 “아니오”다. 이들은 화면에 보여졌을 때 모든 컨텐츠를 한 번에 볼 수 있다. 그렇기 때문에 <code>LazyHStack</code>을 사용해서 그 어떤 이득도 볼 수 없다. 만일 일반 Stack과 Lazy Stack 중 어떤 것을 사용해야 할지 고민된다면 일반 Stack을 사용하는 걸 권장한다. </p>
<p>Instruments를 사용해 프로파일링을 한 후 성능의 병목 현상을 발견했고 이를 해결할 때만 Lazy Stack을 사용하도록 하자</p>
<h2 id="Grids"><a href="#Grids" class="headerlink" title="Grids"></a>Grids</h2><p>그리드 레이아웃을 위한 새로운 기본 레이아웃이 추가되었는데 <code>LazyVGrid</code>와 <code>LazyHGride</code>가 그것이다. 이들의 사용법 역시 그리 어렵진 않다.</p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/5.png" alt=""></p>
<p><code>LazyVGrid</code> 기준으로 원하는 행의 구성 정보와 함께 기존의 <code>VStack</code> 코드를 대체하였다. 그리고 이런 행의 정보를 나타내는 <code>GridItem</code> 역시 새로 추가되었다. </p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/7.png" alt=""></p>
<p><code>GridItem</code>을 사용해 그리드 레이아웃의 각각의 아이템의 크기와 위치를 지정해 줄 수 있다. </p>
<p>이들은 기본적으로 유연하기(<em>flexible</em>) 때문에 위와 같이 세 개의 <code>GridItem</code>을 사용하면 각 행의 너비는 모두 동일한 너비를 갖게 된다. </p>
<p><code>GridItem</code>은 단순히 갯수만이 아닌 최소 너비 값과 같은 특정 사이즈 크기를 이용해 원하는 그리드 레이아웃을 구성하는데 사용할 수 있다. </p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/8.png" alt=""></p>
<h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p><code>List</code> 역시 기본 레이아웃 구성 요소 중 하나로 스크롤과 선택된 항목(<em>selection</em>) 관리와 같은 인터렉션을 지원하는 레이아웃 요소이다. <code>List</code>는 항상 컨텐츠를 Lazy 하게 불러온다.</p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/9.png" alt=""></p>
<p>이뿐만 아니라 이번에 추가된 기능으로 우린 리스트를 통해 컨텐츠를 그룹화하여 표현할 수 있게 되었다.</p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/10.png" alt=""></p>
<p><code>children</code> keypath를 사용하는 생성자를 통해 우린 <code>List</code>의 컨텐츠를 쉽게 그룹화할 수 있게 되었다. 내부적으로 어떻게 이것이 가능한지 살펴보도록 하자.</p>
<h2 id="Outlines"><a href="#Outlines" class="headerlink" title="Outlines"></a>Outlines</h2><p><code>OutlineGroup</code>은 <code>ForEach</code>와 동일하게 데이터를 순회하지만 단일 계층의 flat 한 콜렉션 타입의 데이터를 순회하는 <code>ForEach</code>와 달리 <code>OutlineGroup</code>은 트리 구조 형태의 데이터 타입을 순회한다.</p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/11.png" alt=""></p>
<p><code>OutlineGroup</code>을 <code>Section</code>과 함께 사용하면 <code>.listStyle(_:)</code>에 따라 다양한 기본 스타일의 헤더 뷰를 사용할 수 있다.</p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/12.png" alt=""></p>
<p>이렇게 계층화된 데이터를 사용해 동일한 외형의 Row를 사용하는 것이 아니라 서로 다른 데이터 타입이지만 단순히 이들을 계층화하고, 보여주기와 숨기기 기능을 사용하고 싶다면 이번에 새로 추가된 <code>DisclosureGroup</code>을 사용하면 된다.</p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/13.png" alt=""></p>
<p><code>OutlineGroup</code>이 내부적으로 어떻게 동작하는지 살펴보자.</p>
<p><img src="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/14.png" alt=""></p>
<ol>
<li>예제의 <code>OutlineGroup</code>은 <code>graphics</code> 모델을 사용한다. </li>
<li><code>OutlineGroup</code>은 동일한 모델을 사용하는 <code>ForEach</code>로 확장된다. </li>
<li><code>ForEach</code>의 <code>body</code>는 <code>DisclosureGroup</code>으로 <code>graphics</code>의 아이템 하나를 사용한다. </li>
<li><code>DisclosureGroup</code>은 다시 하나의 <code>graphic</code>를 데이터로 갖는 <code>OutlineGroup</code>을 <code>body</code>로 갖는다.</li>
</ol>
<p>이런 1~4의 과정은 <code>children</code>이 없는 <code>graphic</code>을 찾을 때까지 반복된다. 이러한 계산 과정은 그룹이 확장되었을 때(사용자가 그룹을 확장시켰을 때)에만 진행되기 때문에 최소한의 과정만을 갖게 된다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-09-20T03:04:00.000Z" title="2020-09-20T03:04:00.000Z">2020-09-20</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></span><span class="level-item">18 minutes read (About 2675 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/20/Meet-WidgetKit/">Meet WidgetKit</a></h1><div class="content"><blockquote>
<p> <a href="https://developer.apple.com/videos/play/wwdc2020/10028/">링크</a></p>
</blockquote>
<h2 id="What-makes-a-greate-Widget"><a href="#What-makes-a-greate-Widget" class="headerlink" title="What makes a greate Widget?"></a>What makes a greate Widget?</h2><p><img src="/2020/09/20/Meet-WidgetKit/1.png" alt=""></p>
<h3 id="Glanceable"><a href="#Glanceable" class="headerlink" title="Glanceable"></a>Glanceable</h3><p><img src="/2020/09/20/Meet-WidgetKit/2.png" alt=""></p>
<p>위젯은 미니앱이 아니다. 단순히 앱의 컨텐츠를 보여주는 것이므로, 컨텐츠에 집중해야하며 한 눈에 볼 수 있는(<em>Glanceable</em>) 컨텐츠를 제공해야 한다. </p>
<h3 id="Relevant"><a href="#Relevant" class="headerlink" title="Relevant"></a>Relevant</h3><p>스마트 스택을 이용해 특정 시점에 적절한 위젯을 보여주어야 한다. 즉 연관성이 있어야 한다. </p>
<p>연관성을 뒷받침 하는 요소들은 다음과 같다. </p>
<ul>
<li>Stacks use on-device intelligence</li>
<li>Siri Shortcuts donation</li>
<li>WidgetKit API</li>
</ul>
<p><a href="https://developer.apple.com/videos/play/wwdc2020/10194/">관련 WWDC 세션 - Add Configuration and intelligence to Your Widgets</a></p>
<h3 id="Personalized"><a href="#Personalized" class="headerlink" title="Personalized"></a>Personalized</h3><p><img src="/2020/09/20/Meet-WidgetKit/2-5.png" alt=""></p>
<p>위젯에는 세 가지 크기가 존재한다. 모든 크기를 지원할 필요는 없지만 최대한 많은 사이즈를 지원해 위젯의 개인화를 더욱 향상 시킬 수 있다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/4.png" alt=""></p>
<p>또한 Shortcut에서 사용했던 Intent를 이용해 구성 옵션(Configuration Option)과 구성 화면(Configuration UI)를 쉽게 구현할 수 있다.</p>
<h2 id="How-WidgetKit-works"><a href="#How-WidgetKit-works" class="headerlink" title="How WidgetKit works"></a>How WidgetKit works</h2><p>위젯은 멀티플랫폼을 지원해야 하기 때문에 SwiftUI로 만들어졌다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/5.png" alt=""></p>
<p>위젯은 위에서 언급했듯이 한 눈에 볼 수 있어야(<em>Glanceable</em>) 한다. 이를 위해 WidgetKit은 타임라인에 따른 연속된 뷰 계층을 반환해야 한다. 그렇기 때문에 이는 백그라운드 익스텐션에 속한다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/6.png" alt=""></p>
<p>타임라인에 따른 연속된 뷰 계층을 패키징하여 홈 스크린에 전달하면 홈 스크린은 주어진 타임라인에 따라 정해진 뷰를 그리게 된다. 우리는 이런 메커니즘을 통해 런치 프로세스, 뷰 로딩 등을 피할 수 있다. 이를 통해 위젯은 항상 적절한 컨텐츠를 즉시 볼 수 있게끔 준비되어 있다.</p>
<p>이렇게 미리 뷰가 준비되어 있다는 것은 다른 곳에서 이를 재사용할 수 있다는 것을 의미한다. 아래는 이렇게 준비된 뷰가 위젯 갤러리에서 사용되는 모습이다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/7.png" alt=""></p>
<p>이런 타임라인 메커니즘으로 우리는 위젯을 통해 항상 적절한 컨텐츠를 바로 볼 수 있다. </p>
<p>그리고 이런 타임라인은 메인 앱에서 사용자가 컨텐츠에 영향을 주는 데이터를 변경했을 때 갱신될 수 있다. 혹은 익스텐션에서 이러한 갱신을 스케쥴링해줄 수도 있다.</p>
<p>예를 들어 캘린더 위젯은 하루동안의 이벤트가 언제 일어날지에 대해 알고 있다. 익스텐션은 이 정보를 바탕으로 적절한 시간에 해당하는 뷰를 랜더링한다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/8.png" alt=""></p>
<h2 id="How-to-make-a-great-Widget"><a href="#How-to-make-a-great-Widget" class="headerlink" title="How to make a great Widget?"></a>How to make a great Widget?</h2><p>훌륭한 위젯을 만드는 방법을 아래 주제들을 통해 알아보자</p>
<ul>
<li>Defining a widget</li>
<li>Creating a glanceable experience</li>
<li>Views, timelines and reloads</li>
<li>Personaliztion and intelligence</li>
</ul>
<h3 id="Defining-a-widget"><a href="#Defining-a-widget" class="headerlink" title="Defining a widget"></a>Defining a widget</h3><p>위젯을 정의하기 위해선 몇 가지 컨셉에 대해서 짚고 넢어가야한다. </p>
<ul>
<li><code>kind</code></li>
<li><code>configuration</code></li>
<li><code>supportFamilies</code></li>
<li><code>placeholder</code></li>
</ul>
<p>처음 위젯을 설계할 때 하나의 익스텐션으로 다양한 유형의 위젯을 지원할 수 있는 메커니즘을 구상했다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/9.png" alt=""></p>
<p>주식 앱 익스텐션을 예로 들자면, 이는 몇 가지 종목에 대한 개요를 볼 수 있는 위젯을 제공한다. 하지만 추가로 한 가지 종목에 대한 상세 정보를 확인할 수 있는 위젯을 제공하거나 혹은 macOS의 알람 센터에서 확인할 수 있는 위젯을 제공한다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/10.png" alt=""></p>
<p><img src="/2020/09/20/Meet-WidgetKit/11.png" alt=""></p>
<p>위젯의 종류(<code>kind</code>)는 자신들이 어떤 유형의 Configuration을 지원하는지를 나타내기도 한다. 이런 Configuration에는 두 가지가 존재한다. </p>
<ul>
<li><code>StaticConfiguration</code></li>
<li><code>IntentConfiguration</code></li>
</ul>
<p><img src="/2020/09/20/Meet-WidgetKit/12.png" alt=""></p>
<p><strong><code>StaticConfiguration</code></strong></p>
<p>피트니스앱의 위젯은 단순히 현재 피트니스 상태를 알려주고, 딱히 사용자가 이를 구성할 수 있도록 지원할 필요는 없다. 이는 <code>StaticConfiguration</code> 타입이다.</p>
<p><img src="/2020/09/20/Meet-WidgetKit/13.png" alt=""></p>
<p><strong><code>IntentConfiguration</code></strong></p>
<p>다시 알림앱은 목록을 사용자가 수정하고 개인화할 수 있다. 이는 <code>IntentConfiguration</code> 타입에 해당한다.</p>
<p><img src="/2020/09/20/Meet-WidgetKit/14.png" alt=""></p>
<p>위젯은 하나 혹은 다수의 <code>supportedFamilies</code>를 지원할 수 있다. 기본적으로 위젯은 모든 <code>supportedFamilies</code> 타입을 지원한다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/14-5.png" alt=""></p>
<p><code>placeholder</code>는 위젯의 기본 컨텐츠(Default Content)가 된다. <code>placeholder</code>를 통해 위젯이 어떤 유형의 컨텐츠를 제공하는지만을 나타내야지 사용자 데이터가 포함되어 있어서는 안된다. </p>
<p>또한 <code>placeholder</code>는 자주 볼 수 있는 UI가 아니고 언제 보일지는 보장할 수 없다. 일반적으로 기기 환경 설정이 변경되었을 때 새 <code>placeholder</code>를 요청하곤 한다. </p>
<p>사용자에게 위젯이 어떤 유형의 컨텐츠를 제공하는지를 잘 나타내는 <code>placeholder</code>가 훌륭한 <code>placeholder</code>다.</p>
<p><img src="/2020/09/20/Meet-WidgetKit/16.png" alt=""></p>
<p>아래의 코드는 위에서 살펴본 네 가지 키워드가 모두 담겨져있다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/17.png" alt=""></p>
<h3 id="Creating-a-glanceable-experience"><a href="#Creating-a-glanceable-experience" class="headerlink" title="Creating a glanceable experience"></a>Creating a glanceable experience</h3><p>아래는 glanceable한 위젯의 예들이다. 위젯은 유용한 정보를 제공하며 사용자로 하여금 위젯을 탭 하여 더 많은 정보를 볼 수 있게끔 유도하고 있다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/18.png" alt=""></p>
<p>한 눈에 보기 쉬운 위젯을 만들기 위한 요소 중 하나는 Stateless한 UI다. 이는 다음과 같은 특성을 갖는다. </p>
<ul>
<li>No Scrolling</li>
<li>No videos or animated images</li>
<li>Tap interactions</li>
</ul>
<p>위젯은 딥 링크를 지원하므로, 탭을 통해 메인 앱의 특정 컨텐츠로 사용자를 유도할 수 있다. 이런 딥 링크는 <a href="https://www.notion.so/bakedcorn/Meet-WidgetKit-01d8e3012b8b400298808b6017a14d08">widgetURL</a>를 이용해 구현할 수 있다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/19.png" alt=""></p>
<h3 id="Views-timelines-and-reloads"><a href="#Views-timelines-and-reloads" class="headerlink" title="Views, timelines and reloads"></a>Views, timelines and reloads</h3><p>뷰, 타임라인 그리고 갱신은 위젯의 엔진 역할을 한다. </p>
<p>뷰를 위한 세 가지 개념이 존재한다. </p>
<ul>
<li>Placeholder</li>
<li>Snapshot</li>
<li>Timeline</li>
</ul>
<p><strong><u>Snapshot</u></strong></p>
<p>Snapshot은 시스템이 위젯을 빠르게 제공하기 위해 필요한 단일 진입점이다. 이를 위해 익스텐션은 이 뷰를 최대한 빨리 반환해주어야 한다. 그리고 이렇게 반환된 Snapshot은 위젯 갤러리에서 확인할 수 있다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/20.png" alt=""></p>
<p>보통 Timeline의 첫 번째 진입점과 Snapshot은 동일한 진입점으로 반환될 수 있다. 그렇기 때문에 위젯 갤러리에서 보는 것은 사용자가 위젯을 디바이스에 추가했을 때의 보는 모습과 동일하다.</p>
<p>Snapshot이 단지 하나의 단일 진입점이라면, 제시간에 보여지는 다수의 연속된 뷰는 Timeline이라고 할 수 있다.</p>
<p><strong><u>Timeline</u></strong></p>
<p>Timeline은 뷰와 날짜의 조합으로 어떤 뷰가 언제 보여져야 하는지를 나타낸다. Timeline은 다크모드, 라이트모드 모두  반환해야 한다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/21.png" alt=""></p>
<p>익스텐션이 진입점을 제공하면 우리는 이 정보를 받아 디스크에 뷰 계층을 직렬화한다. 이를 통해 적절한 타이밍에 각 항목을 렌더링할 수 있다. 이런 방식으로 시스템은 수많은 Timeline을 통해 동시에 수많은 위젯에 이를 적용할 수 있다. </p>
<p>타임라인은 일반적으로 하루치 컨텐츠를 제공해야 한다. 그러나 주어진 시간에 따른 컨텐츠가 아닌 최신 정보를 보여주어야 할 때가 있다. 우린 이를 갱신(Reload)이라 부른다.</p>
<p><strong><u>Reload</u></strong></p>
<p>Reload란, 시스템이 익스텐션을 깨우고 각각의 위젯을 위한 새 Timeline을 요청하는 것을 말한다. Reload를 통해 사용자의 컨텐츠가 항상 최신 상태로 유지되도록 할 수 있다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/22.png" alt=""></p>
<p>아래는 <a href="https://developer.apple.com/documentation/widgetkit/timelineprovider"><code>TimelineProvider</code></a> 프로토콜로 WidgetKit에 언제 위젯을 갱신해주어여 하는지 알릴 때 사용된다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/23.png" alt=""></p>
<p><code>reloadPolicy</code></p>
<p>시스템에게 언제 다음 Timeline을 요청해야 하는지를 알려주는 일종의 갱신 정책이다. </p>
<ul>
<li><p><code>atEnd</code></p>
</li>
<li><p><code>after(date: Date)</code></p>
</li>
<li><p><code>never</code></p>
<p><a href="https://developer.apple.com/documentation/widgetkit/keeping-a-widget-up-to-date">관련 개발자 문서</a></p>
</li>
</ul>
<p><img src="https://docs-assets.developer.apple.com/published/2971813b6a098a34d134a04e38a50b83/1900/WidgetKit-Timeline-At-End@2x.png" alt=""></p>
<p>시스템은 reloadPolicy를 받아 위젯을 갱신(reload)한다. 자주 보는 위젯은 더 자주 갱신될 것이고,  아닌 위젯은 덜 자주 갱실될 것이다. 또한 기기 환경 설정이 변경되면 시스템은 강제로 위젯을 갱신한다. </p>
<p>이렇게 시스템에 의한 위젯 갱신도 있지만 메인 앱 주도의 갱신도 존재한다. </p>
<p><img src="/2020/09/20/Meet-WidgetKit/24.png" alt=""></p>
<p>백그라운드 노티피케이션 혹은 앱 내의 데이터 변경에 의해 위젯이 갱신될 수 있는데 이때 우리는 <a href="https://developer.apple.com/documentation/widgetkit/widgetcenter"><code>WidgetCenter</code></a>를 사용해 위젯을 갱신해줄 수 있다.  </p>
<p><img src="/2020/09/20/Meet-WidgetKit/25.png" alt=""></p>
<p>서버로부터 받아온 정보를 바탕으로 위젯을 갱신해주기 위해선 백그라운드 세션을 사용해야 한다. 또한 서버 통신으로 만들어진 payload는 <a href="https://developer.apple.com/documentation/widgetkit/intentconfiguration/onbackgroundurlsessionevents(matching:_:)-78bry">onBackgroundURLSesionEvents</a> 변경자를 통해 전달된다. 요청은 일괄처리하고, 서버 통신은 필요한만큼만 사용해야 한다. </p>
<p>위젯은 매초마다 수행되는 작업이 아니다. 실시간 실행 환경도 아니다. 상태에 맞는 갱신 정책을 통해 위젯을 효율적으로 갱신해야 한다.</p>
<p><img src="/2020/09/20/Meet-WidgetKit/26.png" alt=""></p>
<h3 id="Personalized-and-intelligence"><a href="#Personalized-and-intelligence" class="headerlink" title="Personalized and intelligence"></a>Personalized and intelligence</h3><p>위젯의 개인화와 지능은 두 가지 요소로 결정된다. </p>
<ul>
<li><strong>Intents</strong></li>
<li><strong>Relevance</strong></li>
</ul>
<p><strong><u>Intents</u></strong></p>
<p>Intent는 사용자가 위젯을 구성하는데 사용되는 메커니즘이다.</p>
<p>Intent를 통해 사용자에게 일종의 질문을 하고 (어떤 위치의 날씨 정보를 원하는지, 어떤 주식 종목을 원하는지) 시스템이나 앱은 이에 대한 응답으로 위젯을 갱신한다. 이를 통해 우린 위젯의 사용자화를 향상시킬 수 있다. </p>
<p><strong><u>Relevance</u></strong></p>
<p>스마트 스택의 지능에 영향을 미칠 수 있는 요인 중 하나다. </p>
<blockquote>
<p><em>When users perform actions in your app, your app can donate shortcuts.<br>If your widget is backed by the same INIntent, then your widget may be rotated to in the stack when the user would have typically perform that action.</em></p>
</blockquote>
<p>또한 <a href="https://developer.apple.com/documentation/widgetkit/timelineentryrelevance"><code>TimelineEntryRelevance</code></a> 구조체의 <code>score</code>와 <code>duration</code>을 이용해 관련성(Relevance)에 영향을 줄 수 있다.</p>
<p>[관련 WWDC 세션 - Add Configuration and intelligence to Your Widgets](</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-08-23T07:22:27.000Z" title="2020-08-23T07:22:27.000Z">2020-08-23</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/Swift/">Swift</a></span><span class="level-item">10 minutes read (About 1446 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/23/Embrace-Swift-type-inference/">Embrace Swift type inference</a></h1><div class="content"><blockquote>
<p><a href="https://developer.apple.com/videos/play/wwdc2020/10165/">WWDC 2020</a></p>
</blockquote>
<p>스위프트는 코드의 안전성을 훼손하지 않고 간결한 코드를 작성하기 위해 <strong>타입 추론(Type inference)</strong>을 광범위하게 사용한다.</p>
<p>이 영상을 통해 우리는 다음의 것들을 살펴볼 것이다. </p>
<ol>
<li>타입 추론을 활용하는 법</li>
<li>컴파일러에서 타입 추론이 어떻게 동작하는지 </li>
<li>타입 추론에 의해 발생할 수 있는 에러의 원인과 이를 해결하는 방법 </li>
</ol>
<p><strong>What is type inference?</strong></p>
<p>먼저 타입 추론이 무엇인지 간단하게 알아보자. </p>
<p>타입 추론은 프로퍼티에 타입을 명시적으로 선언하지 않아도 컴파일러가 문맥에 따라 타입을 추론하는 것을 말한다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/1.png" alt="img"></p>
<p>위의 코드에서 <code>String</code>을 명시적으로 선언하지 않아도 컴파일러는 이를 <code>String</code>으로 추론한다. 좀 더 복잡한 예제 코드로 타입 추론을 활용하고, 컴파일러에서 타입 추론이 어떻게 동작하는지를 살펴보자. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/2.png" alt="img"></p>
<p>위의 코드에서 <code>FilteredList</code>는 주어진 데이터를 리스트 형태로 보여주고 필터링 기능을 제공하는 재사용 가능한 뷰다. 이 <code>FilteredList</code>는 재사용 가능해야 하므로 기본적으로 생성자 인자들은 제네릭 해야 한다. 위의 코드에서 <code>FilteredList</code>를 사용하면서 따로 타입을 명시해 주지 않고 있다. 이는 컴파일러가 타입 추론을 하기 때문에 가능한 일인데, 이를 좀 더 알아보기 위해 <code>FilteredList</code>가 어떻게 정의되어 있는지 코드로 살펴보도록 하자</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/3.png" alt="img"></p>
<p><code>Element</code>, <code>FilterKey</code> 그리고 <code>RowContent</code>는 <code>FileteredList</code>가 생성될 때 실제 타입, 즉 Concrete 타입으로 대체된다. 이제 선언부와 호출부를 나란히 두고 비교해보자.</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/4.png" alt="img"></p>
<p>제네릭 타입으로 인해 복잡한 선언부와 비교했을 때 호출부는 훨씬 깔끔한 코드임을 확인할 수 있다. 이는 컴파일러가 주어진 값들로 타입 추론을 하기 때문에 가능한 일인데, 타입 추론이 아닌 명시적으로 타입을 명시한다면 아래와 보다 복잡한 코드를 작성해야 한다.</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/5.png" alt="글"></p>
<p>그렇다면 컴파일러는 어떻게 타입 추론을 하는 것일까? 타입 추론은 일종의 퍼즐이라고 할 수 있다. 우린 퍼즐을 하면서 하나의 조각이 맞춰질 때 다음 조각을 자연스럽게 유추할 수 있다. 하나의 퍼즐이 맞춰질 때마다 다음 조각에 대한 단서를 우린 유추할 수 있다. 컴파일러는 이렇게 퍼즐을 풀 듯이 우리의 코드에서 단서를 찾아 퍼즐을 하나씩 맞춰가며 타입을 추론한다. </p>
<p>위의 코드를 사용해서 컴파일러가 어떻게 퍼즐을 맞춰가는지 살펴보자. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/6.png" alt="img"></p>
<p>먼저 첫 번째로 인자로 넘기는 <code>smoothies</code>라는 단서를 통해 <code>Element</code>의 타입을 추론할 수 있다. <code>smoothies</code>는 <code>[Smoothie]</code> 타입으로 <code>Element</code>는 <code>Smoothie</code> 타입으로 대체된다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/7.png" alt="img"></p>
<p>우린 <code>Element</code>라는 퍼즐 조각을 맞췄기 때문에 이를 통해 또 다른 단서를 얻을 수 있다. 바로 <code>FilterKey</code>다. <code>\.title</code>은 <code>\Smoothe.title</code>로 대체되고 <code>Smoothie</code>의 <code>title</code> 프로퍼티는 <code>String</code>이란 것을 알 수 있기 때문에 <code>FilterKey</code>는 <code>String</code>으로 대체된다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/8.png" alt="img"></p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/9.png" alt="img"></p>
<p><code>RowContent</code> 역시 <code>ViewBuilder</code> 클로저 안에서 <code>SmoothieRowView</code>가 반환되기 때문에 <code>SmoothieRowView</code>로 대체될 수 있다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/10.png" alt="img"></p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/11.png" alt="img"></p>
<p>이런 식으로 컴파일러는 이전 단계의 단서를 통해 하나씩 타입을 추론해 나간다. 하지만 이렇게 얻은 이전 단계의 퍼즐 조각(단서)이 맞지 않는다면 소스 코드에 에러가 발생했다는 것을 의미한다. 즉 맞지 않은 타입이 들어갔기 때문에 컴파일러는 더 이상 타입 추론을 진행할 수 없다.</p>
<p><code>Smoothie.title</code>이 아닌 <code>Bool</code> 타입의 <code>Smoothie.isPopular</code>로 바꿔보자</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/12.png" alt="img"></p>
<p>그렇다면 컴파일러는 <code>Bool</code> 타입을 <code>FilterKey</code>의 조각으로 사용할 것이다. 하지만 <code>Bool</code> 타입은 <code>hasSubString(_:)</code> 메서드가 없기 때문에 이후의 타입 추론을 진행할 수 없고, 에러를 뱉는다. </p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/13.png" alt="img"></p>
<p>이렇게 스위프트 컴파일러는 추후에 에러 메시지를 출력할 때 사용하기 위해 에러 추적 기능을 타입 추론에 통합시켰다. 컴파일러는 타입 추론을 진행하면서 직면한 에러를 기록한다. 그리고 컴파일러는 에러를 고치고 타입 추론을 계속 진행하기 위해 <a href="https://ko.wikipedia.org/wiki/휴리스틱_이론">휴리스틱</a>을 사용한다.</p>
<p>그리고 타입 추론이 끝나면 컴파일러는 타입 추론을 진행하면서 수집한 에러를 actionable한 에러 메시지(자동으로 코드를 수정할 수 있는)나 에러를 발생시킨 실제 타입에 대한 메시지와 함께 개발자에게 알린다.</p>
<p><img src="/2020/08/23/Embrace-Swift-type-inference/14.png" alt="img"></p>
<p>이렇게 통합된 에러 추적 시스템은 Xcode11.4의 스위프트 5.2에선 많은 오류 메시지에 도입되었고, Xcode12의 스위프트 5.3에선 모든 에러 메시지에 적용되었다. Embrace Swift type inference</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-26T08:37:48.000Z" title="2020-07-26T08:37:48.000Z">2020-07-26</time><span class="level-item"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></span><span class="level-item">14 minutes read (About 2029 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/26/GeometryReader-in-SwiftUI/">GeometryReader in SwiftUI</a></h1><div class="content"><p>SwiftUI를 공부하다 보면 자연스레 등장하는 개념이 바로 <code>GeometryReader</code>다. 어렴풋이 이해하고 있던 개념을 포스팅을 통해 정리해보려 한다. </p>
<h2 id="What-is-GeometryReader"><a href="#What-is-GeometryReader" class="headerlink" title="What is GeometryReader"></a>What is GeometryReader</h2><p><code>GeometryReader</code>란 무엇인가? </p>
<p>SwiftUI에선 UIKit으로 레이아웃을 작성할 때와 달리 뷰 객체에 직접 접근할 수 없다. 뷰 객체에 직접 접근해 뷰 정보(size, position 등)에 알 수 있었던 것과 달리 SwiftUI에서 뷰 객체는 일시적인(<em>transient</em>) 객체로 프레임워크가 뷰를 그리고 난 후 객체는 사라지기 때문에 UIKit과 같은 방식으론 뷰에 관한 정보를 알 수 없다.</p>
<p>그렇다고 모든 뷰에 <code>.frame(width:, height)</code> 변경자를 사용해 직접 고정 값을 넣을 수도 없는 일이다. 이를 위해 등장한 개념이 <code>GeometryReader</code>로 상위 뷰의 <em>Geometry</em> 정보를 하위 뷰에 제공하는 역할을 한다. </p>
<blockquote>
<p>보다 정확히는 상위 뷰가 제안한 <em>Geometry</em> 정보</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">    	<span class="comment">// proxy를 통해 뷰 정보에 접근.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GeometryReader</code>에 대해 더 자세히 살펴보기 전에 아직은 완성되지 않은 듯한 애플 공식 문서가 설명하고 있는 <code>GeometryReader</code>를 살펴보자. </p>
<p><em>A container view that defines its content as a function of its own size and coordinate space.</em></p>
<p><em>컨텐츠를 자신의 크기 및 좌표 공간의 함수로 정의하는 컨테이너 뷰</em> </p>
<p>이 설명을 통해 자세히는 아니지만 몇 가지 키워드로 힌트는 얻을 수 있다. </p>
<ul>
<li>컨테이너 뷰 </li>
<li>자신의 크기 및 좌표 공간</li>
</ul>
<h3 id="Layout-Process"><a href="#Layout-Process" class="headerlink" title="Layout Process"></a>Layout Process</h3><p><code>GeometryReader</code>를 이해하고 올바르게 사용하려면, SwiftUI에서 레이아웃을 그리는 세 단계에 대해 반드시 이해해야 할 필요가 있다. </p>
<blockquote>
<p><a href="https://protocorn93.github.io/2020/02/15/SwiftUI-under-the-hood/">이전 글</a>을 참고하셔도 좋습니다.</p>
</blockquote>
<p>이 세 단계를 간단히 요약하자면 아래와 같다.</p>
<ol>
<li>부모 뷰가 자식 뷰의 사이즈를 제안한다. </li>
<li>자식 뷰는 제안받은 사이즈를 이용해 자신의 사이즈를 결정한다. (<code>(언제나 제안받은 사이즈 == 자신의 사이즈) == false</code>)</li>
<li>부모 뷰는 결정된 자식 뷰를 적절히 위치시킨다. </li>
</ol>
<p><strong><code>GeometryReader</code>는 상위 뷰에서 제안한 사이즈를 자신의 사이즈로 사용 및 반환한다.</strong> 가능한한 최대한 확장한다고 생각하면 된다.</p>
<h2 id="GeometryProxy"><a href="#GeometryProxy" class="headerlink" title="GeometryProxy"></a>GeometryProxy</h2><p><code>GeometryReader</code>는 컨테이너 뷰의 한 종류이며, 다른 컨테이너 뷰의 <code>ViewBuilder</code>와는 다르게 인자를 하나 받는데 그것이 바로 <code>GeometryProxy</code> 객체다. 실제로 상위 뷰의 정보는 이 객체를 통해 접근이 가능하다. 기본적으로 위에서 살펴보았듯이 <code>GeometryProxy</code>는 <code>size</code> 프로퍼티를 갖고 있다. </p>
<p>이외에도 <code>.frame(in: )</code>라는 메서드가 있으며, 서브스크립트도 지원한다. </p>
<h3 id="frame-in"><a href="#frame-in" class="headerlink" title=".frame(in:)"></a>.frame(in:)</h3><p><code>GeometryReader</code>를 통해 <code>size</code>뿐만 아니라 <code>.frame</code> 메서드를 통해 <code>CGRect</code>에 접근해, 좌표값도 알 수 있다. </p>
<p>이 좌표값은 지정한 좌표평면 공간에 따라 달라질 수 있다. </p>
<ul>
<li><code>.local</code> - 자신이 속한 컨테이너 뷰 안에서의 좌표를 반환한다.</li>
<li><code>.global</code> - 전체 스크린에서의 좌표를 반환한다. </li>
<li><code>.named(_:)</code> - 지정한 좌표평면에서의 좌표를 반환한다. <ul>
<li><code>.coordinateSpace(name:</code> 을 통해 사용자 정의 좌표평면을 지정할 수 있다. </li>
</ul>
</li>
</ul>
<p><code>.frame(in:)</code> 메서드를 통해 UIKit에서 <code>convert</code> 메서드를 사용해 좌표를 변환하던 작업이 보다 수월해졌다. </p>
<p><img src="/2020/07/26/GeometryReader-in-SwiftUI/frame.png" alt=""></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">            <span class="type">HStack</span>(spacing: <span class="number">0.0</span>) &#123;</span><br><span class="line">              ...</span><br><span class="line">                    <span class="type">ZStack</span>(alignment: .topLeading) &#123;</span><br><span class="line">                      ...</span><br><span class="line">                        <span class="type">GeometryReader</span> &#123; innerProxy <span class="keyword">in</span></span><br><span class="line">                            <span class="type">Rectangle</span>()</span><br><span class="line">                                .foregroundColor(<span class="type">Color</span>.pink)</span><br><span class="line">                                .onTapGesture &#123;</span><br><span class="line">                                    <span class="keyword">let</span> local = innerProxy.frame(<span class="keyword">in</span>: .local)</span><br><span class="line">                                    <span class="keyword">let</span> global = innerProxy.frame(<span class="keyword">in</span>: .global)</span><br><span class="line">                                    <span class="keyword">let</span> named = innerProxy.frame(<span class="keyword">in</span>: .named(<span class="string">"OuterGeometry"</span>))</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"[local] minX : \(local.origin.x), minY : \(local.origin.y)"</span>)</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"[global] minX : \(global.origin.x), minY : \(global.origin.y)"</span>)</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"[named] minX : \(named.origin.x), minY : \(named.origin.y)"</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;.frame(width: <span class="number">50</span>, height: <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.coordinateSpace(name: <span class="string">"OuterGeometry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[RESULT]</span><br><span class="line">[local] minX : 0.0, minY : 0.0</span><br><span class="line">[global] minX : 112.5, minY : 20.0</span><br><span class="line">[named] minX : 112.5, minY : 0.0</span><br></pre></td></tr></table></figure>



<h3 id="subscript-Anchor-gt-T"><a href="#subscript-Anchor-gt-T" class="headerlink" title="subscript(Anchor) -&gt; T"></a>subscript(Anchor) -&gt; T</h3><p><code>GeometryProxy</code>의 서브스크립트를 이해하기 위해선 <code>Anchor</code>와 함께 <strong>Preferences</strong>에 대한 이해가 있어야 한다. 그러므로 이는 추후 <strong>Preferences</strong>에 대한 포스팅에서 함께 다뤄볼 예정이다. </p>
<blockquote>
<p><strong>Preferences</strong>는 <code>GeometryReader</code>와 함께 SwiftUI에서 중요한 개념 중 하나로, 하위 뷰에서 상위 뷰로 정보를 전달하는데 사용된다. </p>
</blockquote>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>그럼 우린 <code>GeometryReader</code>를 어떻게 사용할 수 있을까? 위에서 언급했듯이 기본적으로 상위 뷰와 비례해 하위 뷰의 사이즈를 조정할 때 사용할 수 있다.</p>
<p>추가로 위에서 언급했던 <strong>“<code>GeometryReader</code>는 상위 뷰에서 제안한 사이즈를 자신의 사이즈로 사용 및 반환한다.”</strong> 특성을 이용하여  Preferences와 함께 사용될 때 하위 뷰의 <em>geometry</em> 정보를 상위 뷰에 전달할 때도 유용하게 사용할 수 있다.  </p>
<p><img src="/2020/07/26/GeometryReader-in-SwiftUI/usage.png" alt=""></p>
<p>위의 결과 화면은 <code>VStack</code> 내부의 <code>Text</code>들 중 가장 너비가 큰 값을 이용해 <code>Text</code> 각각의 <code>background</code>에 <code>Circle</code>을 위치시킨 결과다. 그럼 <code>Circle</code>의 적절한 너비와 높이 값이 정해져야 하는데 이 정보는 어떻게 알 수 있으며 어떻게 지정해야 할까?</p>
<p>Preferences에 관한 포스팅에서도 더 자세히 살펴볼 코드지만 그중 일부만 살펴보자. </p>
<blockquote>
<p>그전에 <a href="https://swiftui-lab.com/geometryreader-to-the-rescue/">이 글</a>을 참고하면 조금이나마 코드를 이해하는데 도움이 될 수 있습니다. </p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">  .padding()</span><br><span class="line">  .fixedSize()</span><br><span class="line">  .background(<span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">    <span class="type">Color</span>.clear.preference(key: <span class="type">SizePreferenceKey</span>.<span class="keyword">self</span>,</span><br><span class="line">                           value: [proxy.size])</span><br><span class="line">    &#125;)</span><br><span class="line">  .frame(width: size?.width, height: size?.width)</span><br><span class="line">  .background(</span><br><span class="line">    <span class="type">Circle</span>()</span><br><span class="line">      .fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p><code>background</code>안에 투명한 <code>Color</code> 뷰를 넣어 해당 <code>Text</code>의 <code>size</code> 값을 알 수 있다.</p>
<p>그 이유를 이해하기 위해선 역시 Layout Process에 대한 이해가 필요한데, 기본적으로 <code>background</code>는 caller의 사이즈를 그대로 인자로 들어가는 뷰에 제안한다. 그리고 <code>GeometryReader</code>는 제안받은 사이즈를 자신의 사이즈로 반환하기 때문에 위의 코드에서 <code>proxy</code>의 사이즈가 곧 <code>Text</code>의 <code>size</code>가 된다. </p>
<p>이렇게 알아낸 <code>Text</code>의 사이즈를 상위 뷰로 전달하고 상위 뷰는 이렇게 취합된 <code>Text</code>들의 사이즈 중 가장 큰 사이즈로 <code>Text</code>들의 너비를 조정해 파란색 <code>Circle</code>에 올바른 사이즈를 제안할 수 있게 된다. </p>
<h3 id="Bugs🐛"><a href="#Bugs🐛" class="headerlink" title="Bugs🐛"></a>Bugs🐛</h3><hr>
<p>사실 버그라고 해야 할지, 단순히 버전 차이에 따른 차이인지 정확하게는 알 수 없다. 하지만 iOS 13.x 버전과 iOS 14 버전에서의 <code>GeometryReader</code>의 동작 방식에는 차이가 있다. </p>
<p>바로 <code>GeometryReader</code> 하위 뷰들의 정렬 차이인데, 아래의 이미지를 통해 그 차이를 살펴보자.</p>
<p><img src="/2020/07/26/GeometryReader-in-SwiftUI/Differences.png" alt=""></p>
<p>코드의 구조는 대략 아래와 같다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123; </span><br><span class="line">  <span class="type">GeometryReader</span> &#123; </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"…"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">Text</span>(<span class="string">"…"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.x 버전에선 <code>GeometryReader</code>가 <code>Text</code>를 기본적으로 가운데 위치시키지만, iOS 14 버전에선 <code>Text</code>를 왼쪽 상단 모서리에 위치시킨다. 구글링을 해보았지만, 딱히 명확한 이유를 알 수 없었다..😇</p>
<blockquote>
<p>이에 대해 알고 있는 부분이 있으시다면 댓글 부탁드립니다 </p>
</blockquote>
<p>.</p>
<p>.</p>
<p>.</p>
<p><strong>[는 하루만에 이유를 찾았다.] 😅</strong></p>
<p>그 이유는 <a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-12-beta-release-notes">Xcode 12 beta 3 release note</a>에서 찾을 수 있었다.</p>
<blockquote>
<p>Resolved in Xcode 12 beta</p>
<ul>
<li>Rebuilding against the iOS 14, macOS 11, watchOS 7, and tvOS 14 SDKs changes uses of <a href="https://developer.apple.com/documentation/swiftui/geometryreader"><code>GeometryReader</code></a> to reliably top-leading align the views inside the <a href="https://developer.apple.com/documentation/swiftui/geometryreader"><code>GeometryReader</code></a>. This was the previous behavior, <em>except</em> when it wasn’t possible to detect a single static view inside the <a href="https://developer.apple.com/documentation/swiftui/geometryreader"><code>GeometryReader</code></a>. (59722992) (FB7597816)</li>
</ul>
</blockquote>
<p>즉 <strong>top-leading 정렬이 정상 동작</strong>이며, <code>GeometryReader</code>가 단일 정적 뷰를 내부 뷰로 가져갈 경우 이를 감지 못하던 이슈(가운데 정렬시키던)가 해결되었다고 언급하고 있다. </p>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://www.hackingwithswift.com/books/ios-swiftui/understanding-frames-and-coordinates-inside-geometryreader">Understanding frames and coordinates inside GeometryReader</a></li>
<li><a href="https://swiftui-lab.com/geometryreader-to-the-rescue/">GeometryReader to the Rescue</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-07-19T10:36:32.000Z" title="2020-07-19T10:36:32.000Z">2020-07-19</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></span><span class="level-item">11 minutes read (About 1601 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/19/App-essentials-in-SwiftUI/">App essentials in SwiftUI</a></h1><div class="content"><blockquote>
<p> WWDC 2020을 통해 SwiftUI에선 <code>App</code>과 <code>Scene</code> 개념이 추가됐다. 이를 소개하고 있는 <a href="https://developer.apple.com/videos/play/wwdc2020/10040/">App essentials in SwiftUI</a> 세션을 보고 간단히 정리해보았다. </p>
</blockquote>
<p>새롭게 등장한 <code>App</code>, <code>Scene</code> 개념으로 UIKit 없이 순수 SwiftUI로만 앱을 만들 수 있게 됐다. </p>
<h2 id="Views-scenes-and-apps"><a href="#Views-scenes-and-apps" class="headerlink" title="Views, scenes and apps"></a>Views, scenes and apps</h2><p><img src="/2020/07/19/App-essentials-in-SwiftUI/1.png" alt=""></p>
<p>화면에 보이는 모든 뷰가 하나의 앱에 속하는 것이 아니기 때문에, 하나의 앱이 전체 화면에 대해 완벽히 제어할 수 없다. 나누어진 영역에서 앱이 보여지는 방법은 플랫폼이 제어한다. SwiftUI에선 이렇게 화면 안에 구분된 영역을 <code>Scene</code>이라 부른다. </p>
<p>윈도우는 화면에 보여지는 <code>Scene</code>의 컨텐츠를 보여주는 가장 흔한 방법이다. iPadOS와 같은 플랫폼은 다수의 윈도우를 나란히 보여줄 수 있다. iOS나 watchOS 그리고 tvOS는 각각의 앱에 대해서 하나의 꽉 찬 단일 윈도우를 선호한다. macOS는 <code>Scene</code>의 컨텐츠가 얼마나 다양한 방법으로 보여질 수 있는가를 나타내는 좋은 예다. </p>
<p>macOS에선 아래와 같이 다수의 윈도우로 개별 <code>Scene</code>을 보여주거나 탭으로 여러 <code>Scene</code>을 묶어 보여줄 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/2.png" alt=""><br><img src="/2020/07/19/App-essentials-in-SwiftUI/3.png" alt=""></p>
<p>이렇게 다수의 <code>Scene</code>은 <code>App</code>을 구성하고 <code>App</code>, <code>Scene</code> 그리고 <code>View</code>는 하나의 계층 구조를 이룬다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/4.png" alt=""></p>
<p>아래의 앱과 코드를 살펴보자. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/5.png" alt=""></p>
<p><code>ReadingListViewer</code>는 <code>View</code>로 <code>Scene</code>의 한 종류인 <code>WindowGroup</code>에 속한다. 그리고 <code>WindowGroup</code>은 <code>App</code> 프로토콜을 따르는 <code>BookClubApp</code>의 <code>Scene</code>으로 사용된다. 코드에서 확인할 수 있는 계층구조와 우리가 위에서 살펴본 계층구조가 일치하는 것을 확인할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/6.png" alt=""></p>
<p>그리고 <code>BookClubApp</code>과 <code>ReadingListViewer</code>가 선언된 코드 구조도 유사한 것을 확인할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/7.png" alt=""></p>
<ul>
<li><code>App</code>과 <code>View</code>, 둘 모두 Data Dependency를 선언할 수 있다. <ul>
<li><code>BoolClubApp</code> - <code>@StateObject</code><ul>
<li><code>@StateObject</code>는 이번에 새로 등장한 개념으로 이는 추후에 살펴보도록 하자</li>
</ul>
</li>
<li><code>ReadingListViewer</code> - <code>@ObservedObject</code></li>
</ul>
</li>
<li><code>App</code>과 <code>View</code>, 둘 모두 <code>body</code> 프로퍼티를 통해 사용자 인터페이스를 표시한다. <ul>
<li><code>BookClubApp</code> - <code>var body: some Scene</code></li>
<li><code>ReadingListViewer</code> - <code>var body: some View</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>세션의 주제와 별개로 Swift 5.3부터 등장한 <code>@main</code>이 선언되어 있는 것을 확인할 수 있다. 이는 프로그램의 시작점을 의미한다. 기본적으로 스위프트 프로그램은 <code>main.swift</code>를 필요로 하는데 <code>@main</code>을 통해 <code>App</code> 프로토콜을 따르고 있는 구조체에 해당 책임을 위임할 수 있다. </p>
</blockquote>
<h2 id="Understanding-Scenes"><a href="#Understanding-Scenes" class="headerlink" title="Understanding Scenes"></a>Understanding Scenes</h2><h3 id="WindowGroup"><a href="#WindowGroup" class="headerlink" title="WindowGroup"></a>WindowGroup</h3><p><code>WindowGroup</code>을 통해 다수의 윈도우를 독립적으로 관리할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/8.png" alt=""></p>
<p>그리고 이렇게 독립된 윈도우는 서로 독립된 상태를 갖는데 이것이 SwiftUI에서 <code>Scene</code>의 가장 중요한 특징이라고 할 수 있다. </p>
<p>각각의 독립된 윈도우는 서로의 상태에 영향을 주지 않는다. <code>App</code>은 각 <code>Scene</code>이 사용할 수 있는 Shared Model을 제공할 수 있지만, 각 <code>Scene</code>의 뷰들의 상태는 서로 독립적이다. </p>
<p>그리고 위와 같이 앱 스위처에서 보여지는 타이틀을 뷰 변경자를 통해 윈도우별로 다르게 지정할 수 있다. 이는 부모 <code>Scene</code>의 상태에 영향을 줄 수 있는 변경자 중 하나이다. </p>
<p>macOS에선 <code>WindowGroup</code>을 사용해 아래의 기능들을 제공할 수 있다.</p>
<ul>
<li>다중 윈도우</li>
<li>파일 메뉴에 새 윈도우 생성 메뉴 아이템 추가<ul>
<li>단축키 지원 (<code>Command + N</code>)</li>
</ul>
</li>
<li>윈도우 메뉴<ul>
<li>개별 윈도우를 위한 메뉴 아이템(윈도우 타이틀)</li>
<li>다수의 윈도우를 하나의 탭 인터페이스로 통합하는 기능을 지원하는 메뉴 아이템</li>
</ul>
</li>
</ul>
<p>이 모든 것들은 부가적인 코드 없이 SwiftUI가 자동으로 지원하는 기능들이다. </p>
<p><code>Scene</code>의 생명주기는 실행되고 있는 플랫폼에 의해 관리된다. macOS에선 새 윈도우가 필요하면 <code>WindowGroup</code>은 새 자식 <code>Scene</code>을 생성한다. 이처럼 macOS나 iPadOS와 같이 다중 윈도우를 지원하는 플랫폼에선 <code>WindowGroup</code>은 다수의 자식 <code>Scene</code>을 생성할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/9.png" alt=""></p>
<p>각각의 윈도우는 사용자 인터페이스 정의를 공유하지만 모두 독립된 상태를 갖는다. 그렇기 때문에 하나의 윈도우에서의 변화는 다른 윈도우에 영향을 주지 않는다.</p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/10.png" alt=""></p>
<p>플랫폼이 <code>Scene</code> 생명주기 관리에 책임이 있기 때문에, 각 뷰의 상태를 관리할 수 있는 새 프로퍼티 래퍼인 <code>@SceneStorage</code>라는 개념이 새로 등장했다.</p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/11.png" alt=""></p>
<p>이는 고유 키 값을 이용해 저장될 상태를 식별한다. 그리고 상태는 SwiftUI에 의해 적절한 타이밍에 저장되고 복원된다. </p>
<h2 id="Customizing-Apps"><a href="#Customizing-Apps" class="headerlink" title="Customizing Apps"></a>Customizing Apps</h2><h3 id="Document-based-App"><a href="#Document-based-App" class="headerlink" title="Document based App"></a>Document based App</h3><p>지금까지 살펴본 <code>BookClubApp</code>은 Data-Driven 앱으로 Shared Model을 기반으로 하는 형태의 앱이었다. </p>
<p>이런 형태의 앱뿐만 아니라, 문서 기반의 앱도 존재한다. 이런 형태의 앱에선 <code>DocumentGroup</code>을 사용할 수 있다. </p>
<p><code>DocumentGroup</code>은 열기, 편집, 저장과 같이 문서 기반의 앱을 관리하는데 필요한 기능을 제공하는 <code>Scene</code>의 한 종류다.</p>
<h3 id="Preferences-Window"><a href="#Preferences-Window" class="headerlink" title="Preferences Window"></a>Preferences Window</h3><p>설정 윈도우(<em>Preferences Window</em>)는 macOS 앱들이 제공하는 공통적인 기능 중 하나이다. </p>
<p>이를 위해 macOS에는 새로운 <code>Scene</code> 타입인  <code>Settings</code> 타입이 추가되었다. 이는 기본적인 설정 윈도우와 관련 단축키도 제공한다.</p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/12.png" alt=""></p>
<p>그리고 우린 기본 단축키 이외의 단축키도 새 변경자 API를 통해 지원할 수 있다. </p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/13.png" alt=""></p>
<p><img src="/2020/07/19/App-essentials-in-SwiftUI/14.png" alt=""></p>
<hr>
<p>해당 세션을 통해 앱과 관련하여 새로 추가된 기능 및 API들에 대해 간단히 알아볼 수 있었다. 길지 않은 세션이기 때문에 출,퇴근길에 간단하게 시청할 수 있는 세션이었다. </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-15T08:26:52.000Z" title="2020-02-15T08:26:52.000Z">2020-02-15</time><span class="level-item"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></span><span class="level-item">23 minutes read (About 3398 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/15/SwiftUI-under-the-hood/">SwiftUI under the hood</a></h1><div class="content"><p>요즘 SwiftUI를 공부하면서 느낀 점은 마냥 쉽지만은 않다는 것이다. 흔히 SwiftUI를 소개할 때 매우 쉽게 UI를 그릴 수 있는 프레임워크로 소개하곤 하는데, 완전히 틀린 말은 아니지만 그렇다고 완전히 맞는 말도 아닌 것 같다. SwiftUI를 공부하면서 처음 iOS를 공부했을 때, 더 나아가 처음 프로그래밍을 공부했을 때가 종종 생각나곤 한다. </p>
<p>당시 처음으로 프로그래밍 언어를 가르쳐 주신 강사님으로부터 기본적인 C 언어 문법을 배우고 모든 걸 배운 것처럼 기세등등했던 적이 있다. 자신감이 한없이 하늘을 찌르고 있을 때 강사님은 다음과 같은 말씀을 해주셨다. </p>
<p>*”원래 처음 프로그래밍을 배우고 기본 문법을 마친 사람들이 프로그래밍을 매우 쉽다고 생각하고 자만하게 됩니다. 하지만 공부를 하면 할수록 어렵게 느껴지고 자신감이 떨어질 수 있는 공부가 프로그래밍입니다.”*</p>
<blockquote>
<p>비단 프로그래밍에만 국한되는 이야기는 아닌 것 같다.</p>
</blockquote>
<p>당시에는 이해가 가질 않았으나, 본격적으로 학부 공부를 시작하고 취업 준비를 하면서 저 말이 계속해서 떠올랐고 자신감이 자주 떨어지곤 했다. SwiftUI를 공부하면서도 마찬가지였다. 처음 <code>VStack</code>, <code>List</code> 등을 사용하면서 그 간편함에 놀라고 매우 쉽다고 생각했다. 하지만 데이터의 흐름과 레이아웃이 결정되는 방식 등 깊게 파고들면 파고들수록 머릿속은 여러 개념들이 완전하지 않은 채  뒤엉키게 되었다. 그렇게 혼란스러워하던 중 한 컨퍼런스에서 Chris Eidhof가 “SwiftUI under the hood”란 주제로 발표한 영상을 보고 복잡하고 산발되어 있던 개념들이 어느 정도 정리가 되면서 여러 개념들의 존재 이유와 목적에 대해 감을 잡을 수 있었다. 오늘은 그 영상의 내용을 요약 및 정리해보는 시간을 가지려 한다. </p>
<blockquote>
<p>영상 : <a href="https://youtu.be/GuK6wwX8M0E">Chris Eidhof - SwiftUI under the hood</a></p>
</blockquote>
<p>영상에서 다루는 큰 주제는 레이아웃 알고리즘이다. 즉 SwiftUI가 어떤 방식으로 레이아웃을 그리는지에 대해 다룬다. 이를 설명하면서 <code>GeometryReader</code>, <code>Preference</code> 등 중요한 개념들이 자연스럽게 등장하며 설명을 돕는다.</p>
<p>서론이 너무 길었다. 바로 시작해보자.</p>
<hr>
<h3 id="Layout-Algorithm"><a href="#Layout-Algorithm" class="headerlink" title="Layout Algorithm"></a>Layout Algorithm</h3><p>파란색 배경의 원 안에 텍스트가 존재하는 뷰를 만든다고 상상해보자. 원이 아닌 다양한 도형이 될 수 있다. 즉 매우 흔한 상황이다. 우리가 원하는 결과물은 다음과 같을 것이다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/0.5.png" alt=""></p>
<p>매우 쉬워 보인다! 그럼 코드로 이를 만들어보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">	.background(</span><br><span class="line">    <span class="type">Circle</span>()</span><br><span class="line">    .fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>기대하던 모습이 나올까? 그렇지 않다. 그 모습은 우리가 기대하던 모습과 거리가 멀다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/1.png" alt=""></p>
<p>이유가 무엇일까? 그 이유를 알기 위해선 SwiftUI의 레이아웃 알고리즘에 대한 이해가 있어야 한다. 모든 레이아웃은 다음 4가지 단계를 통해 그려진다. </p>
<ol>
<li>컨테이너 뷰(직계 상위 뷰)가 사이즈를 제안한다. </li>
<li>하위 뷰가 자신의 사이즈를 결정한다. (하위 뷰는 상위 뷰가 제안한 사이즈를 그대로 사용하거나, 본인이 자신의 사이즈를 결정하기도 한다.)</li>
<li>하위 뷰가 컨테이너 뷰에 자신의 사이즈를 알린다. (2단계에서 결정된 사이즈로 컨테이너 뷰의 사이즈가 정해진다.)</li>
<li>컨테이너 뷰가 하위 뷰를 가운데 정렬 시킨다. (<code>alignment</code>)</li>
</ol>
<p>이는 아주 기본적인 절차이고 여러 값들의 재정의를 통해 변경될 수 있다. 그럼 이 알고리즘을 바탕으로 위의 코드를 분석해보자. 먼저 위의 코드로 그려진 뷰의 계층을 뷰 디버깅을 통해 살펴보고 아래 설명을 따라가면서 이해해보자.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/3.png" alt=""></p>
<ol>
<li><p>먼저 루트 뷰(root view)가 화면 전체 사이즈를 <code>background</code>에게 제안한다. 그리고 <code>background</code>는 이를 다시 <code>Text</code>에게 전달한다. </p>
<blockquote>
<p>Modifier는 새로운 뷰를 만들고 이전 뷰를 감싸서 반환한다는 것을 기억한다면 <code>background</code>가 <code>Text</code>를 감싸고 있다는 것을 이해할 수 있다. </p>
</blockquote>
</li>
<li><p>하지만 <code>Text</code>는 자신이 담고 있는 내용만큼만 필요하기 때문에 <code>&quot;Reset&quot;</code>만큼만 사용할 것을 <code>backgroud</code>에 알린다. </p>
</li>
<li><p>그럼 다시 <code>background</code>는 이를 하위 뷰인 <code>ShapeView</code>에 알리고 <code>ShapeView</code>는 이를 <code>Circle</code>에게 알린다. (<code>ShapeView</code>와 <code>Text</code>는 형제-자매(sibling) 관계다.) <code>Circle</code>는 받은 크기(<code>Text</code>의 크기)를 그대로 사용해서 그 크기에 딱 맞는 원을 그린다.</p>
</li>
<li><p>그리고 이를 <code>background</code>에게 전달하고 <code>background</code>는 다시 이 크기를 루트 뷰에 전달하고 루트 뷰는 해당 뷰를 가운데 정렬한다.</p>
</li>
</ol>
<p>뷰 계층과 알고리즘을 따라가보면 왜 우리가 원하는 레이아웃이 나오지 않았는지에 대해 이해할 수 있다. 그럼 우리가 원하는 레이아웃을 그리기 위해선 어떻게 해야 할까?</p>
<p>가장 먼저 떠오르는 생각은 <code>frame</code> 변경자를 사용하는 것이다. 사용하기에 앞서 <code>frame</code> 변경자의 특징을 알아야 한다. <strong><code>frame</code> 변경자는 상위 뷰에서 오는 크기 정보나, 하위 뷰에서 알려주는 크기 정보를 모두 무시하고 자신의 인자로 넘어온 크기 정보만 사용한다.</strong> 이 점을 기억하고 아래 코드를 살펴보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line"><span class="comment">//.frame(width: 75, height: 75) // --- 1</span></span><br><span class="line">	.background(</span><br><span class="line">    <span class="type">Circle</span>()</span><br><span class="line">    	.fill(<span class="type">Color</span>.blue)</span><br><span class="line"><span class="comment">//    .frame(width: 75, height: 75) // --- 2</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">//.frame(width: 75, height: 75) // --- 3</span></span><br></pre></td></tr></table></figure>

<p><code>frame</code> 연산자를 1, 2번 두 곳 중 한 곳에만 위치시켜도 원하는 레이아웃을 그릴 수 있다. 하지만 두 곳 모두 문제점을 갖고 있다. </p>
<ol>
<li><p>위에서 언급했듯이 <code>frame</code>은 하위 뷰에서 알려준 크기 정보도 무시한다. 즉 <code>Text</code>가 정한 크기도 무시한다는 뜻이다. 그렇기 때문에 이곳에 <code>frame</code>을 위치시면 길어진 문자열 크기를 <code>Text</code>가 아무리 <code>frame</code>에 알려도 <code>frame</code>은 자신의 정보로 크기를 결정하기 때문에 문자열은 75x75 영역 안에서 벗어날 수 없고, 해당 영역 안에 표시되지 못한 부분은 말 줄임표(<code>...</code>)로 나타나게 된다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/5.png" alt=""></p>
</li>
<li><p><code>frame</code> 영역은 <code>Circle</code>에만 영향을 주기 때문에 문자열이 길어지면 원의 영역을 벗어난다. </p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/6.png" alt=""></p>
</li>
</ol>
<p><code>frame</code>을 3번에 위치시키면 어떻게 될까? <code>frame</code>이 이 크기 정보(75x75)를 <code>background</code>에게 <code>background</code>가 다시 <code>Text</code>에 전달하지만 <code>Text</code>는 자신이 담고 있는 내용만큼만 사용한다고 <code>background</code>에 알리고 <code>background</code>는 이 정보를 다시 <code>Circle</code>에 전달하기 때문에 결과적으로 위에서 봤던 레이아웃과 동일한 것을 육안으로 확인할 수 있다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/4.png" alt=""></p>
<p>육안으로 확인한 레이아웃이 같다고 실제로 그 둘이 같은 것은 아니다. 전체를 감싸고 있는 뷰의 크기 차이가 존재한다(파란 테두리가 감싸고 있는 영역). 그 이유는 위에서 언급했듯이 <code>frame</code>은 하위 뷰에서 보낸 정보도 무시하기 때문에 자신의 크기 정보(75x75)를 사용한다. 그렇기 때문에 전체를 감싸고 있는 뷰의 크기에 차이가 생기는 것이다.</p>
<p>문제를 해결하기 위해선 <code>frame</code> 안에 들어갈 값은 문자열의 길이에 따라 동적으로 변경되어야 한다. 정확히는 <code>Text</code>의 크기에 따라 변경되어야 한다. 그럼 <code>Text</code>의 크기는 어떻게 알 수 있을까? UIKit을 사용할 땐 객체에 직접 접근해 값을 가져올 수 있었다. 하지만 SwiftUI에선 불가능하다. 우리는 이 문제점을 <code>GeometryReader</code>를 사용해 해결해보려 한다. </p>
<h3 id="GeometryReader"><a href="#GeometryReader" class="headerlink" title="GeometryReader"></a>GeometryReader</h3><p><code>GeometryReader</code>는 SwiftUI에서 중요한 개념이지만 이번 포스팅에선 현재 상황에서 <code>GeometryReader</code>가 해결할 수 있는 부분에 대해서만 간단하게 설명해보고자 한다. </p>
<p><code>GeometryReader</code>는 컨테이너 뷰의 한 종류로 자신의 직계 상위 뷰의 기하학(Geometry) 정보(좌표, 크기 등)를 자신이 포함하는 자식 뷰에게 제공하는 역할을 한다. 그럼 바로 사용해보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">	.padding()</span><br><span class="line">	.fixedSize()</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span> </span><br><span class="line">    	<span class="comment">// proxy.size.width == Text("Reset")'s width               </span></span><br><span class="line">		&#125;</span><br><span class="line">  )</span><br><span class="line">	.frame(width: <span class="number">75</span>, height: <span class="number">75</span>)</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">Circle</span>()</span><br><span class="line">    	.fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>fixedSize</code> 변경자는 <code>Text</code>에만 존재하는 변경자로 아무리 문자열이 길어져도 1줄에 보여주도록 강제한다. 이를 사용하면 위에서 보았던 이미지처럼 주어진 크기 안에서 문자열이 길어질 때 여러 줄과 함께 말 줄임표로 보여주는 것이 아니라 영역을 벗어나더라도 문자열을 1줄에 보여줄 수 있다.</p>
</blockquote>
<p>단순히 직계 상위 뷰의 정보를 받아온다고 생각하지 말고 위에서 살펴보았던 레이아웃 결정 과정을 대입해서 생각해보자.</p>
<ol>
<li><code>background</code>는 루트 뷰로부터 크기를 제안받는다. </li>
<li><code>background</code>는 그 크기를 <code>Text</code>에게 제안한다.</li>
<li><code>Text</code>는 자신이 포함하는 내용만을 담을 수 있는 크기를 사용하기로 결정하고 이를 <code>background</code>에게 알린다.</li>
<li><code>background</code>는 그 정보를 <code>GeometryReader</code>에게 알린다. </li>
</ol>
<p>이런 순서로 <code>GeometryReader</code>는 직계 상위 뷰의 정보를 받아올 수 있는 것이다. 정확히 표현하자면 <code>Text</code>에 의해 결정된 크기를 사용하는 <code>background</code>의 크기 정보를 받아온 것이다. 그럼 우린 이 크기 정보를 사용하면 된다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> width: <span class="type">CGFloat?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">	.padding()</span><br><span class="line">	.fixedSize()</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span> </span><br><span class="line">      <span class="keyword">self</span>.width = proxy.size.width</span><br><span class="line">		&#125;</span><br><span class="line">  )</span><br><span class="line">	.frame(width: <span class="keyword">self</span>.width, height: <span class="keyword">self</span>.width)</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">Circle</span>()</span><br><span class="line">    	.fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>위와 같이 코드를 작성할 수 있을 것 같지만 실제로 이렇게 작성하면 에러가 발생한다. 왜냐하면 <code>GeometryReader</code>는 생성자로 <code>@ViewBuilder</code>를 받기 때문에 <code>self.width = proxy.size.width</code>와 같은 코드는 <code>@ViewBuilder</code> 안에 작성할 수 없다.</p>
<p>우린 이 시점에서 프록시(<code>GeometryProxy</code>)에 담긴 크기 정보를 바로 <code>width</code> 프로퍼티에 할당할 수 없다. 우린 이 정보를 뷰 계층 위로 전달해야 한다. 이렇게 하위 뷰에서 상위 뷰로 정보를 전달하기 위해서 사용하는 것이 바로 <code>Preference</code>다.</p>
<h3 id="Preference"><a href="#Preference" class="headerlink" title="Preference"></a>Preference</h3><p><code>Preference</code> 역시 <code>GeometryReader</code>와 마찬가지로 굉장히 중요한 개념 중 하나이다. 하지만 마찬가지로 현재 상황에서 <code>Preference</code>가 해결할 수 있는 부분에 대해서만 간단하게 설명해보고자 한다. </p>
<p><code>Preference</code>는 키-밸류 메커니즘으로 하위 뷰 정보를 상위 뷰에 전달할 수 있는 수단이다. 이를 위해선 먼저 <code>PreferenceKey</code> 프로토콜을 따르는 키를 정의해주어야 한다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SizeKey</span>: <span class="title">PreferenceKey</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">reduce</span><span class="params">(value: <span class="keyword">inout</span> CGFloat?, nextValue: <span class="params">()</span></span></span> -&gt; <span class="type">CGFloat?</span>) &#123;</span><br><span class="line">    value = nextValue()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>간단하게 설명하자면 <code>reduce</code> 메소드는 <code>SizeKey</code>를 사용하는 하위 뷰들을 순회하면서 상위 뷰가 접근할 수 있는 값을 만들기 위해 이들의 값(<code>SizeKey</code>를 사용하는 하위 뷰의 값) 취합하는 역할을 한다.</p>
<blockquote>
<p>이번 포스팅에선 단순히  <code>PreferenceKey</code>의 기능만을 소개하지만 추후 포스팅에서 더욱 자세히 다룰 예정이다. 하지만 당장 궁금하다면 <a href="https://swiftui-lab.com/communicating-with-the-view-tree-part-1/">이 글</a>을 참고하면 좋을 것이다.</p>
</blockquote>
<p>그리고 간단한 트릭(?)을 사용해서 우린 뷰 계층 위로 <code>proxy</code> 정보를 전달할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> width: <span class="type">CGFloat?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">    .padding()</span><br><span class="line">    .fixedSize()</span><br><span class="line">    .background(</span><br><span class="line">      <span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">				<span class="type">Color</span>.clear.preference(key: <span class="type">SizeKey</span>.<span class="keyword">self</span>, value: proxy.size.width) <span class="comment">// --- 1</span></span><br><span class="line">			&#125;</span><br><span class="line">    )</span><br><span class="line">    .frame(width: <span class="keyword">self</span>.width, height: <span class="keyword">self</span>.width)</span><br><span class="line">    .background(</span><br><span class="line">      <span class="type">Circle</span>()</span><br><span class="line">      .fill(<span class="type">Color</span>.blue)</span><br><span class="line">    )</span><br><span class="line">    .onPreferenceChange(<span class="type">SizeKey</span>.<span class="keyword">self</span>) &#123; value <span class="keyword">in</span> <span class="comment">// --- 2</span></span><br><span class="line">			<span class="keyword">self</span>.width = value</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Color</code>도 <code>View</code> 프로토콜을 따른다. 그렇기 때문에 사용자는 볼 수 없는 <code>Color.clear</code>에 <code>preference</code>를 통해 <code>proxy.size.width</code>를 전달하고 있다. </li>
<li>상위 뷰(<code>Text</code>)에선 하위 뷰에서 전달한 정보를 <code>onPreferenceChange</code>를 통해 받을 수 있다. </li>
</ol>
<p>이제 진짜 우리가 원하던 레이아웃을 확인할 수 있을 것이다. </p>
<hr>
<h3 id="정리하며"><a href="#정리하며" class="headerlink" title="정리하며"></a>정리하며</h3><p>간단한 레이아웃(?)을 그려보면서 SwiftUI를 관통하는 여러 개념들을 자연스럽게 접해볼 수 있던 영상이었다. SwiftUI가 레이아웃을 그리는 알고리즘에 대해 이해하고 나니 왜 그렇게 그려지는지 이해가 가지 않았던 부분들이 어느정 도 머릿속에 정리가 되는 시간이었다.</p>
<blockquote>
<p>영상 말미에 한 가지 과제(?)를 주는데 이 부분은 <a href="https://github.com/ehdrjsdlzzzz/SwiftUI-practice/tree/master/SwiftUIUnderTheHood">github</a>에 올려놓았습니다.</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-08T11:16:48.000Z" title="2020-01-08T11:16:48.000Z">2020-01-08</time><span class="level-item"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></span><span class="level-item">6 minutes read (About 967 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/08/SwiftUI%EC%97%90%EC%84%9C-%EC%97%AC%EB%9F%AC-%ED%83%80%EC%9E%85%EC%9D%98-%EB%B7%B0-%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0/">SwiftUI에서 여러 타입의 뷰 반환하기</a></h1><div class="content"><p>지난 포스팅에서 불투명 타입(Opaque Type)에 대해 공부했었다. </p>
<blockquote>
<p>글 : <a href="https://ehdrjsdlzzzz.github.io/2019/12/12/Opaque-Types-in-Swift/">Opaque Types in Swift</a></p>
</blockquote>
<p>당시 우리는 불투명 타입을 반환할 땐 타입 정체성(Identity)를 잃지 않기 위해 한 가지 타입만 반환해야 한다고 공부했다. 하지만 개발을 하다 보면 여러 예외 상황을 마주하게 되는데 이는 불투명 타입도 마찬가지다. </p>
<p>먼저 SwiftUI로 프로젝트를 생성했을 때 마주하게 되는 기본 <code>ContentView</code> 코드를 살펴보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>body</code> 프로퍼티는 <code>some View</code> 타입이기 때문에 한 가지 타입만 반환할 수 있다. 그래서 뷰 계층을 작성할 때 우리는 아래와 같은 구조에 익숙하다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    ...<span class="type">View</span> &#123; </span><br><span class="line">    	...<span class="type">View</span> &#123; </span><br><span class="line">        ...<span class="type">View</span> &#123; </span><br><span class="line">          ...<span class="type">View</span> &#123; </span><br><span class="line">          </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>some View</code>를 반환해야 하기 때문에 위와 같은 구조의 코드에 익숙하다. 하지만 조건에 따라 다른 타입의 뷰를 보여주어야 한다면 어떻게 해야 할까?</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">  	<span class="keyword">if</span> isLogIn &#123; </span><br><span class="line">      <span class="type">Image</span>(<span class="string">"User-Avatar"</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="type">Text</span>(<span class="string">"Please Login"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 코드를 작성하면 우리는 <code>Function declares an opaque return type, but has no return statements in its body from which to infer an underlying type</code>와 같은 에러 메시지를 볼 수 있다. </p>
<p>하지만 언제나 방법은 있다! 게다가 두 가지씩이나! 그럼 그 두 가지를 살펴보자. </p>
<h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><p> <strong><code>Group</code>은 어떠한 레이아웃 특성도 지니지 않는다.</strong> <code>Group</code> 안에서는 위와 같이 조건 분기를 통한 두 가지 타입을 반환할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="type">Group</span> &#123; </span><br><span class="line">      <span class="keyword">if</span> isLogIn &#123; </span><br><span class="line">        <span class="type">Image</span>(<span class="string">"User-Avatar"</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Please Login"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>오늘의 주제와 별개로 <code>Group</code>의 사용 예를 한 가지 더 들어보자면 기본적으로 뷰 빌더 안에는 최대 10개 뷰만 들어갈 수 있다. 10개가 넘어가면 에러 메시지를 출력하는데, 이때 우리는 <code>Group</code>을 사용해 레이아웃을 해치지 않으면서 10개 이상의 뷰를 추가할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="type">VStack</span> &#123; </span><br><span class="line">      <span class="type">Group</span> &#123; </span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="type">Group</span> &#123; </span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      	<span class="type">Text</span>(<span class="string">"Text"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="AnyView"><a href="#AnyView" class="headerlink" title="AnyView"></a>AnyView</h3><p><code>Group</code> 말고도 우린 <code>AnyView</code>를 통해 두 가지 타입의 뷰를 반환할 수 있다. 정확하게는 타입을 지워(Type erase) 하나의 타입이 반환되는 것처럼 보이게 하는 것이다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> isLogIn &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="type">AnyView</span>(<span class="type">Image</span>(<span class="string">"User-Avatar"</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="type">AnyView</span>(<span class="type">Text</span>(<span class="string">"Please Login"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만 <code>AnyView</code>는 성능 비용이 높기 때문에 사용하는 것을 지양한다. <code>AnyView</code>의 공식 문서에는 다음과 같은 내용이 있다. </p>
<p><strong><em>Whenever the type of view used with an <code>AnyView</code> changes, the old hierarchy is destroyed and a new hierarchy is created for the new type</em></strong></p>
<blockquote>
<p><code>AnyView</code>와 함께 사용된 뷰가 변할 때마다 이전 뷰 계층을 파괴하고 새로 만들기 때문에 이 부분에서 성능 비용이 높다고 설명하는 것 같다. </p>
</blockquote>
<p>하지만 또 이 부분에 대해 <a href="https://medium.com/swlh/swiftui-performance-battle-anyview-vs-group-55bf852158df"><code>Group</code>과 성능 비교를 한 글</a>도 확인할 수 있었다. 이 비교 실험 글에 따르면 사실상 큰 차이는 없다고 나온다. 또한 이 글에선 <code>body</code>에서 뷰 상태의 바인딩을 최소한으로 하는 것이 성능 향상에 더 도움이 된다고 언급하고 있다. </p>
<blockquote>
<p>상태에 의존하는 뷰가 많을수록 rebuild 횟수가 증가할 가능성이 크기 때문에 이렇게 말하고 있는 것으로 생각된다.</p>
</blockquote>
<hr>
<p>오늘은 SwiftUI에서 여러 타입의 뷰를 반환하는 두 가지 방법에 대해 알아보았다. </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-03T12:27:18.000Z" title="2020-01-03T12:27:18.000Z">2020-01-03</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">9 minutes read (About 1323 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/03/Property-Wrappers-in-Swift/">Property Wrappers in Swift</a></h1><div class="content"><p>Property wrapper는 프로퍼티를 정의하는 코드(<em>code that defines a property</em>)와 프로퍼티가 어떻게 저장되는지를 관리하는 코드(<em>code that manages how a property is stored</em>) 사이의 계층(<em>layer</em>)이다.</p>
<p><img src="/2020/01/03/Property-Wrappers-in-Swift/property_wrapper.png" alt=""></p>
<p>Property wrapper를 사용하면 정의할 때 관리 코드(management code)를 한 번만 작성하고 여러 프로퍼티에 <strong>재사용</strong>할 수 있다. 사실 이런 wrapper 개념은 이번에 갑자기 나타난 것이 아니다. <code>lazy</code>나 <code>@NSCopying</code> 같은 키워드도 wrapper의 한 종류다. 하지만 Swift 5.1에선 개발자가 이런 wrapper를 직접 만들 수 있게 되었다.</p>
<p>Property wrapper를 이해하기 위해선 Property wrapper가 어떤 문제를 해결할 수 있는지를 보면 된다. 객체 안의 프로퍼티에 값이 할당될 때마다 로그를 출력해주어야 한다고 가정해보자. 우린 다음과 같이 코드를 작성할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; _x &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      _x = newValue</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"New value is \(newValue)"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="type">Bar</span>()</span><br><span class="line">bar.x = <span class="number">1</span> <span class="comment">// Prints 'New value is 1'</span></span><br></pre></td></tr></table></figure>

<p>가장 직관적인 방법이다. 하지만 객체 안에 <code>x</code>뿐만 아니라 수많은 프로퍼티가 존재하고 이런 프로퍼티 모두가 값이 할당될 때마다 로그를 출력해주어야 한다면 상황은 달라진다. </p>
<p>이런 상황을 해결하기 위해 우린 새로운 타입을 정의해줄 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = wrappedValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; </span><br><span class="line">      value = newValue</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"New value is \(newValue)"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 기존의 <code>Bar</code> 구조체를 아래와 같이 <code>ConsoleLogged</code> 타입을 사용해 바꿀 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _x = <span class="type">ConsoleLogged</span>&lt;<span class="type">Int</span>&gt;(wrappedValue: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; _x.wrappedValue &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; _x.wrappedValue = newValue &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="type">Bar</span>()</span><br><span class="line">bar.x = <span class="number">1</span> <span class="comment">// Prints 'New value is 1'</span></span><br></pre></td></tr></table></figure>

<p>이렇게 <code>ConsoleLogged</code> 타입을 사용해 중복 코드를 줄일 수 있다. Swift 5.1에선 이런 패턴을 Property wrapper라는 <em>Syntatic Sugar</em>로 제공한다. 사용 방법은 매우 간단하다. 기존의 <code>ConsoleLogged</code>에 <code>@propertyWrapper</code>만 붙이면 된다. <code>@propertyWrapper</code>를 타입(<code>struct</code>, <code>class</code>, <code>enum</code>) 앞에 붙이고 <code>wrappedValue</code>만 정의해주면 된다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = wrappedValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; </span><br><span class="line">      value = newValue</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"New value is \(newValue)"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>프로퍼티가 어떻게 저장되는지를 관리하는 코드(<em>code that manages how a property is stored</em>) </p>
</blockquote>
<p>이렇게 선언한 Property wrapper는 사용하기도 쉽다. 아래와 같이 두 가지 방법으로 Property wrapper를 사용할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123; </span><br><span class="line">  @<span class="type">ConsoleLogged</span> <span class="keyword">var</span> x = <span class="number">0</span> <span class="comment">// 1</span></span><br><span class="line">  @<span class="type">ConsoleLogged</span>(wrappedValue: <span class="number">2</span>) <span class="keyword">var</span> y <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>프로퍼티를 정의하는 코드(<em>code that defines a property</em>)</p>
</blockquote>
<p>Property wrapper 안에는 <code>wrappedValue</code>와 같이 프로퍼티뿐만 아니라 메소드도 정의할 수 있다. 하지만 안에 정의된 메소드를 사용할 땐 스코프(<em>scope</em>)에 주의할 필요가 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Foo"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 Property wrapper안에 <code>foo</code>라는 메소드를 정의했다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HasWrapper</span> </span>&#123;</span><br><span class="line">    @<span class="type">Wrapper</span> <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; _x.foo() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그럼 당연히 <code>Wrapper</code>를 Property wrapper로 사용하는 객체 내부에선 <code>foo</code> 메소드를 사용할 수 있다. (<code>_x.foo()</code>)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">HasWrapper</span>()</span><br><span class="line">a._x.foo() <span class="comment">// ❌ '_x' is inaccessible due to 'private' protection level</span></span><br></pre></td></tr></table></figure>

<p>하지만 위와 같이 외부에서의 접근은 불가능하다. 이유는 <code>private</code> 수준의 접근 제어를 갖기 때문이다. 물론 외부에서 접근할 수 있는 방법은 존재한다. <code>projectedValue</code>를 사용하면 된다. </p>
<p>우리는 <code>projectedValue</code>를 통해 부수적인 API를 외부에 노출시킬 수 있다. <code>wrappedValue</code>와 다르게 <code>projectedValue</code>는 타입의 제한이 없다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> projectedValue: <span class="type">Wrapper</span>&lt;<span class="type">T</span>&gt; &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Foo"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 우리는 <code>projectedValue</code>를 <code>x</code>에 <code>$</code>을 붙여 접근할 수 있다.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">HasWrapper</span>()</span><br><span class="line">a.$x.foo() <span class="comment">// Prints 'Foo'</span></span><br></pre></td></tr></table></figure>

<p>SwiftUI엔 <code>@State</code>, <code>@Binding</code>과 같은 빌트인 Property wrapper가 존재한다. 이에 대해선 추후 다루게 될 SwiftUI 포스팅에서 하나씩 살펴보도록 하자. </p>
<p>이번 포스팅에선 간단한 예로 <code>UserDefaults</code>를 Property wrapper를 통해 보다 간편하게 사용할 수 있는 예제를 살펴보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserDefault</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> key: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> initialValue: <span class="type">T</span></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123; <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: key) &#125;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="type">UserDefaults</span>.standard.object(forKey: key) <span class="keyword">as</span>? <span class="type">T</span> ?? initialValue &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>먼저 <code>UserDefault</code>라는 Property wrapper를 위와 같이 정의했다. <code>initialValue</code>를 통해 값이 존재하지 않을 때 초기값을 제공할 수 있다. 그리고 아래와 같이 사용할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">  @<span class="type">UserDefault</span>(key: <span class="string">"isCheatModeEnabled"</span>, initialValue: <span class="literal">false</span>) <span class="keyword">static</span> <span class="keyword">var</span> isCheatModeEnabled: <span class="type">Bool</span></span><br><span class="line">  @<span class="type">UserDefault</span>(key: <span class="string">"highestScore"</span>, initialValue: <span class="number">10000</span>) <span class="keyword">static</span> <span class="keyword">var</span> highestScore: <span class="type">Int</span></span><br><span class="line">  @<span class="type">UserDefault</span>(key: <span class="string">"nickname"</span>, initialValue: <span class="string">"cloudstrife97"</span>) <span class="keyword">static</span> <span class="keyword">var</span> nickname: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">UserPreferences</span>.isCheatModeEnabled = <span class="literal">true</span></span><br><span class="line"><span class="type">UserPreferences</span>.highestScore = <span class="number">25000</span></span><br><span class="line"><span class="type">UserPreferences</span>.nickname = <span class="string">"squallleonhart"</span></span><br></pre></td></tr></table></figure>

<p>물론 Property wrapper로 선언된 프로퍼티에도 한계가 존재한다. </p>
<ul>
<li>하위 클래스에서 오버라이딩될 수 없다. </li>
<li><code>lazy</code>, <code>weak</code>, <code>@NSCopying</code>과 같이 사용할 수 없다. </li>
<li>커스텀 <code>set</code>, <code>get</code>을 사용할 수 없다.</li>
<li>프로토콜이나 익스텐션에서 선언될 수 없다. </li>
</ul>
<p>오늘은 Swift 5.1에 새로 추가된 Property wrapper에 대해 매우 간단히 알아보았다. 이후에는 SwiftUI에서 사용되고 있는 Property wrapper들에 대해서 소개해보려 한다. </p>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://devsday.ru/blog/details/3752">The Complete Guide to Property Wrappers in Swift5</a></li>
<li><a href="https://medium.com/swlh/understanding-property-wrappers-in-swift-by-examples-604206022b5c">Understanding Property Wrappers in Swift By Examples</a></li>
<li><a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html">Swift Docs</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-26T12:10:52.000Z" title="2019-12-26T12:10:52.000Z">2019-12-26</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></span><span class="level-item">19 minutes read (About 2789 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/26/SwiftUI-Essentials-2/">SwiftUI Essentials (2)</a></h1><div class="content"><h2 id="Building-custom-views"><a href="#Building-custom-views" class="headerlink" title="Building custom views"></a>Building custom views</h2><p>SwiftUI로 커스텀 뷰를 만드는 방식에 대해 이야기 해보자. </p>
<p>주문 내역을 보여주는 <code>OrderHistory</code>를 살펴보자.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/1.png" alt=""></p>
<p>위의 코드에서 먼저 살펴볼 부분은 바로 <code>View</code> 프로토콜을 따르고 있는 <code>OrderHistory</code>가 구조체로 선언되어 있다는 점이다.</p>
<p>일반적으로 UIKit으로 뷰를 만들면 프로토콜을 따르는 구조체가 아닌 공통 부모 클래스로부터 상속받는 클래스를 작성하곤 한다. <code>OrderHistory</code>를 UIKit으로 만든다면 다음과 같은 상속 관계를 가질 것이다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/2.png" alt=""></p>
<p><code>UIView</code>는 <code>alpha</code>나 <code>backgroundColor</code> 같은 공통된 저장 프로퍼티(stored property)를 갖고 있다. <code>OrderHistory</code>는 자신의 <code>previousOrders</code> 프로퍼티와 더불어 부모 클래스의 프로퍼티까지 갖고 있게 된다. 반면에 SwiftUI는 어떨까? </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/3.png" alt=""></p>
<p>SwiftUI는 이런 공통된 저장 프로퍼티를 분리된 변경자로 관리하고 각각의 변경자는 자신들만의 뷰를 생성하게 된다. 그러므로 공통된 저장 프로퍼티는 뷰 계층 전반에 걸쳐 분산된다. 이러한 방식으로 뷰를 더 가볍게 해서 각 뷰의 고유 목적에 맞게 최적화한다.</p>
<p>이러한 방식 때문에 SwiftUI에서 뷰가 프로토콜이 된다고 할 수 있는 것이다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/4.png" alt=""></p>
<p>그럼 뷰는 무엇을 하는 것일까?</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/5.png" alt=""></p>
<p>뷰는 단지 UI의 한 조각을 정의할 뿐이고 우린 이런 뷰들을 이용하고 재사용하여 뷰 계층을 구성하는 것이다. <code>View</code> 프로토콜의 살펴보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/6.png" alt=""></p>
<p>위의 코드를 보고 있으면 어떤 생각이 드는가? 재귀적이지 않은가? </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/7.png" alt=""></p>
<p>하나의 뷰가 있고 그 뷰의 <code>body</code>가 다른 뷰를 나타내고 그 뷰의 <code>body</code>가 또 다른 뷰를 나타내는 이런 구조를 보일 수 있다고 생각할 수 있는데 이는 지속되지 않는다. 그 이유는 SwiftUI가 스스로 컨텐츠를 갖지 않고 다른 뷰를 구성하는 아토믹(atomic)한 뷰인 원시 뷰(primitive view)를 제공하고 위와 같은 <code>body</code> 사슬의 끝은 결국 이런 원시 뷰이기 때문이다.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/8.png" alt=""></p>
<p>우리가 위에서 보았던 <code>Text</code>나 <code>Image</code>와 더불어 드로잉에 사용되는 <code>Color</code>와 <code>Shape</code>, 레이아웃에 사용되는 <code>Spacer</code>와 같은 다양한 원시 뷰를 제공한다. </p>
<p>다시 <code>OrderHistory</code>로 돌아와 클래스가 아닌 구조체로 정의된 것에 주목해보자. 클래스로 정의한 것이 아니기 때문에 <code>OrderHistory</code>는 더 이상 이벤트 기반으로 동작하는 명령형 코드로 갱신되는 영구적인 객체가 아니다.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/9.png" alt=""></p>
<p>대신 뷰는 Input에 따라 결과가 달라지는 함수와 같이 선언형 코드로 정의된다. 이 말은 Input이 변경되면 SwiftUI가 <code>body</code> 프로퍼티를 다시 호출해서 뷰를 갱신한다.</p>
<p>만일 이벤트 기반의 명령형 코드였다면 Input의 변경(삭제, 삽입 등)에 따른 갱신 코드를 작성해주어야 했는데, SwiftUI에서는 선언형 코드로 인풋이 변경되면 SwiftUI가 내부적으로 이전 데이터와 새 데이터를 비교해서 무엇이 변경되었는지를 비교 후 효율적으로 뷰를 갱신하게 된다.</p>
<p><code>OrderHistory</code> 코드를 계속해서 살펴보자. 조건에 따라 뷰의 유무를 표시할 때 우리는 다음과 같이 뷰 빌더 클로저 안에 조건문을 통해 이를 구현할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/10.png" alt=""></p>
<p>하지만 이런 조건문도 상황에 따라 제대로 사용해야 한다. 다음 상황의 코드를 살펴보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/11.png" alt=""></p>
<p><code>flipped</code> 값에 따라 아이콘의 각도를 다르게 보여주고 싶을 때 위와 같이 작성할 수 있다. 하지만 이는 잘못된 방법이다. 이런 코드는 부자연스러운 애니메이션을 만들게 된다. 이 코드는 SwiftUI에게 서로 다른 뷰 중 하나를 선택하게 하는 것이고 이는 곧 뷰의 추가와 삭제를 의미한다. 뷰의 추가와 삭제는 fade 애니메이션이 적용되기에 부자연스러운 애니메이션을 보게 되는 것이다. </p>
<p>우리가 원하는 자연스러운 애니메이션을 위해선 다음과 같이 코드를 작성해야 한다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/12.png" alt=""></p>
<p>여기서 얻을 수 있는 교훈은 이런 조건에 따라 다른 값에 의한 뷰의 변화를 부드러운 애니메이션을 통해 제공하기 위해선 최대한 이를 변경자 내부에 위치시켜 SwiftUI가 변화를 감지하여 보다 부드러운 애니메이션을 제공하도록 해야 한다는 것이다.</p>
<p>또한 비대해진 <code>OrderHistory</code>를 우린 더 작은 뷰로 나누어 관리할 수도 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/13.png" alt=""></p>
<p>만일 <code>OrderHistory</code>에 조건에 따라 또 다른 뷰가 추가되어야 한다면 코드를 어떻게 작성해야할까</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/14.png" alt=""></p>
<p>위와 같은 방법은 확장성이 매우 떨어진다. 우리는 이런 상황에서 <code>ForEach</code> 뷰를 사용할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/15.png" alt=""></p>
<p><code>ForEach</code>는 하나의 뷰로 <code>List</code>와 마찬가지로 콜렉션 데이터 타입을 인자로 받는다. 그리고 뷰 빌더 클로저 안에 뷰를 나열하는데 이때 나열된 뷰는 <code>ForEach</code>에 추가되지 않고 <code>ForEach</code>의 상위 뷰에 추가된다.</p>
<p>지금까지 작성된 코드들을 보면 우리가 직접 작성하지 않고도 SwiftUI가 스스로 그리고 반응하며 갱신하는 것을 확인할 수 있었다. 이것이 바로 선언형 코드의 장점이라 할 수 있다.</p>
<h2 id="Composing-Controls"><a href="#Composing-Controls" class="headerlink" title="Composing Controls"></a>Composing Controls</h2><p>아보카도 토스트 주문을 넣는 화면을 다시 살펴보자. 이는 우리가 알고 있는 화면과 많이 다르다. 정확히 말하자면 정형화되지 않은 상태다. 이 뷰를 아래와 같이 우리가 익숙한 형태의 뷰로 변경해보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/16.png" alt=""></p>
<p>둘의 가장 큰 차이점은 컨테이너가 다르다는 것이다. </p>
<p>기존 뷰(왼쪽)의 컨테이너가 <code>VStack</code>이라면 우리가 익숙한 오른쪽 뷰의 컨테이너는 <code>Form</code>이다. <code>Form</code> 역시 뷰 컨테이너의 한 종류다. <code>VStack</code>과의 차이점에는 헤더, 섹션 등이 있어 보다 정형화된 그룹 스타일의 UI를 보다 쉽게 만들 수 있다.</p>
<p>그리고 이렇게 컨테이너가 바뀜에 따라 그 안에 속하는 컨트롤(버튼, 토글 등)도 그 모습이나 속성이 컨테이너에 따라 변한다. 또한 <code>Form</code>을 사용하면 서로 다른 플랫폼에서 다양한 룩앤필(Look and Feel)을 제공할 수 있다. 이렇게 SwiftUI가 UI를 그리기 때문에 우리는 기능에 보다 집중할 수 있다.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/17.png" alt=""></p>
<p>위의 화면에서 <code>Button</code>을 예로 들면 뷰 컨테이너가 바뀌면서 <code>Button</code>의 <code>padding</code>, <code>alignment</code> 등이 바뀐 것을 확인할 수 있다. </p>
<p>이번엔 <code>Button</code> 코드를 살펴보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/18.png" alt=""></p>
<p>위의 단일 코드로 여러 플랫폼에서 다양한 룩앤필을 제공할 수 있다. </p>
<p><code>Button</code>은 눌렸을 때 액션을 인자로 넣어주고 버튼의 상태와 목적을 나타내는 <code>label</code>을 뷰 빌더 클로저를 통해 제공해줄 수 있다. 그리고 앞에서 봐왔듯이 여러 변경자들을 통해 보다 쉽게 커스터마이징을 할 수 있다. 이를 통해 우리는 다양한 플랫폼의 다양한 버튼을 사용자에게 제공해줄 수 있다.</p>
<p>그렇기 때문에 SwiftUI에서 컨트롤은 적응형(adaptive) 컨트롤이라 할 수 있다. 적응형 컨트롤은 다음과 같은 특성을 갖는다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/19.png" alt=""></p>
<p>컨트롤은 그 자체로 모양이 아닌 역할을 나타낸다. 이렇게 컨트롤이 역할을 의미하기 때문에 여러 플랫폼에 거쳐 재사용될 수 있는 것이다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/20.png" alt=""></p>
<p>이렇게 컨트롤들은 역할이 있고 이런 역할은 목적에 의해 생겨나기 때문에 <code>Toggle</code>이나 <code>Button</code>들은 그들 각자의 목적이 존재한다. 그리고 이들은 사람이 읽을 수 있는 레이블을 포함하기 때문에 기본적으로 VoiceOver 기능을 지원한다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/21.png" alt=""></p>
<p>그리고 레이블이 <code>Text</code>가 아니라 <code>Image</code>어도 <code>Image</code>에 설명을 위한 <code>Text</code>를 함께 제공하여 VoiceOver 기능을 제공할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/22.png" alt=""></p>
<p>또한 커스텀 뷰는 <code>accessbility</code> 변경자를 통해 이런 기능을 제공할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/23.png" alt=""></p>
<p>이렇게 컨트롤은 플랫폼에 따라 모양은 다를 수 있지만 본연의 목적을 수행하는 데 이는 SwiftUI의 핵심이라고 할 수 있다. SwiftUI는 한 번만 작성하고 어디에서나 실행할 수 있는 수단 일뿐만 아니라 이러한 핵심 개념을 배우고 다양한 컨텍스트와 플랫폼에서 사용할 수 있는 프레임 워크다.</p>
<p>그리고 우리가 뷰에서처럼 컨트롤에서도 변경자를 사용할 수 있다. 그리고 이는 뷰에서와 동일한 특성을 갖는다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/24.png" alt=""></p>
<p>예를 들어 다음과 같이 컨트롤 계층 전반에 걸쳐 변경자를 공유할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/25.png" alt=""></p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/26.png" alt=""></p>
<p>다음으로 살펴볼 것은 환경(Environment)이다. 이는 일종의 모든 뷰에서 접근할 수 있는 특성의 집합으로 볼 수 있다. 그리고 자식 뷰는 부모 뷰의 환경 특성을 상속 받는다. 물론 필요에 따라 자식 뷰에서 이를 오버라이딩할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/27.png" alt=""></p>
<p>그리고 이 환경은 프리뷰에서 유용하게 사용되는데, 동일한 UI를 여러 문맥에 따라 다르게 보여주는 기능을 제공한다. 이를 통해 환경, 문맥에 따라 UI가 어떻게 바뀌는지 쉽게 확인할 수 있다. </p>
<h2 id="Navigating-your-app"><a href="#Navigating-your-app" class="headerlink" title="Navigating your app"></a>Navigating your app</h2><p>iOS에선 기본적으로 <code>NavigationView</code>를 통해 기본 내비게이션 스타일을 사용할 수 있으며 <code>navigationBarTitle</code> 변경자를 통해 타이틀을 지정할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/28.png" alt=""></p>
<p><code>navigationBarTitle</code>은 다른 변경자와 같이 아래를 향하지 않고 위를 향하는 특성을 갖는다. <code>OrderForm</code>에 변경자를 적용했지만, <code>NavigationView</code>에 반영된다는 것을 의미한다. </p>
<p>그리고 <code>NavigationButton</code>를 목적지와 함께 만들어 실질적인 화면 전환을 구현할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/30.png" alt=""></p>
<p><code>TabbedView</code>를 통해 성격이 다른 두 뷰를 탭 뷰로 묶어 관리할 수도 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/31.png" alt=""></p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Corn"></figure><p class="title is-size-4 is-block line-height-inherit">Corn</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">32</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/protocorn93" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/RxSwift/"><span class="level-start"><span class="level-item">RxSwift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/"><span class="level-start"><span class="level-item">WWDC</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/WWDC/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/WWDC/SwiftUI/WidgetKit/"><span class="level-start"><span class="level-item">WidgetKit</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-10-07T12:34:21.000Z">2020-10-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/">Add configuration and intelligence to your widgets</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a> / <a class="link-muted" href="/categories/WWDC/SwiftUI/WidgetKit/">WidgetKit</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-20T05:29:20.000Z">2020-09-20</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/">Stacks, Grids, and Outlines in SwiftUI</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-20T03:04:00.000Z">2020-09-20</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/20/Meet-WidgetKit/">Meet WidgetKit</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-23T07:22:27.000Z">2020-08-23</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/23/Embrace-Swift-type-inference/">Embrace Swift type inference</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/Swift/">Swift</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-26T08:37:48.000Z">2020-07-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/26/GeometryReader-in-SwiftUI/">GeometryReader in SwiftUI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/10/"><span class="level-start"><span class="level-item">October 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">September 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/03/"><span class="level-start"><span class="level-item">March 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Binding/"><span class="tag">@Binding</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/State/"><span class="tag">@State</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ABI-Stability/"><span class="tag">ABI Stability</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AnyView/"><span class="tag">AnyView</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App/"><span class="tag">App</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Thinning/"><span class="tag">App Thinning</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bitcode/"><span class="tag">Bitcode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Custom-URL-Scheme/"><span class="tag">Custom URL Scheme</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GeometryReader/"><span class="tag">GeometryReader</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Group/"><span class="tag">Group</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Intent/"><span class="tag">Intent</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Opaque-Type/"><span class="tag">Opaque Type</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OptionSet/"><span class="tag">OptionSet</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PreferenceKey/"><span class="tag">PreferenceKey</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Property-Wrappers/"><span class="tag">Property Wrappers</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxSwift/"><span class="tag">RxSwift</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scene/"><span class="tag">Scene</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift5/"><span class="tag">Swift5</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SwiftUI/"><span class="tag">SwiftUI</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Universal-Links/"><span class="tag">Universal Links</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/View/"><span class="tag">View</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC/"><span class="tag">WWDC</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC19/"><span class="tag">WWDC19</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Widget-Configuration/"><span class="tag">Widget Configuration</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WidgetKit/"><span class="tag">WidgetKit</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WindowGroup/"><span class="tag">WindowGroup</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/enum/"><span class="tag">enum</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS-13/"><span class="tag">iOS 13</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/some/"><span class="tag">some</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%9D%B4%EC%A7%81/"><span class="tag">이직</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Corn the blog" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>