{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"이직기 (feat. 근황)","text":"근황 👣이직을 하게 되었고 퇴사를 했다. 10월 중순에 퇴사를 하고 새 회사로 출근하는 것으로 정해졌지만 전 회사 사정으로 의도치 않게 9월까지 마무리하는 것으로 결정나서 애매하게 시간이 떠버리게 되었다. 그래서 나만의 시간, 가족과의 시간을 보내게 되었다. 10월 첫째 주는 제주도로 혼자 여행을 떠났고, 10월 둘째 주는 가족과 예정되어 있던 코타키나발루로 떠나게 되었다. 그리고 출근 마지막 주인 10월 셋째 주는 학교도 방문하고, 다시 출근을 하면 만나기 힘들 것 같은 지인들도 만나려 한다. 그리고 틈틈이 평소에 읽고 싶었던 문서나 책을 읽으며 시간을 보내고 있다. (효율적으로 시간을 보내고 있는 것 같지는 않다.😅) 나만의 시간을 보내게 되어 나태해졌는지 블로그에 소홀해졌다. 그래서 이렇게 근황과 이직기를 시작으로 다시금 글을 써보려 한다. 이직기 🏢 ➡️ 🏬이직을 결심하게 된 이유 군대와 동아리 등 여러 단체 생활을 하면서 느낀 점은 누구와 함께 하는지가 가장 중요하다는 것이었다. 이는 직장 생활에서도 동일하게 작용한다고 생각한다. 어쩌면 직장 생활에서 가장 중요한 부분 중 하나라고 생각한다. 다행히 전 직장을 포함해서 난 사람 운은 정말 좋았다고 생각한다. 팀원들과 의사소통을 하면서 내가 부족한 점이 무엇인지를 많이 깨닫게 되었고 또한 팀원들을 보면서 스스로 어떻게 개선해야 할지도 깨닫게 되었다. 기술적인 토론도 심심치 않게 나누어 팀원들의 훌륭한 지식도 여러 방면으로 습득하게 되었다. 위의 내용을 한 줄로 요약하자면 사람 때문에 이직하게 된 것은 아니다. 오히려 사람 때문에 아쉬움이 컸다. 내가 이직을 하게 된 계기는 서비스에 있다. 결정적인 이유는 서비스와 내가 맞지 않았다고 생각한다. 나는 퇴근을 하고선 이슈가 터지지 않는 이상 회사 앱을 켜본 기억이 드물다. 내가 만들고 있는 앱이지만 내가 사용하지 않았단 이야기다. 개인적으로 나는 내가 잘 사용할 수 있는 서비스를, 내가 필요한 서비스를 만들 때 스스로 더 재미를 느끼고 개발을 하는 것 같다. 물론 평생 나와 맞는 것, 내가 재미를 느끼는 것만 개발할 수 있다고는 생각하지 않는다. 하지만 적어도 주니어 개발자에겐 재미를 느끼고 개발한다는 동기부여가 필요하다고 생각한다. 이런 나의 가치관과 전 회사의 서비스는 맞지 않았다. 또한 전 회사의 서비스는 비교적 보편적인 서비스는 아니었다고 생각한다. 현재는 특수한 목적을 갖고 서비스를 사용하는 사용자가 대다수였다. 개인적으로 나는 사람들의 일상에 녹아있는 보편적인 서비스를 개발하고 싶은 마음이 컸다. 위의 내용을 토대로 다음 회사는 다음의 세 가지를 충족하길 원했다. 커뮤니케이션이 활발한 조직 내가 자주 사용할 수 있는 서비스 보편적인 서비스 물론 주변의 많은 사람들이 *”적어도 2년, 아니 1년이라도 채우고 움직여라”라는 조언을 많이 해주었다. 내가 생각해도 그 조언은 틀리지 않았고 나 같아도 주변에 그렇게 조언을 해줄 것 같다. 하지만 내가 1년도 채우지 않고 이직을 하기로 결정하게 된 계기는 나에겐 *”1년도 채우지 않고 이직했다”라는 꼬리표를 감수할 수 있을 만큼 위에 나열된 부분에 대한 욕망이 더욱 컸기 때문이라고 생각한다. 어쩌면 나는 평생 다른 사람들에게 이러한 이유들을 수없이 “해명”해야 할 수도 있다. 하지만 그런 점을 감수하고도 보다 빨리 내 개발 가치관과 맞는 회사를 찾는 것이 중요하다고 판단한 것이다. 내가 문을 두드렸던 기업 리스트 많은 기업에 지원한 것은 아니지만 그 나름대로 의미가 있을 것이라고 생각하여 이렇게 기록을 해본다. 순서는 무관하며 기업명은 밝히지 않도록 하겠습니다. 기업을 설명하는 코멘트는 개인적인 주관이 포함되어 있을 수 있습니다. 국내 OTT 서비스 중 가장 영향력이 높다고 생각하는 W사 지원 경로 : 프로그래머스 2019 앱 개발자 온라인 잡 페어 채용 프로세스 : W사는 기업 개별 전형에선 과제 전형을 진행 결과 : 과제 전형에서 탈락 개인적으로 네이버 핵데이를 통해서 잠깐 경험했던 미디어 프로그래밍에 대해 관심도 있었고, 서비스 자체도 애용했던 서비스라 지원을 하게 되었다. 과제 전형을 진행하게 되었고, 과제 전형에선 어떤 라이브러리를 사용해도 무관하다고 안내받았다. 48시간이라는 시간 내에 주어진 과제를 제출해야 했다. 처음엔 48시간이 충분하다고 생각했으나 일과 병행하려니 시간은 생각보다 많이 촉박했다. 기능 구현에 대한 고민과 더불어 프로그램 구조에 대한 고민을 함께 하려니 나에겐 턱없이 부족한 시간이었다. 어찌어찌 제출은 하였으나 내가 생각해도 완성도가 높진 않았다고 생각했고, 결과는 내가 예상한 것에서 벗어나지 않았다. 채용 과정에서 좋았던 점 : 과제에 대한 결과와 더불어 과제에 대한 피드백이 주어졌다는 점에서 무엇이 부족했는지 납득할 수 있었고 내 코드를 되돌아볼 수 있는 계기가 되었다. 채용 과정에서 아쉬웠던 점 : 과제 안내 메일에서 자사 서비스 UI를 참고하여 개발하되 동일할 필요는 없다고 언급하였으나 피드백에선 “UI 구현에서 자사 서비스 앱과 비슷하게 구현하셨으면 했습니다.“라는 피드백을 받아 이 피드백에 대해선 조금은 납득하기 어려웠다. 하지만 과제를 내는 기업 입장에선 자사 서비스와 유사하게 구현되어 있으면 당연히 좋은 인상을 받을 수 있다는 것은 부인하기 힘든 사실인 것 같다. 동네 기반 중고 직거래 플랫폼 서비스 D사 지원 경로 : W사와 동일 채용 프로세스 : W사와 동일 D사는 기업 개별 전형에서 전화 면접을 진행 결과 : 최종 면접에서 탈락 서비스를 사용하면서 굉장히 만족도가 높았던 서비스였고, 기타 다른 중고 거래 플랫폼들에 비해 신뢰도가 상당히 높았던 서비스였다. 또한 슈퍼 개발자분들이 모여 계신 기업으로 iOS 개발자분도 유명하신 분이시라 더욱 함께하고 싶은 마음이 컸다. 전화 면접에서는 iOS 전반에 걸친 질문들을 해주셨고, 간단한 CS에 관한 질문도 해주셨다. 전화 면접을 통과하고 최종 면접을 진행했고, 합류하고 싶었던 마음이 컸던지 다른 기업 면접과는 비교가 안될 정도로 크게 긴장하였다. 그로 인해 알고 있던 내용들도 제대로 답하지 못했다. 또한 끝나고 들었던 생각이지만 너무 내 의견만을 고집했던 경향이 없지 않아 있었던 것 같다. 하지만 덕분에 보다 사고적으로 열릴 수 있었던 계기였다. 채용 과정에서 좋았던 점 : 확실히 유연한 분위기 속에서 면접이 진행되었고, 면접관으로 들어오신 분들 모두가 지원자를 배려하려는 마음이 느껴져서 좋았다. 또한 면접비도 제공이 되었다.🤑 시간이 어느 정도 흐르고 한 개발자 컨퍼런스에서 면접관으로 들어오셨던 분이 나를 알아보시고 말씀을 걸어주셔서 굉장히 감사하게 생각했다. 한국의 글로벌 키즈 컨텐츠 기업 S사 지원 경로 : 지인의 추천 채용 프로세스 : 서류 전형 ➡️ 1차 실무진 면접 ➡️ 2차 CEO 및 인사팀 면접 (최종 면접) 결과 : 최종 합격 이 회사는 D사 최종 면접을 보러 갔던 날 마주쳤던 지인의 추천으로 지원하게 된 기업이다. 이 기업은 미국에 거주하는 어린 조카들을 통해 먼저 알게 되었고, 국내 기업이라는 점에서 적지 않게 놀랐던 기억이 난다. 글로벌 컨텐츠로는 국내에서 높은 지위를 갖고 있는 기업이라고 생각이 든다. 서류 전형을 거쳐 진행한 1차 실무진 면접의 난이도는 꽤나 높았던 것으로 기억한다. 부족한 CS 지식에 대해 깊이 파고드는 질문들이 이어졌고 만족스러운 답변을 하지 못했던 것 같다. 또한 iOS에 관한 질문에서도 평소에는 그냥 넘어갔을 부분에 대해 질문이 들어와 적지 않게 당황했던 기억이 난다. 1차 면접을 그리 잘 보지 않았던 터라 기대는 하지 않았으나 1차 면접에 합격하여 최종 면접에 임했고 최종 면접답게 조금은 추상적인 질문들을 주고받으며 면접을 진행했다. 그리고 얼마 뒤 최종 합격 통보를 받았다. 채용 과정에서 좋았던 점 : 모든 채용 프로세스가 신속하게 진행되었다. 역시 면접관으로 들어오셨던 분들의 배려로 편안한 분위기 속에서 면접을 진행할 수 있었다. 일상에서 누구나 누릴 수 있는 금융의 이로운 흐름을 만드는 K사 지원 경로 : 헤드헌팅 채용 프로세스 : 서류 전형 ➡️ 과제 전형 ➡️ 1차 실무진 면접 ➡️ 2차 CTO 및 인사팀 면접 (최종 면접) 결과 : 최종 합격 헤드헌터를 통한 대규모 채용을 진행하고 있던 기업이었고, 나 역시 헤드헌터로부터 채용 관련 연락을 받았다. 내가 일상에서 상당히 애용하고 있는 간편 결제 서비스를 제공하는 기업으로 앱 역시 상당히 잘 만들어져 있다는 인상을 받고 있던 터라 주저 없이 지원을 하게 되었다. 서류 전형 이후 주어진 과제는 재직자를 감안하여 2주라는 넉넉한 시간이 주어졌고, 덕분에 기능 외적으로 구조적인 부분에 대해 많은 고민을 할 수 있었다. 과제를 완성하고 관련 도큐먼트를 작성하는데도 적지 않은 노력을 기울였다. 과제 전형 합격 이후 1차 면접에선 주어진 시간 중 90%는 과제 리뷰로 진행되었다. 내가 작성한 코드에 대해 면접관분들과 많은 의견을 나누었고, 이러한 과정 속에서 내가 생각한 의도를 충분히 전달할 수 있었다. 1차 면접 과정은 굉장히 즐거운 시간으로 기억된다. 의견을 나누는 과정에서 무엇이 서툴렀고, 무엇을 잘못 생각했는지 깨달을 수 있던 시간이었다. 그리고 1차 면접을 보고 돌아오는 길에 합격 통보를 받았고 2차 면접 일정을 잡았다. 금요일에 진행된 2차 면접은 CTO님과 두 분의 인사담당분들이 함께 했다. 1차 면접과는 사뭇 분위기가 달랐고 조금 더 경직된 분위기에서 면접은 진행되었다. 그리고 1시간 30분 넘게 진행되었던 1차 면접과는 다르게 40분 만에 면접이 끝났다. 이로 인한 불안감은 있었지만 월요일에 최종 합격 통보를 받을 수 있었다. 채용 과정에서 좋았던 점 : 모든 채용 프로세스가 신속하게 진행되었다. 1차 실무진 면접은 면접이라는 상황을 떠나 굉장히 즐거운 경험으로 기억된다. 과제 전형 역시 프로그램 전반적으로 많은 고민을 해볼 수 있는 경험이었다. 채용 프로세스를 진행하면서 이렇게 간절함이 컸던 회사는 처음이었다. 결과적으로 내가 일상에서 상당히 자주 애용하는 서비스를 운영하는 K사를 선택하였다. 그리고 끝이 아닌 새로운 시작이라고 생각하며 해당 서비스에 기여하고 싶은 마음이 상당히 크다. 더 많은 개발자분들과 더 많은 대화를 나눌 수 있다는 기대감도 크다. 그리고 그런 과정에서 느끼고 배운 것들을 주기적으로 글을 통해 기록해보려 한다.","link":"/2019/10/13/8%EC%9B%94-%EB%A7%90%EB%B6%80%ED%84%B0-%EC%A7%80%EA%B8%88%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B7%BC%ED%99%A9-feat-%EC%9D%B4%EC%A7%81%EA%B8%B0/"},{"title":"ABI Stability","text":"스위프트 5.0에서 가장 많이 주목을 받고 있는 부분이 바로 ABI 안정화(Stability)이다. 대체 ABI가 안정화된다는 것이 무엇을 의미하는지, 왜 ABI 안정화를 지원하게 됬는지 ABI 자체가 무엇인지에 대해 알아보려 한다. 기본적으로 Swift ABI Stability Manifesto 글을 기반으로 각종 블로그 글들을 참고하면서 나름대로 정리해보았다. The Big Picture현재 스위프트의 가장 최우선 순위는 향후 스위프트 버전과의 호환성(compatibilty)이다. 호환성은 다음의 두 가지 목표를 갖고 있다. 소스 호환성(Source compatibility)은 새 컴파일러가 구 버전의 스위프트를 컴파일 할 수 있다는 것을 의미한다. 이는 새 스위프트 버전이 나오면 스위프트 개발자들이 직면했던 마이그레이션의 고통을 줄여주는 목적을 갖고 있다. 소스 호환성 없이는 프로젝트는 버전 잠금(version-lock)에 직면하는데 이는 프로젝트와 패키지 내부의 모든 소스코드가 동일한 스위프트 버전으로 작성되어야 한다는 것을 의미한다. 소스 호환성이 존재한다면 패키지 작성자는 그들의 사용자가 새로운 버전의 스위프트를 사용할 수 있도록 하며 여러 스위프트 버전을 단일 코드 기반으로 유지할 수 있다. 바이너리 프레임워크와 런타임 호환성(Binary framwork &amp; runtime compatibility)은 다양한 스위프트 버전에서 동작할 수 있는 바이너리 형태의 프레임워크 배포를 가능하게 한다. 바이너리 프레임워크는 프레임워크 API의 소스-레벨 정보와 통신하는 스위프트 모듈 파일(Swift module file)과 런타임 중 로드되는 컴파일된 구현체인 공유 라이브러리(shared library)를 포함한다. 따라서 바이너리 프레임워크 호환성(binary framework compatibility)은 두 가지 목적을 갖고 있다. 모듈 포맷 안정성(Module format stability)은 컴파일러가 프레임워크의 공개 인터페이스를 나타내는 모듈 파일을 안정화시킨다. 이는 API의 선언과 inlineable 코드를 포함한다. 이 모듈 파일은 컴파일러가 프레임워크를 사용하는 클라이언트 코드를 컴파일 할 때 타입 검사, 코드 생성 등과 같은 필수 작업을 진행하는데 사용된다. ABI 안전성(ABI stability)은 서로 다른 스위프트 버전으로 컴파일된 어플리케이션과 라이브러리 사이의 바이너리 호환성을 가능하게 한다. What is ABI?런타임 중에 스위프트 프로그램 바이너리는 ABI를 통해 다른 라이브러리와 요소들과 상호작용한다. ABI는 Application Binary Interface를 의미하며 독립적으로 컴파일된 바이너리 엔티티(실체)들이 서로 연결되고 실행되기 위해서 반드시 따라야 규격이다. 이러한 바이너리 엔티티들은 함수를 호출하는 방법, 메모리에서 데이터가 표현되는 방법 그리고 그들의 메타데이터가 어디에 존재해야하는지 그리고 어떻게 접근해야하는지 등의 저수준의 상세 사항들을 따라야 한다. API를 사용할 때 우리는 사용하려는 기능의 내부 로직은 크게 신경쓰지 않고 API의 원하는 기능을 취할 수 있다. 라이브러리가 업데이트되어도 우리가 호출하는 API의 메소드의 외형은 동일하게 사용할 수 있어야 한다. 라이브러리가 업데이트될 때마다 외형이 변경된다면 우리는 계속해서 우리의 코드를 이에 맞춰 수정해야 한다. ABI도 마찬가지라고 생각한다. ABI의 안정화 없이 스위프트 버전이 올라가게 되면 우리는 프로젝트에서 사용되는 스위프트를 새 버전의 스위프트로 계속해서 마이그레이션 해야 한다. What is ABI Stability?ABI 안정화란 향후 새로운 버전의 컴파일러가 안정환된 ABI 규격을 따르는 바이너리를 생성할 수 있는 수준으로 만드는 것을 의미한다. ABI 안정화는 오직 외부에 노출되는 공공 인터페이스와 심볼의 불변성에만 영향을 미친다. 내부 심볼, 컨벤션 그리고 레이아웃은 ABI 규격을 깰 필요 없이 지속해서 변경할 수 있다. 예를 들어 미래의 컴파일러는 공개되어 있는 공공 인터페이스를 유지하는한 내부 함수 호출의 호출 규칙을 자유롭게 변경할 수 있다. What Does ABI Stability Enable?ABI 안정화는 OS 공급자가 운영체제에 스위프트 표준 라이브러리와 구 버전 혹은 새 버전의 스위프트로 만들어진 어플리케이션과의 호환성을 갖는 런타임을 내장할 수 있도록 한다. 이렇게 되면 이러한 플랫폼 상의 앱을 배포할 때 표준 라이브러리를 앱 내에 포함시켜 배포할 필요가 없어진다. 이는 도구의 의존성을 줄여주고 운영체제에 보다 우수한 조화를 가능하게 한다. 기존의 iOS 앱 번들에는 해당 앱을 만드는데 사용한 버전의 스위프트 표준 라이브러리를 포함하고 있었다. 즉 스위프트 4.2로 만들어진 앱은 스위프트 4.2 ABI를 포함하는 스위프트 4.2 동적 라이브러리를 앱 번들 내에 포함하고 있었고 스위프트 3.0으로 만들어진 앱은 3.0 ABI를 포함하는 동적 라이브러리를 앱 번들 내에 포함하고 있었다는 것이다. 즉 각각의 언어는 각각의 OS 버전과 서로 다른 ABI 규격을 갖고 있었기 때문에 다른 버전의 OS에서 앱이 실행되기 위해선 앱 번들 자체에 스위프트 동적 라이브러리를 포함했어야 했다. ABI가 안정화되면 이렇게 앱 번들 내에 해당 버전의 스위프트 다이나믹 라이브러리를 포함할 필요가 없기 때문에 앱 사이즈는 줄어들 수 있다. 왜냐하면 OS와 스위프트의 버전 차이가 존재해도 ABI 규격은 동일하기 때문이다. 스위프트 표준 라이브러리와 스위프트 런타임이 OS에 내장되는 것이다. Module StabilityABI 안정화는 런타임 중의 스위프트 버전들의 혼용에 관한 것이다. 컴파일 시점은 어떤가? 스위프트는 “swiftmodule”이라는 불투명한 아카이브 포맷을 사용해 수동으로 작성된 헤더 파일이 아닌 “MagicKt” 프레임워크와 같은 라이브러이의 인터페이스를 나타낸다. 그러나 “swiftmodule” 포맷 역시 현재 컴파일러 버전에 묶여잇고 이는 만일 “MagicKit”이 다른 스위프트 버전으로 만들어졌다면 개발자는 import MagicKit을 통해 해당 프레임워크를 사용할 수 없다는 것을 의미한다. 즉 앱 개발자와 라이브러리 제작자는 반드시 같은 버전의 컴파일러를 사용해야 한다. 이러한 제한 사항을 없애기 위해 라이브러리 제작자는 현재 구현중인 현재는 구현되고 있는 모듈 안전성(module stability)라 불리는 기능을 필요로 한다. 이를 통해 라이브러리를 사용하는 개발자는 모듈이 어떤 컴파일러로 만들어졌는지 생각할 필요 없이 모듈을 사용할 수 있다. 예를들어 스위프트6 그리고 스위프트7 컴파일러는 스위프트6로 만들어진 프레임워크의 인터페이스를 읽을 수 있는 것이다. Libraray Evolution우리는 지금까지 컴파일러 교체에 관해 얘기했지만 스위프트 코드도 동일하다. 오늘날 스위프트 라이브러리가 변경되면 해당 스위프트 라이브러리를 사용하는 앱은 재컴파일 되어야 한다. 이는 몇 가지 장점이 있는데 컴파일러가 앱이 사용하는 라이브러리의 버전을 정확히 알고 있기 때문에 코드 크기를 줄일 수 있는 추가적인 가정(assumption)을 할 수 있고 앱을 보다 빠르게 실행시킬 수 있다. 하지만 이러한 가정은 다음 라이브러리 버전에는 맞지 않을 수 있다. Library Evolution 기능은 앱을 재컴파일 할 필요 없이 새로운 버전의 라이브러리의 기능을 사용할 수 있도록 하는 것이다. 위의 예제에서 앱은 노란색 버전으로 만들어진 프레임워크로 만들어졌다. library evolution과 함께 노란색 버전을 가진 시스템에서의 실행은 물론이고 새롭게 개선된 빨간색 버전에서도 실행될 수 있다. 참고 자료 ABI Stability and More Swift 5 ABI Stability Zedd님의 ABI Stability","link":"/2019/03/09/ABI-Stability/"},{"title":"App essentials in SwiftUI","text":"WWDC 2020을 통해 SwiftUI에선 App과 Scene 개념이 추가됐다. 이를 소개하고 있는 App essentials in SwiftUI 세션을 보고 간단히 정리해보았다. 새롭게 등장한 App, Scene 개념으로 UIKit 없이 순수 SwiftUI로만 앱을 만들 수 있게 됐다. Views, scenes and apps 화면에 보이는 모든 뷰가 하나의 앱에 속하는 것이 아니기 때문에, 하나의 앱이 전체 화면에 대해 완벽히 제어할 수 없다. 나누어진 영역에서 앱이 보여지는 방법은 플랫폼이 제어한다. SwiftUI에선 이렇게 화면 안에 구분된 영역을 Scene이라 부른다. 윈도우는 화면에 보여지는 Scene의 컨텐츠를 보여주는 가장 흔한 방법이다. iPadOS와 같은 플랫폼은 다수의 윈도우를 나란히 보여줄 수 있다. iOS나 watchOS 그리고 tvOS는 각각의 앱에 대해서 하나의 꽉 찬 단일 윈도우를 선호한다. macOS는 Scene의 컨텐츠가 얼마나 다양한 방법으로 보여질 수 있는가를 나타내는 좋은 예다. macOS에선 아래와 같이 다수의 윈도우로 개별 Scene을 보여주거나 탭으로 여러 Scene을 묶어 보여줄 수 있다. 이렇게 다수의 Scene은 App을 구성하고 App, Scene 그리고 View는 하나의 계층 구조를 이룬다. 아래의 앱과 코드를 살펴보자. ReadingListViewer는 View로 Scene의 한 종류인 WindowGroup에 속한다. 그리고 WindowGroup은 App 프로토콜을 따르는 BookClubApp의 Scene으로 사용된다. 코드에서 확인할 수 있는 계층구조와 우리가 위에서 살펴본 계층구조가 일치하는 것을 확인할 수 있다. 그리고 BookClubApp과 ReadingListViewer가 선언된 코드 구조도 유사한 것을 확인할 수 있다. App과 View, 둘 모두 Data Dependency를 선언할 수 있다. BoolClubApp - @StateObject @StateObject는 이번에 새로 등장한 개념으로 이는 추후에 살펴보도록 하자 ReadingListViewer - @ObservedObject App과 View, 둘 모두 body 프로퍼티를 통해 사용자 인터페이스를 표시한다. BookClubApp - var body: some Scene ReadingListViewer - var body: some View 세션의 주제와 별개로 Swift 5.3부터 등장한 @main이 선언되어 있는 것을 확인할 수 있다. 이는 프로그램의 시작점을 의미한다. 기본적으로 스위프트 프로그램은 main.swift를 필요로 하는데 @main을 통해 App 프로토콜을 따르고 있는 구조체에 해당 책임을 위임할 수 있다. Understanding ScenesWindowGroupWindowGroup을 통해 다수의 윈도우를 독립적으로 관리할 수 있다. 그리고 이렇게 독립된 윈도우는 서로 독립된 상태를 갖는데 이것이 SwiftUI에서 Scene의 가장 중요한 특징이라고 할 수 있다. 각각의 독립된 윈도우는 서로의 상태에 영향을 주지 않는다. App은 각 Scene이 사용할 수 있는 Shared Model을 제공할 수 있지만, 각 Scene의 뷰들의 상태는 서로 독립적이다. 그리고 위와 같이 앱 스위처에서 보여지는 타이틀을 뷰 변경자를 통해 윈도우별로 다르게 지정할 수 있다. 이는 부모 Scene의 상태에 영향을 줄 수 있는 변경자 중 하나이다. macOS에선 WindowGroup을 사용해 아래의 기능들을 제공할 수 있다. 다중 윈도우 파일 메뉴에 새 윈도우 생성 메뉴 아이템 추가 단축키 지원 (Command + N) 윈도우 메뉴 개별 윈도우를 위한 메뉴 아이템(윈도우 타이틀) 다수의 윈도우를 하나의 탭 인터페이스로 통합하는 기능을 지원하는 메뉴 아이템 이 모든 것들은 부가적인 코드 없이 SwiftUI가 자동으로 지원하는 기능들이다. Scene의 생명주기는 실행되고 있는 플랫폼에 의해 관리된다. macOS에선 새 윈도우가 필요하면 WindowGroup은 새 자식 Scene을 생성한다. 이처럼 macOS나 iPadOS와 같이 다중 윈도우를 지원하는 플랫폼에선 WindowGroup은 다수의 자식 Scene을 생성할 수 있다. 각각의 윈도우는 사용자 인터페이스 정의를 공유하지만 모두 독립된 상태를 갖는다. 그렇기 때문에 하나의 윈도우에서의 변화는 다른 윈도우에 영향을 주지 않는다. 플랫폼이 Scene 생명주기 관리에 책임이 있기 때문에, 각 뷰의 상태를 관리할 수 있는 새 프로퍼티 래퍼인 @SceneStorage라는 개념이 새로 등장했다. 이는 고유 키 값을 이용해 저장될 상태를 식별한다. 그리고 상태는 SwiftUI에 의해 적절한 타이밍에 저장되고 복원된다. Customizing AppsDocument based App지금까지 살펴본 BookClubApp은 Data-Driven 앱으로 Shared Model을 기반으로 하는 형태의 앱이었다. 이런 형태의 앱뿐만 아니라, 문서 기반의 앱도 존재한다. 이런 형태의 앱에선 DocumentGroup을 사용할 수 있다. DocumentGroup은 열기, 편집, 저장과 같이 문서 기반의 앱을 관리하는데 필요한 기능을 제공하는 Scene의 한 종류다. Preferences Window설정 윈도우(Preferences Window)는 macOS 앱들이 제공하는 공통적인 기능 중 하나이다. 이를 위해 macOS에는 새로운 Scene 타입인 Settings 타입이 추가되었다. 이는 기본적인 설정 윈도우와 관련 단축키도 제공한다. 그리고 우린 기본 단축키 이외의 단축키도 새 변경자 API를 통해 지원할 수 있다. 해당 세션을 통해 앱과 관련하여 새로 추가된 기능 및 API들에 대해 간단히 알아볼 수 있었다. 길지 않은 세션이기 때문에 출,퇴근길에 간단하게 시청할 수 있는 세션이었다.","link":"/2020/07/19/App-essentials-in-SwiftUI/"},{"title":"Bitcode in iOS","text":"오늘은 iOS의 비트코드(Bitcode)에 대해 알아보려 한다. 비트코드를 알아보게 된 계기는 현재 인턴을 진행하면서 기존 네이버 지도 API를 네이버 지도 V3 API로 교체를 해야 하는 작업을 과제로 받았다. 이를 위해 데모 프로젝트와 문서를 보면서 샘플 프로젝트를 만드려는데 시뮬레이터에서는 정산적으로 빌드가 되고 실행이 되는 반면 실제 디바이스에서 테스트를 진행하려니 비트코드 에러가 발생하면서 빌드조차 되지 않았다. 이 에러를 해결 방법은 간단했는데 Build Setting 탭으로 들어가 Enable Bitcode 항목을 No로 지정해주면 되었다. 하지만 늘 그렇듯 어떤 문제를 했는데 그 해결 방법이 어떠한 방법으로 문제를 해결했는지에 대해 알지 못하는 것만큼 불안한 것은 없다. 특히 이렇게 빌드 세팅의 속성을 변경해주는 경우에는 더 그렇다. 그래서 이에 관해 조금 찾아보았고 그 정보들을 정리해서 기록해보려 한다. Bitcode먼저 애플 공식 문서는 비트코드를 다음과 같이 설명하고 있다. 비트코드는 컴파일된 프로그램의 중간 표현(intermediate representation)이다. 비트코드를 포함한 앱을 앱 스토어에 업로드하면 앱은 컴파일되고 앱 스토어어와 링크될 것이다. 비트코드를 포함하면 새로운 버전의 앱을 앱 스토어에 다시 제출할 필요 없이 애플이 앱 바이너리(컴퓨터가 실행할 수 있는 코드를 포함하고 있는 파일)를 다시 최적화할 수 있다. iOS 앱에서 비트코드는 기본으로 포함되지만 이를 선택할 수 있다. watchOS와 tvOS 앱에서 비트코드는 필수다. 만일 비트코드를 제공한다면 모든 앱과 앱 번들 안의 모든 프레임워크(프로젝트 안의 모든 타겟)는 비트코드를 포함해야 한다. Xcode는 기본적으로 앱의 심볼을 숨기기 때문에 이는 애플이 읽을 수 없다. 앱을 앱 스토어에 올릴 때 심볼을 포함할 것인지에 대한 옵션이 주어진다. 심볼을 포함하면 테스트플라이트 혹은 앱 스토어를 통해 앱을 배포했을 때 애플은 앱에 대한 크래시 리포트를 제공한다. 만약 크래시리포트를 직접 수집하고 상징화(Symbolication : 상징화는 크래시 로그의 메모리 주소를 사람이 읽을 수 있는 함수명과 라인 넘버로 교체하는 작업을 말한다.)하기를 원한다면 심볼을 업로드할 필요 없다. 대신 앱 배포 후 비트코드 컴파일 dSYM 파일을 다운로드 받을 수 있다. 모든 뜻을 이해할 순 없었지만 내 프로젝트에서 에러가 발생하는 이유는 추측할 수 있었다. Xcode를 통해 프로젝트를 생성하면 기본적으로 비트코드는 포함되도록 설정되어 있다. 하지만 네이버 지도 V3 API 프레임워크는 비트코드를 포함하고 있지 않기 때문에 문서의 내용 중 *”만일 비트코드를 제공한다면 모든 앱과 앱 번들 안의 모든 프레임워크(프로젝트 안의 모든 타겟)는 비트코드를 포함해야 한다.”*에 위배된다. 그래서 프로젝트의 빌드 세팅에서 비트코드 포함 옵션을 No로 지정하니 프로젝트가 정상적으로 빌드 되고 실행될 수 있던 것이다. 하지만 여전히 비트코드 이 자체에 대한 이해는 부족하다. 좀 더 자료를 찾아보자. 역시 나와 비슷한 사람은 많았고 누군가 Quora에 질문을 올렸고 이에 대한 답변이 애플의 공식 문서보다 친절하고 보다 명확하게 와닿았다. LLVM 비트코드를 이해하기 위해선 먼저 LLVM(Low Level Virtual Machine)에 대해 알아야 한다. LLVM은 라이브러리로 코드를 중간 매체 혹은 기계 코드로 컴파일하는데 사용된다. LLVM을 통해 많은 컴파일러와 언어들을 만들어낸다. 이렇게 만들어진 컴파일러의 컴파일 과정은 세 단계로 나뉜다. 컴파일러 프론트 엔드는 소스 코드를 중간 표현 단계로 변환한다. 이 중간 표현 단계는 불필요한 코드를 제거하고 하는 등의 최적하 과정을 겪는다. 이 과정은 소스 코드도 기계 코드도 아닌 중간 표현 단계에서 진행되는데 옵티마이저가 더욱 쉽게 해석할 수 있는 형태이기 때문이다. 컴파일러 백 엔드가 중간 표현 단계를 기반으로 기계 코드를 생성한다. 비트코드는 LLVM을 통해 앱의 코드를 받아 이를 비트코드로 전환하고 주어진 지침을 통해 이를 실행 가능한 앱으로 전환하는 방법을 안다. 즉 비트코드는 어떤 아키텍쳐에서도 실행되기를 준비하는 중간 단계인 것이다. 간단히 말해서, 이러한 구조는 애플이 앱 스토어에 새로운 CPU 지원을 백엔드에 쉽게 추가할 수 있다는 것을 의미하며 이렇게 되면 비트코드는 이를 통해 새로운 아키텍처로 컴파일 하는 방법을 알 수 있는 것이다. 비트코드를 포함하지 않는다면 컴파일러는 머신 코드만을 포함하는 실행 파일을 생성할 것이다. 하지만 비트코드를 포함한다면 비트코드는 기계 코드와 나란히 실행 파일에 포함될 것이다. 비트코드의 형태로 앱 스토어에 제출하면 앱 스토어는 해당 앱을 다운로드 받는 디바이스 환경에 맞춰 최적화를 진행하여 내려보낼 것이다. 이 과정은 앱 시닝(App Thinning)에 포함된다. 앱 시닝에 대한 내용은 추후에 살펴보고 포스팅할 예정이다. 일례로 살펴보면 애플은 2013년에 아이폰 5s부터 64비트 칩셋으로 교체할 것이라고 발표했고 앱 개발자들은 이를 위해 앱을 다시 컴파일해서 제출해야 했다. 그 이유는 비트코드가 아닌 실행 가능한 코드 자체를 올렸기 때문에 이는 새로운 아키텍쳐 칩셋 환경에서 동작할 수 없었기 때문이다. 이제는 비트코드가 포함된 실행 파일을 올려도 새로운 디바이스 환경에서 앱이 동작할 수 있게 되었다. 참고 자료 What is app thinning? (iOS, tvOS, watchOS) What is Apple Bitcode? Is it safe to enable bitcode?","link":"/2019/03/10/Bitcode-in-iOS/"},{"title":"Embrace Swift type inference","text":"WWDC 2020 스위프트는 코드의 안전성을 훼손하지 않고 간결한 코드를 작성하기 위해 타입 추론(Type inference)을 광범위하게 사용한다. 이 영상을 통해 우리는 다음의 것들을 살펴볼 것이다. 타입 추론을 활용하는 법 컴파일러에서 타입 추론이 어떻게 동작하는지 타입 추론에 의해 발생할 수 있는 에러의 원인과 이를 해결하는 방법 What is type inference? 먼저 타입 추론이 무엇인지 간단하게 알아보자. 타입 추론은 프로퍼티에 타입을 명시적으로 선언하지 않아도 컴파일러가 문맥에 따라 타입을 추론하는 것을 말한다. 위의 코드에서 String을 명시적으로 선언하지 않아도 컴파일러는 이를 String으로 추론한다. 좀 더 복잡한 예제 코드로 타입 추론을 활용하고, 컴파일러에서 타입 추론이 어떻게 동작하는지를 살펴보자. 위의 코드에서 FilteredList는 주어진 데이터를 리스트 형태로 보여주고 필터링 기능을 제공하는 재사용 가능한 뷰다. 이 FilteredList는 재사용 가능해야 하므로 기본적으로 생성자 인자들은 제네릭 해야 한다. 위의 코드에서 FilteredList를 사용하면서 따로 타입을 명시해 주지 않고 있다. 이는 컴파일러가 타입 추론을 하기 때문에 가능한 일인데, 이를 좀 더 알아보기 위해 FilteredList가 어떻게 정의되어 있는지 코드로 살펴보도록 하자 Element, FilterKey 그리고 RowContent는 FileteredList가 생성될 때 실제 타입, 즉 Concrete 타입으로 대체된다. 이제 선언부와 호출부를 나란히 두고 비교해보자. 제네릭 타입으로 인해 복잡한 선언부와 비교했을 때 호출부는 훨씬 깔끔한 코드임을 확인할 수 있다. 이는 컴파일러가 주어진 값들로 타입 추론을 하기 때문에 가능한 일인데, 타입 추론이 아닌 명시적으로 타입을 명시한다면 아래와 보다 복잡한 코드를 작성해야 한다. 그렇다면 컴파일러는 어떻게 타입 추론을 하는 것일까? 타입 추론은 일종의 퍼즐이라고 할 수 있다. 우린 퍼즐을 하면서 하나의 조각이 맞춰질 때 다음 조각을 자연스럽게 유추할 수 있다. 하나의 퍼즐이 맞춰질 때마다 다음 조각에 대한 단서를 우린 유추할 수 있다. 컴파일러는 이렇게 퍼즐을 풀 듯이 우리의 코드에서 단서를 찾아 퍼즐을 하나씩 맞춰가며 타입을 추론한다. 위의 코드를 사용해서 컴파일러가 어떻게 퍼즐을 맞춰가는지 살펴보자. 먼저 첫 번째로 인자로 넘기는 smoothies라는 단서를 통해 Element의 타입을 추론할 수 있다. smoothies는 [Smoothie] 타입으로 Element는 Smoothie 타입으로 대체된다. 우린 Element라는 퍼즐 조각을 맞췄기 때문에 이를 통해 또 다른 단서를 얻을 수 있다. 바로 FilterKey다. \\.title은 \\Smoothe.title로 대체되고 Smoothie의 title 프로퍼티는 String이란 것을 알 수 있기 때문에 FilterKey는 String으로 대체된다. RowContent 역시 ViewBuilder 클로저 안에서 SmoothieRowView가 반환되기 때문에 SmoothieRowView로 대체될 수 있다. 이런 식으로 컴파일러는 이전 단계의 단서를 통해 하나씩 타입을 추론해 나간다. 하지만 이렇게 얻은 이전 단계의 퍼즐 조각(단서)이 맞지 않는다면 소스 코드에 에러가 발생했다는 것을 의미한다. 즉 맞지 않은 타입이 들어갔기 때문에 컴파일러는 더 이상 타입 추론을 진행할 수 없다. Smoothie.title이 아닌 Bool 타입의 Smoothie.isPopular로 바꿔보자 그렇다면 컴파일러는 Bool 타입을 FilterKey의 조각으로 사용할 것이다. 하지만 Bool 타입은 hasSubString(_:) 메서드가 없기 때문에 이후의 타입 추론을 진행할 수 없고, 에러를 뱉는다. 이렇게 스위프트 컴파일러는 추후에 에러 메시지를 출력할 때 사용하기 위해 에러 추적 기능을 타입 추론에 통합시켰다. 컴파일러는 타입 추론을 진행하면서 직면한 에러를 기록한다. 그리고 컴파일러는 에러를 고치고 타입 추론을 계속 진행하기 위해 휴리스틱을 사용한다. 그리고 타입 추론이 끝나면 컴파일러는 타입 추론을 진행하면서 수집한 에러를 actionable한 에러 메시지(자동으로 코드를 수정할 수 있는)나 에러를 발생시킨 실제 타입에 대한 메시지와 함께 개발자에게 알린다. 이렇게 통합된 에러 추적 시스템은 Xcode11.4의 스위프트 5.2에선 많은 오류 메시지에 도입되었고, Xcode12의 스위프트 5.3에선 모든 에러 메시지에 적용되었다. Embrace Swift type inference","link":"/2020/08/23/Embrace-Swift-type-inference/"},{"title":"GeometryReader in SwiftUI","text":"SwiftUI를 공부하다 보면 자연스레 등장하는 개념이 바로 GeometryReader다. 어렴풋이 이해하고 있던 개념을 포스팅을 통해 정리해보려 한다. What is GeometryReaderGeometryReader란 무엇인가? SwiftUI에선 UIKit으로 레이아웃을 작성할 때와 달리 뷰 객체에 직접 접근할 수 없다. 뷰 객체에 직접 접근해 뷰 정보(size, position 등)에 알 수 있었던 것과 달리 SwiftUI에서 뷰 객체는 일시적인(transient) 객체로 프레임워크가 뷰를 그리고 난 후 객체는 사라지기 때문에 UIKit과 같은 방식으론 뷰에 관한 정보를 알 수 없다. 그렇다고 모든 뷰에 .frame(width:, height) 변경자를 사용해 직접 고정 값을 넣을 수도 없는 일이다. 이를 위해 등장한 개념이 GeometryReader로 상위 뷰의 Geometry 정보를 하위 뷰에 제공하는 역할을 한다. 보다 정확히는 상위 뷰가 제안한 Geometry 정보 1234567struct SomeView: View { var body: some View { GeometryReader { proxy in // proxy를 통해 뷰 정보에 접근. } }} GeometryReader에 대해 더 자세히 살펴보기 전에 아직은 완성되지 않은 듯한 애플 공식 문서가 설명하고 있는 GeometryReader를 살펴보자. A container view that defines its content as a function of its own size and coordinate space. 컨텐츠를 자신의 크기 및 좌표 공간의 함수로 정의하는 컨테이너 뷰 이 설명을 통해 자세히는 아니지만 몇 가지 키워드로 힌트는 얻을 수 있다. 컨테이너 뷰 자신의 크기 및 좌표 공간 Layout ProcessGeometryReader를 이해하고 올바르게 사용하려면, SwiftUI에서 레이아웃을 그리는 세 단계에 대해 반드시 이해해야 할 필요가 있다. 이전 글을 참고하셔도 좋습니다. 이 세 단계를 간단히 요약하자면 아래와 같다. 부모 뷰가 자식 뷰의 사이즈를 제안한다. 자식 뷰는 제안받은 사이즈를 이용해 자신의 사이즈를 결정한다. ((언제나 제안받은 사이즈 == 자신의 사이즈) == false) 부모 뷰는 결정된 자식 뷰를 적절히 위치시킨다. GeometryReader는 상위 뷰에서 제안한 사이즈를 자신의 사이즈로 사용 및 반환한다. 가능한한 최대한 확장한다고 생각하면 된다. GeometryProxyGeometryReader는 컨테이너 뷰의 한 종류이며, 다른 컨테이너 뷰의 ViewBuilder와는 다르게 인자를 하나 받는데 그것이 바로 GeometryProxy 객체다. 실제로 상위 뷰의 정보는 이 객체를 통해 접근이 가능하다. 기본적으로 위에서 살펴보았듯이 GeometryProxy는 size 프로퍼티를 갖고 있다. 이외에도 .frame(in: )라는 메서드가 있으며, 서브스크립트도 지원한다. .frame(in:)GeometryReader를 통해 size뿐만 아니라 .frame 메서드를 통해 CGRect에 접근해, 좌표값도 알 수 있다. 이 좌표값은 지정한 좌표평면 공간에 따라 달라질 수 있다. .local - 자신이 속한 컨테이너 뷰 안에서의 좌표를 반환한다. .global - 전체 스크린에서의 좌표를 반환한다. .named(_:) - 지정한 좌표평면에서의 좌표를 반환한다. .coordinateSpace(name: 을 통해 사용자 정의 좌표평면을 지정할 수 있다. .frame(in:) 메서드를 통해 UIKit에서 convert 메서드를 사용해 좌표를 변환하던 작업이 보다 수월해졌다. 123456789101112131415161718192021222324252627struct ContentView: View { var body: some View { GeometryReader { proxy in HStack(spacing: 0.0) { ... ZStack(alignment: .topLeading) { ... GeometryReader { innerProxy in Rectangle() .foregroundColor(Color.pink) .onTapGesture { let local = innerProxy.frame(in: .local) let global = innerProxy.frame(in: .global) let named = innerProxy.frame(in: .named(\"OuterGeometry\")) print(\"[local] minX : \\(local.origin.x), minY : \\(local.origin.y)\") print(\"[global] minX : \\(global.origin.x), minY : \\(global.origin.y)\") print(\"[named] minX : \\(named.origin.x), minY : \\(named.origin.y)\") } }.frame(width: 50, height: 50) } ... } }.coordinateSpace(name: \"OuterGeometry\") }} 1234[RESULT][local] minX : 0.0, minY : 0.0[global] minX : 112.5, minY : 20.0[named] minX : 112.5, minY : 0.0 subscript(Anchor) -&gt; TGeometryProxy의 서브스크립트를 이해하기 위해선 Anchor와 함께 Preferences에 대한 이해가 있어야 한다. 그러므로 이는 추후 Preferences에 대한 포스팅에서 함께 다뤄볼 예정이다. Preferences는 GeometryReader와 함께 SwiftUI에서 중요한 개념 중 하나로, 하위 뷰에서 상위 뷰로 정보를 전달하는데 사용된다. Usage그럼 우린 GeometryReader를 어떻게 사용할 수 있을까? 위에서 언급했듯이 기본적으로 상위 뷰와 비례해 하위 뷰의 사이즈를 조정할 때 사용할 수 있다. 추가로 위에서 언급했던 “GeometryReader는 상위 뷰에서 제안한 사이즈를 자신의 사이즈로 사용 및 반환한다.” 특성을 이용하여 Preferences와 함께 사용될 때 하위 뷰의 geometry 정보를 상위 뷰에 전달할 때도 유용하게 사용할 수 있다. 위의 결과 화면은 VStack 내부의 Text들 중 가장 너비가 큰 값을 이용해 Text 각각의 background에 Circle을 위치시킨 결과다. 그럼 Circle의 적절한 너비와 높이 값이 정해져야 하는데 이 정보는 어떻게 알 수 있으며 어떻게 지정해야 할까? Preferences에 관한 포스팅에서도 더 자세히 살펴볼 코드지만 그중 일부만 살펴보자. 그전에 이 글을 참고하면 조금이나마 코드를 이해하는데 도움이 될 수 있습니다. 123456789101112Text(\"Reset\") .padding() .fixedSize() .background(GeometryReader { proxy in Color.clear.preference(key: SizePreferenceKey.self, value: [proxy.size]) }) .frame(width: size?.width, height: size?.width) .background( Circle() .fill(Color.blue) ) background안에 투명한 Color 뷰를 넣어 해당 Text의 size 값을 알 수 있다. 그 이유를 이해하기 위해선 역시 Layout Process에 대한 이해가 필요한데, 기본적으로 background는 caller의 사이즈를 그대로 인자로 들어가는 뷰에 제안한다. 그리고 GeometryReader는 제안받은 사이즈를 자신의 사이즈로 반환하기 때문에 위의 코드에서 proxy의 사이즈가 곧 Text의 size가 된다. 이렇게 알아낸 Text의 사이즈를 상위 뷰로 전달하고 상위 뷰는 이렇게 취합된 Text들의 사이즈 중 가장 큰 사이즈로 Text들의 너비를 조정해 파란색 Circle에 올바른 사이즈를 제안할 수 있게 된다. Bugs🐛 사실 버그라고 해야 할지, 단순히 버전 차이에 따른 차이인지 정확하게는 알 수 없다. 하지만 iOS 13.x 버전과 iOS 14 버전에서의 GeometryReader의 동작 방식에는 차이가 있다. 바로 GeometryReader 하위 뷰들의 정렬 차이인데, 아래의 이미지를 통해 그 차이를 살펴보자. 코드의 구조는 대략 아래와 같다. 123456VStack { GeometryReader { Text(\"…\") } Text(\"…\")} 13.x 버전에선 GeometryReader가 Text를 기본적으로 가운데 위치시키지만, iOS 14 버전에선 Text를 왼쪽 상단 모서리에 위치시킨다. 구글링을 해보았지만, 딱히 명확한 이유를 알 수 없었다..😇 이에 대해 알고 있는 부분이 있으시다면 댓글 부탁드립니다 . . . [는 하루만에 이유를 찾았다.] 😅 그 이유는 Xcode 12 beta 3 release note에서 찾을 수 있었다. Resolved in Xcode 12 beta Rebuilding against the iOS 14, macOS 11, watchOS 7, and tvOS 14 SDKs changes uses of GeometryReader to reliably top-leading align the views inside the GeometryReader. This was the previous behavior, except when it wasn’t possible to detect a single static view inside the GeometryReader. (59722992) (FB7597816) 즉 top-leading 정렬이 정상 동작이며, GeometryReader가 단일 정적 뷰를 내부 뷰로 가져갈 경우 이를 감지 못하던 이슈(가운데 정렬시키던)가 해결되었다고 언급하고 있다. 참고 자료 Understanding frames and coordinates inside GeometryReader GeometryReader to the Rescue","link":"/2020/07/26/GeometryReader-in-SwiftUI/"},{"title":"Opaque Types in Swift","text":"오늘은 Swift 5.1에서 처음 소개된 불투명 타입(Opaque Type)에 대해 공부해보고 기록해보려 한다. 사실 SwiftUI를 본격적으로 공부하려다 some 키워드에 막혀 이게 무엇인지 알아보려다 여기까지 오게 되었다. 이렇게 SwiftUI는 다시금 뒤로 미뤄졌다.🙄 진짜 제대로 시작해야 하는데.. 불투명 타입을 공부하면서 명확하게 이해가 된 부분도 있지만, 아직은 불투명하게 다가온 부분도 있었다. 그 이유는 아무래도 어느 문법을 공부해도 마찬가지겠지만, 직접 프로젝트에 사용하여 필요성을 느껴보지 못해서 그런 것 같다. @escaping 클로저를 처음 배웠을 때도 이와 비슷한 느낌이었다. 오늘은 단순히 문법적 이해를 위한 기록으로 작성하고 추후 기회가 된다면 직접 사용해보고 이 문법이 왜 도입되었고, 언제 사용하면 좋을지 다른 사람들이 소개한 케이스가 아닌 내가 경험한 케이스를 소개해보려 한다. Type Identity불투명 타입을 소개하기 전 가장 먼저 본인이 불투명 타입을 공부하면서 헷갈렸던 부분을 먼저 소개해보려 한다. 스위프트 공식 문서나 여러 해외 블로그들을 읽다 보면 불투명 타입을 설명하는 데 있어 정체성(Identity)를 자주 언급하는 것을 확인할 수 있다. 정확하게 말하면 타입 정체성(Type Identity)이다. 타입 정체성이란 무엇일까? 몇 개의 글과 함께 예제 코드를 보고서야 조금은 감을 잡을 수 있었다. 내가 이해한 타입 정체성은 다음과 같다. 우린 스위프트에서 프로토콜을 타입으로써 사용할 수 있다. 1234567891011121314151617181920212223242526protocol Analytics { func log()}class FirebaseAnalytics: Analytics { func log() { /* ... */ }}class FlurryAnalytics: Analytics { func log() { /* ... */ }}class AnalyticsManager { private let analytics: Analytics init(_ analytics: Analytics) { self.analytics = analytics } func sendLog() { analytics.log() }}let manager1 = AnalyticsManager(FirebaseAnalytics())let manager2 = AnalyticsManager(FlurryAnalytics()) 전적으로 예제를 위한 예제 코드다. AnalyticsManager는 어떤 애널리틱스 툴을 사용해도 로그만 전송하면 된다. 우리는 보통 이런 경우 위와 같이 프로토콜을 만들고 행위를 정의한다. 그리고 행위를 구현한 구현체를 프로토콜 타입으로써 주입해준다. AnalyticsManager가 sendLog를 호출할 때 AnalyticsManager는 FirebaseAnalytics나 FlurryAnalytics가 아닌 단지 Analytics 타입으로 analytics 프로퍼티를 사용한다. 이렇게 프로토콜 타입은 사용되는 시점에 자신의 실제 타입에 대한 정체성을 잃게 된다. “잃게 된다”라는 어감(?) 때문인지 부정적으로 다가올 수 있지만 이게 프로토콜 타입을 사용하는 이유다. 추상화의 의미를 생각해보면 정체성을 잃는다는 것을 보다 쉽게 받아들일 수 있다. 그리고 이런 프로토콜 타입은 프로그램에 유연성을 제공해주기 때문에 의존성 주입 등 코드 작성 전반에 걸쳐 유용하게 사용된다. 하지만 이러한 유연성이 때로는 코드 복잡성을 야기할 수 있다. 일반적인 프로토콜 타입에는 해당하지 않지만 associatedtype이나 Self를 사용하는 프로토콜 타입은 타입으로써 반환되거나, 파라미터로 전달, 프로퍼티로 사용될 수 없다. 만일 그렇게 사용하면 우린 굉장히 익숙한 에러 메세지를 볼 수 있다. 1Protocol 'SomeProtocol' can only be used as a generic constraint because it has Self or associated type requirements 너무 돌아왔다. 결국 프로토콜 타입은 타입 정체성을 잃고 유연성을 제공한다는 것에 주목하자! Opaque Types불투명 타입의 사용법은 간단하다. 반환되는 프로토콜 타입 앞에 some 키워드를 붙여주면 끝이다. 하지만 단순히 문법의 사용법만 가지곤 문법을 활용할 수 없다. 언제 불투명 타입을 사용할 수 있고, 불투명 타입을 왜 사용하는지에 대해 알아보았다. 이를 위해 불투명 타입이 없던 Swift 5.1 이전으로 돌아가 보자. 결제수단을 제공하는 프레임워크를 작성한다고 가정해보자. 123public func favoriteCreditCard() -&gt; CreditCard { return getLastUsedCreditCard()} 위와 같은 방식으로 사용자가 최근에 사용한 카드를 사용자가 선호하는 카드로 반환해줄 수 있다. 하지만 이러한 과정에서 우리는 굳이 사용자가 알 필요 없고, 알아서는 안되는 CreditCard라는 타입을 노출시킨다. 우리는 이런 문제를 프로토콜을 사용하여 해결하려 한다. 12345678910protocol PaymentType { }struct CreditCard: PaymentType { }struct ApplePay: PaymentType { }func favoritePaymentType() -&gt; PaymentType { if likesApplyPay { return ApplePay() } return getLastUsedCreditCard()} 얼핏 보면 해결된 것처럼 보일 수 있지만 사용자가 PaymentType을 비교해야 한다면 얘기는 달라진다. 1protocol PaymentType: Equatable { } Equatable 타입은 내부적으로 Self를 사용한다. 이렇게 결제수단의 비교를 위해 Equatable을 사용하면 타입 정체성에서 언급한 에러 메세지를 보게 된다. 1Error: Protocol 'PaymentType' can only be used as a generic constraint because it has Self or associated type requirements 물론 이런 문제를 제네릭과 타입 제거 기법(type erasure techniques)을 통해 해결할 수 있다. 하지만 이는 프레임워크의 사용을 더욱 어렵게 만들며 역시 의도치 않게 내부 타입을 노출시킬 수 있다. 불투명 타입이 이런 문제를 해결할 수 있다. 방법은 매우 간단하다. 123public func favoriteCreditCard() -&gt; some PaymentType { return getLastUsedCreditCard()} 물론 방법이 매우 간단한 만큼 한계도 존재한다. 불투명 타입을 반환하는 함수는 오로지 하나의 타입만 반환할 수 있다. 위의 코드에서 함수의 반환 타입은 CreditCard다. 하지만 컴파일러가 이를 PaymentType인 것 마냥 다룬다. 내부적으론 실제 타입을 반환하는 것이기 때문에 실제 타입으로 할 수 있는 모든 것들은 할 수 있다. 즉 타입 정체성이 보장된다는 것이다. 타입의 정체성이 보장되기 때문에 associatedtype이나 Self를 사용하는 프로토콜도 반환 타입으로 바로 사용할 수 있다. 물론 불투명 타입의 한계도 존재한다. 이런 타입의 정체성을 보장하기 위해 하나의 타입만을 반환할 수 있다. 123456func favoritePaymentType() -&gt; some PaymentType { if likesApplyPay { return ApplePay() } return getLastUsedCreditCard()} 즉 위와 같은 코드는 사용할 수 없다는 뜻이다. 다시 불투명 타입을 사용하면 어떤 점이 좋은지 이야기해보자. 위에서 언급했듯이 불투명 타입은 모듈 내부의 타입을 노출시키지 않을 수 있다. 이게 단순히 하나의 타입을 노출시키지 않는다는 것을 의미하기도 하지만, 타입이 내부적으로 어떤 타입들로 구성되어 있는지도 숨길 수 있다. SwiftUI를 예로 들어보자. SwiftUI 프로젝트를 생성하면 하나의 템플릿 코드를 확인할 수 있다. 12345struct ContentView: View { var body: some View { Text(\"Hello World\") }} 바로 내가 SwiftUI 공부를 멈추고 불투명 타입을 공부하기 시작하게 된 코드다. 이 코드에서 some 키워드를 사용한 이유가 뭘까? some 키워드를 지우면 컴파일이 되지 않는 걸까? 그렇지 않다. some 키워드가 없이도 충분히 프로그램을 만들 수 있다. 12345struct ContentView: View { var body: Text { Text(\"Hello World\") }} some 키워드를 사용하지 않고 SwiftUI로 화면을 만들어보자. SwiftUI에선 VStack을 이용해 스택 뷰의 형태를 구현할 수 있다. 그리고 SwiftUI에서 이런 컨테이너 타입들은 모두 제네릭 타입이다. 12345678struct ContentView: View { var body: VStack&lt;TupleView&lt;(Text, Image)&gt;&gt; { VStack { Text(\"Hello World\") Image(systemName: \"video.fill\") } }} . . 🤔 자자..! 일단 계속 만들어보자. 하나의 텍스트를 더 추가해보자. 123456789struct ContentView: View { var body: VStack&lt;TupleView&lt;(Text, Text, Image)&gt;&gt; { VStack { Text(\"Hello World\") Text(\"My name is Corn\") Image(systemName: \"video.fill\") } }} 좀 더 복잡한 레이아웃을 그려보자! . . . . 1234567struct ContentView: View { var body: List&lt;Never, TupleView&lt;(HStack&lt;TupleView&lt;(VStack&lt;TupleView&lt;(Text, Text)&gt;&gt;, Text)&gt;&gt;, HStack&lt;TupleView&lt;(VStack&lt;TupleView&lt;(Text, Text)&gt;&gt;, Text)&gt;&gt;)&gt;&gt; { ... ..... ........ }} 자 완성했다! 근데 중간 어디쯤에 있는 Text를 Image로 바꾸려 한다! 그러면…🤯 이쯤 되면 왜 불투명 타입이 필요한지 절실히 깨달을 수 있다. 우린 단지 body가 어떤(some) View 타입을 반환한다 정도만 알고 싶은 것이다. 그리고 그 정도의 정보만 필요하다. 우린 some 키워드로 body는 단지 View 타입을 반환한다는 사실을 명시해줄 수 있다. 1234567struct ContentView: View { var body: some View { ... ..... ........ }} 마무리아직은 내가 직접 작성한 모듈 혹은 프로젝트에서 불투명 타입을 사용해보진 못했다. 하지만 이젠 불투명 타입의 존재와 언제 사용하면 좋을지에 대해 훑어보았기 때문에 다음에 기회가 왔을 때 불투명 타입 사용을 고려해볼 수 있게 되었다. SwiftUI 공부도 다시 시작할 수 있다! 참고 자료 What’s this “some” in SwiftUI Understanding Opaque Return Types in Swift Opaque Types","link":"/2019/12/12/Opaque-Types-in-Swift/"},{"title":"OptionSet","text":"오늘은 회사 과제를 진행하던 중 처음 접한 스위프트의 OptionSet이라는 친구를 살펴보려 한다. 처음 접한 개념이지만 알아보니 그렇게 어렵지 않은 개념이면서도 유용하게 사용할 수 있을 것 같은 개념이어서 이렇게 기록해보려 한다. 먼저 그 개념을 공식 문서를 통해 살펴보도록 하자. OptionSet 프로토콜은 비트들 각각이 집합의 요소를 표현하는 비트 집합 타입을 표현하는데 사용된다. 이 프로토콜을 채택한 사용자 정의 타입에선 요소 검사(해당 요소가 집합에 속하는지), 합집합, 교집합 연산과 같은 집한 연산들을 수행할 수 있다. 옵션 집합(OptionSet 프로토콜을 채택한 사용자 정의 타입)을 만들기 위해선 타입 선언 부분에 rawValue를 포함시켜야 한다. 사용자 정의 타입으로 만든 옵션 집합이 기본 집합 연산을 수행하기 위해선 rawValue 프로퍼티는 반드시 FixedWidthInteger 프로토콜을 따르고 있는 타입(Int, UInt8 등등)이어야 한다. 다음으로는 정적(static) 변수로 고유한 2의 거듭제곱 값(1, 2, 4, 8, …)을 rawValue로 갖는 옵션들을 생성한다. 이렇게 2의 거듭제곱 값을 rawValue로 가져야 각각의 옵션들은 단일 비트로 표현이 가능하기 때문이다. OptionSet은 다음과 같이 정의할 수 있다. 1234567891011struct ShippingOptions: OptionSet { let rawValue: Int static let nextDay = ShippingOptions(rawValue: 1 &lt;&lt; 0) // 0001 static let secondDay = ShippingOptions(rawValue: 1 &lt;&lt; 1) // 0010 static let priority = ShippingOptions(rawValue: 1 &lt;&lt; 2) // 0100 static let standard = ShippingOptions(rawValue: 1 &lt;&lt; 3) // 1000 static let express: ShippingOptions = [.nextDay, .secondDay] // ?? static let all: ShippingOptions = [.express, .priority, .standard] // ??} 먼저 왜 2의 거듭제곱 값으로 표현되어야 할까? 그 이유는 위에서 언급되었듯이 단일 비트로 각각의 값을 표현할 수 있기 때문이다. (Bitmask) 12340001 // 10010 // 20100 // 41000 // 8 만일 2의 거듭제곱이 아니라면 어떻게 될까? 이에 대해서는 밑에서 얘기해보자. 처음 OptionSet을 봤을 때 가장 먼저 든 생각은 *”열거형(enum)이랑 뭐가 다른거지!?”* 였다. 그 생각을 몇몇의 글들을 읽어보면서 정리해보았다. 열거형과 OptionSet을 채택한 타입과의 가장 큰 차이점은 단일 타입 변수가 가질 수 있는 경우의 수의 차이다. 열거형 타입은 해당 타입의 케이스를 하나만 나타낼 수 있다. 하지만 OptionSet 여러 케이스를 하나의 변수로 표현할 수 있다. 열거형에서 이를 표현하려면 여러 케이스에 해당하는 열거형 타입을 배열과 같은 콜렉션 타입으로 표현해야 한다. OptionSet은 여러 케이스를 하나의 변수로 담을 수 있기 때문에 각각의 케이스는 유일해야 한다. 그리고 이를 위해 우리는 비트 값으로 이를 표현한 것이고 2의 거듭제곱으로 표현한 것도 그와 같은 이유다. 실제로 여러 케이스를 표현한다고 여러 값을 갖고 있을 필요는 없다. 위의 ShippingOptions을 살펴보자. express는 [.nextDay, .secondDay]로 표현된다. 하지만 [ShippingOptions]이 아닌 ShippingOptions 타입 변수에 할당된다. 2의 거듭제곱으로 표현되고 있다는 걸 상기시켜보면 실제로 express의 값은 .nextDay(0001)과 .secondDay(0010)을 더한 0011인 것이다. 그리고 모든 원시 값이 2의 거듭제곱이기 때문에 0011만 보아도 0001과 0010의 조합인 걸 알 수 있다. 여기서 2의 거듭제곱으로 해야 하는 이유가 나온다. 만일 2의 거듭제곱 값이 아닌 0011 , 즉 3을 원시 값으로 갖는 케이스가 있다면 .express와 구분이 되지 않기 때문이다. 또한 서버에 값을 전송할 때 리스트 형태의 값을 전달하는 것보다 이렇게 비트 마스크로 표현된 값을 보내는 것이 더 수월할 수 있다. (물론 서버 개발자와의 확실한 상호 협의가 요구되지만) 그리고 위에서 언급했듯이 OptionSet을 따르는 프로토콜은 집합 연산을 수행할 수 있다. 12345678910111213let normal: Pet = [.nextDay, .secondDay]let options2: Pet = [.nextDay, .priority, .standard]let intersection = options1.intersection(options2)print(intersection) // ShippingOptions(rawValue: 1) 👉 nextDaylet union = options1.union(options2)print(union) // ShippingOptions(rawValue: 15) 👉 nextDay, secondDay, priority &amp; standardlet subtracting = options1.subtracting(options2)print(subtracting) // ShippingOptions(rawValue: 2) 👉 secondDaylet contains = options1.contains(.standard)print(contains) // false 오늘은 이렇게 간단히 OptionSet에 대해 알아보았다. 이를 사용한다면 보다 여러 케이스를 포함하는 상황에서 보다 적은 코드로 각각의 상황에 대응할 수 있을 것 같다.","link":"/2019/03/23/OptionSet/"},{"title":"Property Wrappers in Swift","text":"Property wrapper는 프로퍼티를 정의하는 코드(code that defines a property)와 프로퍼티가 어떻게 저장되는지를 관리하는 코드(code that manages how a property is stored) 사이의 계층(layer)이다. Property wrapper를 사용하면 정의할 때 관리 코드(management code)를 한 번만 작성하고 여러 프로퍼티에 재사용할 수 있다. 사실 이런 wrapper 개념은 이번에 갑자기 나타난 것이 아니다. lazy나 @NSCopying 같은 키워드도 wrapper의 한 종류다. 하지만 Swift 5.1에선 개발자가 이런 wrapper를 직접 만들 수 있게 되었다. Property wrapper를 이해하기 위해선 Property wrapper가 어떤 문제를 해결할 수 있는지를 보면 된다. 객체 안의 프로퍼티에 값이 할당될 때마다 로그를 출력해주어야 한다고 가정해보자. 우린 다음과 같이 코드를 작성할 수 있다. 1234567891011121314struct Bar { private var _x = 0 var x: Int { get { _x } set { _x = newValue print(\"New value is \\(newValue)\") } }}var bar = Bar()bar.x = 1 // Prints 'New value is 1' 가장 직관적인 방법이다. 하지만 객체 안에 x뿐만 아니라 수많은 프로퍼티가 존재하고 이런 프로퍼티 모두가 값이 할당될 때마다 로그를 출력해주어야 한다면 상황은 달라진다. 이런 상황을 해결하기 위해 우린 새로운 타입을 정의해줄 수 있다. 123456789101112131415struct ConsoleLogged&lt;Value&gt; { private var value: Value init(wrappedValue: Value) { self.value = wrappedValue } var wrappedValue: Value { get { value } set { value = newValue print(\"New value is \\(newValue)\") } }} 그리고 기존의 Bar 구조체를 아래와 같이 ConsoleLogged 타입을 사용해 바꿀 수 있다. 1234567891011struct Bar { private var _x = ConsoleLogged&lt;Int&gt;(wrappedValue: 0) var x: Int { get { _x.wrappedValue } set { _x.wrappedValue = newValue } }}var bar = Bar()bar.x = 1 // Prints 'New value is 1' 이렇게 ConsoleLogged 타입을 사용해 중복 코드를 줄일 수 있다. Swift 5.1에선 이런 패턴을 Property wrapper라는 Syntatic Sugar로 제공한다. 사용 방법은 매우 간단하다. 기존의 ConsoleLogged에 @propertyWrapper만 붙이면 된다. @propertyWrapper를 타입(struct, class, enum) 앞에 붙이고 wrappedValue만 정의해주면 된다. 12345678910111213141516@propertyWrapperstruct ConsoleLogged&lt;Value&gt; { private var value: Value init(wrappedValue: Value) { self.value = wrappedValue } var wrappedValue: Value { get { value } set { value = newValue print(\"New value is \\(newValue)\") } }} 프로퍼티가 어떻게 저장되는지를 관리하는 코드(code that manages how a property is stored) 이렇게 선언한 Property wrapper는 사용하기도 쉽다. 아래와 같이 두 가지 방법으로 Property wrapper를 사용할 수 있다. 1234struct Bar { @ConsoleLogged var x = 0 // 1 @ConsoleLogged(wrappedValue: 2) var y // 2} 프로퍼티를 정의하는 코드(code that defines a property) Property wrapper 안에는 wrappedValue와 같이 프로퍼티뿐만 아니라 메소드도 정의할 수 있다. 하지만 안에 정의된 메소드를 사용할 땐 스코프(scope)에 주의할 필요가 있다. 123456@propertyWrapperstruct Wrapper&lt;T&gt; { var wrappedValue: T func foo() { print(\"Foo\") }} 위와 같이 Property wrapper안에 foo라는 메소드를 정의했다. 12345struct HasWrapper { @Wrapper var x = 0 func foo() { _x.foo() }} 그럼 당연히 Wrapper를 Property wrapper로 사용하는 객체 내부에선 foo 메소드를 사용할 수 있다. (_x.foo()) 12let a = HasWrapper()a._x.foo() // ❌ '_x' is inaccessible due to 'private' protection level 하지만 위와 같이 외부에서의 접근은 불가능하다. 이유는 private 수준의 접근 제어를 갖기 때문이다. 물론 외부에서 접근할 수 있는 방법은 존재한다. projectedValue를 사용하면 된다. 우리는 projectedValue를 통해 부수적인 API를 외부에 노출시킬 수 있다. wrappedValue와 다르게 projectedValue는 타입의 제한이 없다. 12345678@propertyWrapperstruct Wrapper&lt;T&gt; { var wrappedValue: T var projectedValue: Wrapper&lt;T&gt; { return self } func foo() { print(\"Foo\") }} 그리고 우리는 projectedValue를 x에 $을 붙여 접근할 수 있다. 12let a = HasWrapper()a.$x.foo() // Prints 'Foo' SwiftUI엔 @State, @Binding과 같은 빌트인 Property wrapper가 존재한다. 이에 대해선 추후 다루게 될 SwiftUI 포스팅에서 하나씩 살펴보도록 하자. 이번 포스팅에선 간단한 예로 UserDefaults를 Property wrapper를 통해 보다 간편하게 사용할 수 있는 예제를 살펴보자. 123456789@propertyWrapperstruct UserDefault&lt;T&gt; { var key: String var initialValue: T var wrappedValue: T { set { UserDefaults.standard.set(newValue, forKey: key) } get { UserDefaults.standard.object(forKey: key) as? T ?? initialValue } }} 먼저 UserDefault라는 Property wrapper를 위와 같이 정의했다. initialValue를 통해 값이 존재하지 않을 때 초기값을 제공할 수 있다. 그리고 아래와 같이 사용할 수 있다. 123456789enum UserPreferences { @UserDefault(key: \"isCheatModeEnabled\", initialValue: false) static var isCheatModeEnabled: Bool @UserDefault(key: \"highestScore\", initialValue: 10000) static var highestScore: Int @UserDefault(key: \"nickname\", initialValue: \"cloudstrife97\") static var nickname: String}UserPreferences.isCheatModeEnabled = trueUserPreferences.highestScore = 25000UserPreferences.nickname = \"squallleonhart\" 물론 Property wrapper로 선언된 프로퍼티에도 한계가 존재한다. 하위 클래스에서 오버라이딩될 수 없다. lazy, weak, @NSCopying과 같이 사용할 수 없다. 커스텀 set, get을 사용할 수 없다. 프로토콜이나 익스텐션에서 선언될 수 없다. 오늘은 Swift 5.1에 새로 추가된 Property wrapper에 대해 매우 간단히 알아보았다. 이후에는 SwiftUI에서 사용되고 있는 Property wrapper들에 대해서 소개해보려 한다. 참고 자료 The Complete Guide to Property Wrappers in Swift5 Understanding Property Wrappers in Swift By Examples Swift Docs","link":"/2020/01/03/Property-Wrappers-in-Swift/"},{"title":"RxSwift 들여다보기","text":"RxSwift 들여다보기 RxSwift를 들여다보려 한다. 이유는 간단하다. 내부 동작 원리가 궁금했다. 이 궁금증의 시작은 RxSwift의 대표적인 개념에서부터 시작했다. 정확히 말하자면 RxSwift만의 대표적인 개념이 아니라 리액티브 프로그래밍 언어들에서 볼 수 있는 대표적인 개념들이다. Observable Observer Subscription 리액티브 프로그래밍 언어에서 Observable은 이벤트 스트림을 흘려보내고 Observer는 이를 Subscription하여 이벤트에 반응하게 된다. 처음 RxSwift를 접했을 때 이 문장을 읽고 이해하는데 그렇게 오랜 시간이 걸리지 않았다. 하지만 코드를 작성하고 읽기 시작하면서 하나의 의문점이 생겼는데, 계속 공부를 하면 해결이 될까 했던 궁금증이 여전히 해결되지 않는 모습을 보였다. 그 궁금증의 주체는 바로 Observer다. 간단한 코드를 살펴보자. 123Observable&lt;String&gt;.just(\"Hello World\").subscribe(onNext: { print($0)}).disposed(by: disposeBag) 이 곳에서 위에서 언급된 대표적인 개념들을 찾아보자. Observable과 Subscription은 육안으로 확인할 수 있다. 그렇다면 Observer는 어디 있을까. 이게 내 궁금증의 시작이었다. 코드를 그대로 해석하면 Observable을 바로 Subscription하는 모습을 확인할 수 있다. *”여기서 Observer는 누구지 “* 그래서 RxSwift 소스 코드를 열어보았다. ObservableType 먼저 ObservableType부터 살펴보자. ObservableType은 프로토콜로 Observable은 ObservableType을 따른다. ObservableType을 바로 보기 전에 앞서 ObservableType+Extensions.swift 파일 안의 extension부터 시작해보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public func subscribe(onNext: ((Element) -&gt; Void)? = nil, onError: ((Swift.Error) -&gt; Void)? = nil, onCompleted: (() -&gt; Void)? = nil, onDisposed: (() -&gt; Void)? = nil) -&gt; Disposable { let disposable: Disposable if let disposed = onDisposed { disposable = Disposables.create(with: disposed) } else { disposable = Disposables.create() } #if DEBUG let synchronizationTracker = SynchronizationTracker() #endif let callStack = Hooks.recordCallStackOnError ? Hooks.customCaptureSubscriptionCallstack() : [] let observer = AnonymousObserver&lt;Element&gt; { event in #if DEBUG synchronizationTracker.register(synchronizationErrorMessage: .default) defer { synchronizationTracker.unregister() } #endif switch event { case .next(let value): onNext?(value) case .error(let error): if let onError = onError { onError(error) } else { Hooks.defaultErrorHandler(callStack, error) } disposable.dispose() case .completed: onCompleted?() disposable.dispose() } } return Disposables.create( self.asObservable().subscribe(observer), disposable )} ⁉️ 벌써 첫 번째 궁금증이 해결되었다! subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable 내부적에서 생성되고 있었다. 우리가 넘겨준 onNext, onError, onCompleted 그리고 onDisposed들이 내부적으로 어떻게 사용되고 있는지 살펴보자. 꽤나 직관적인 걸 알 수 있다. 하지만 첫 번째 궁금증이 해결된 것과 동시에 여러 궁금증들이 생겼다. 직관적이어도 정확히 어떻게 동작하는지는 이 코드만 봐서 나는 모두 알 수 없었다. 그래서 하나씩 따라 들어가 보았다. 123456if let disposed = onDisposed { disposable = Disposables.create(with: disposed)}else { disposable = Disposables.create()} 먼저 subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable 메소드에 onDisposed 클로저가 넘어왔다면 이를 이용해 Disposable을 만들고 넘어오지 않았다면 빈 Disposable을 생성한다. 12345678910111213141516171819202122let observer = AnonymousObserver&lt;Element&gt; { event in #if DEBUG synchronizationTracker.register(synchronizationErrorMessage: .default) defer { synchronizationTracker.unregister() } #endif switch event { case .next(let value): onNext?(value) case .error(let error): if let onError = onError { onError(error) } else { Hooks.defaultErrorHandler(callStack, error) } disposable.dispose() case .completed: onCompleted?() disposable.dispose() }} 여기서 생성되는 Observer는 AnonymousObsever로 생성자 함수 인자로 클로저를 받는다. 여기서 받는 클로저는 우리가 subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable 메소드의 인자로 받은 클로저들을 이벤트에 알맞게 호출해주는 행위를 정의하고 있다. 그리고 위에서 생성된 disposable을 사용하고 있는 것에 주목하자. 그럼 AnonymousObserver는 무엇이고 생성자로 전달된 클로저는 어떻게 사용되는 걸까 AnonymousObserver를 살펴보자. AnonymousObservable 12345678910111213141516171819202122final class AnonymousObserver&lt;Element&gt;: ObserverBase&lt;Element&gt; { typealias EventHandler = (Event&lt;Element&gt;) -&gt; Void private let _eventHandler : EventHandler init(_ eventHandler: @escaping EventHandler) {#if TRACE_RESOURCES _ = Resources.incrementTotal()#endif self._eventHandler = eventHandler } override func onCore(_ event: Event&lt;Element&gt;) { return self._eventHandler(event) } #if TRACE_RESOURCES deinit { _ = Resources.decrementTotal() }#endif} 먼저 AnonymousObserver는 ObserverBase 클래스를 상속받고 있다. 그리고 ObserverBase 클래스의 onCore(_:) 메소드를 오버라이딩하고 있고 그 내부에서 우리가 생성자로 넘겨준 클로저를 호출하고 있는 것을 확인할 수 있다. 그러면 이벤트가 흘러들어왔을 때 결국이 onCore(_:) 메소드가 호출되어야 우리가 넘겨준 클로저들도 호출될 텐데 onCore(_:)는 어디서 호출되는지 ObserverBase 클래스로 가보자. ObserverBase 123456789101112131415161718192021222324class ObserverBase&lt;Element&gt; : Disposable, ObserverType { private let _isStopped = AtomicInt(0) func on(_ event: Event&lt;Element&gt;) { switch event { case .next: if load(self._isStopped) == 0 { self.onCore(event) } case .error, .completed: if fetchOr(self._isStopped, 1) == 0 { self.onCore(event) } } } func onCore(_ event: Event&lt;Element&gt;) { rxAbstractMethod() } func dispose() { fetchOr(self._isStopped, 1) }} onCore(_:) 메소드는on(_:) 메소드에서 호출되는 것을 확인할 수 있다. 그럼 다시 on(_:) 메소드가 호출되는 곳을 찾아야 하는데 이는 잠시 후에 밑에서 좀 더 알아보도록 하자. 일단 on(_:) 메소드가 호출되어야 한다는 사실만 기억하고 있자. subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable 메소드 내부에서 마지막으로 살펴볼 코드는 다음과 같다. 1234return Disposables.create( self.asObservable().subscribe(observer), disposable) subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable 메소드 정의에서 볼 수 있듯이 Disposable을 반환하는데 위와 같이 생성해서 반환한다. 그럼 여기서 이제 나는 1self.asObservable().subscribe(observer) 이 코드를 먼저 살펴보려 한다. 먼저 asObservable()은 Observable.swift 파일에서 확인할 수 있다. ObservableType 프로토콜 메소드로 기본 구현되어 있는 메소드를 Observable 메소드는 아래와 같이 정의했다. 123public func asObservable() -&gt; Observable&lt;Element&gt; { return self} 프로토콜인 ObservableType이 아닌 Observable 타입을 반환하기 위한 메소드이다. 그다음으로 살펴볼 것은 바로 ObservableType.swift 파일에 정의되어있는 func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element 메소드다. 우리는 위에서 생성된 AnonymousObserver 객체를 이 메소드 안에 넣어주었다. 파일에 설명된 정의를 살펴보면 다음과 같다. 1234567891011121314151617181920Subscribes `observer` to receive events for this sequence.이 시퀀스에 대한 이벤트를 수신하기 위해선 `observer`를 구독해라.* sequences can produce zero or more elements so zero or more `Next` events can be sent to `observer`*시퀀스는 0개 혹은 그 이상의 요소들을 생산할 수 있고 그렇기 때문에 0개 혹은 그 이상의 `Next` 이벤트들은 `observer`에 전해질 수 있다.* once an `Error` or `Completed` event is sent, the sequence terminates and can't produce any other elements* `Error` 혹은 `Completed` 이벤트가 전달되면, 시퀀스는 종료되고 다른 요소를 생산할 수 없다. It is possible that events are sent from different threads, but no two events can be sent concurrently to `observer`.다른 스레드로부터 이벤트가 전달될 수 있다. 하지만 두 이벤트가 동시에 `observer`에 전달될 순 없다. When sequence sends `Complete` or `Error` event all internal resources that compute sequence elements will be freed.시퀀스가 `Complete` 혹은 `Error` 이벤트를 보내면 내부에서 시퀀스 요소들을 연산하던 자원들은 모두 자유로운 상태가 된다. To cancel production of sequence elements and free resources immediately, call `dispose` on returned subscription.시퀀스 요소 생산을 취소하고 자원을 즉시 자유롭게하고 싶다면, 반환되는 구독 객체의 `dispose` 메소드를 호출해라.returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.반환값: `observer`에 대한 구독 객체로 시퀀스 요소 생산을 취소하거나 자원을 자유롭게 하는데 사용된다. 여기서 제일 위의 설명을 살펴보자. 1이 시퀀스에 대한 이벤트를 수신하기 위해선 'observer'를 구독해라 그리고 리액티브 공식 사이트에서 설명하고 있는 Observable의 정의를 살펴보자. 12In ReactiveX an observer subscribes to an Observable. Then that observer reacts to whatever item or sequence of items the Observable emitsReactiveX에서 observer는 Observable을 구독한다. 그럼 그 observer는 Observable이 방출하는 아이템에 반응한다. 여기서 내가 이해한 것은 Observer는 Observable을 구독하고 그 구독 객체를 우리가 관찰하는 것으로 이해했다. 음.. 구독에 대한 반응을 구독하는…? 그런 느낌으로 이해하고 있는데 이에 대해 피드백을 부탁드립니다. 😭 결국 우리가 subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable을 호출하는 대상은 func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element가 반환하는 구독 객체다. Observable을 바로 구독하고 있던 것이 아니였다! 그럼 이번엔 위에서도 보았던 Disposable에 대해 조금 살펴보도록 하자. 먼저 Disposable이 subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable 안에서 여러 방식으로 생성되고 사용되고 있는 것을 확인할 수 있다. Disposable을 생성하는 방법은 몇 가지가 있다. 오늘은 위에서 확인할 수 있었던 세 가지 방법에 대해서만 살펴보도록 하자. AnonymousDisposable subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable 내부에서 살펴볼 Disposable 생성 방법 첫번째는 AnonymousDisposable이다. AnonymousDisposable.swift을 살펴보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748fileprivate final class AnonymousDisposable : DisposeBase, Cancelable { public typealias DisposeAction = () -&gt; Void private let _isDisposed = AtomicInt(0) private var _disposeAction: DisposeAction? /// - returns: Was resource disposed. public var isDisposed: Bool { return isFlagSet(self._isDisposed, 1) } /// Constructs a new disposable with the given action used for disposal. /// /// - parameter disposeAction: Disposal action which will be run upon calling `dispose`. fileprivate init(_ disposeAction: @escaping DisposeAction) { self._disposeAction = disposeAction super.init() } // Non-deprecated version of the constructor, used by `Disposables.create(with:)` fileprivate init(disposeAction: @escaping DisposeAction) { self._disposeAction = disposeAction super.init() } /// Calls the disposal action if and only if the current instance hasn't been disposed yet. /// /// After invoking disposal action, disposal action will be dereferenced. fileprivate func dispose() { if fetchOr(self._isDisposed, 1) == 0 { if let action = self._disposeAction { self._disposeAction = nil action() } } }}extension Disposables { /// Constructs a new disposable with the given action used for disposal. /// /// - parameter dispose: Disposal action which will be run upon calling `dispose`. public static func create(with dispose: @escaping () -&gt; Void) -&gt; Cancelable { return AnonymousDisposable(disposeAction: dispose) }} 가장 먼저 보이는 것은 AnonymousDisposable은 DisposeBase 클래스를 상속받고 Cancelable을 체택하고 있다는 것이다. 그리고 create(with:) -&gt; Cancelable을 보면 알 수 있듯이 Cancelable 프로토콜 타입으로 생성 결과를 반환한다. 그리고 dispose 메소드가 호출될 때 생성 인자로 받은 액션 클로저를 실행하는 것을 확인할 수 있다. AnonymousDisposable은 subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable에서 onDisposed에 인자가 넘어오면 생성된다. 즉 diposed될 때 추가적으로 해주어야 할 동작이 넘어오면 해당 동작을 실행시킬 수 있는 AnonymousDisposable을 생성하는 것이다. NopDisposable 그 다음으로 살펴볼 방법은 NopDisposable이다. 123456789101112131415161718192021fileprivate struct NopDisposable : Disposable { fileprivate static let noOp: Disposable = NopDisposable() fileprivate init() { } /// Does nothing. public func dispose() { }}extension Disposables { /** Creates a disposable that does nothing on disposal. */ static public func create() -&gt; Disposable { return NopDisposable.noOp }} 코드를 살펴보면 알 수 있듯이 어떠한 추가적인 행동을 하지 않는다. dispose 메소드 안도 비어있다. subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable에서 onDisposed가 nil일때 NopDisposable을 생성한다. 즉 어떤 추가적인 행동을 취할 필요가 없을 때 NopDisposable을 생성하는 것으로 이해할 수 있다. BinaryDisposable 마지막으로 살펴볼 방법은 BinaryDisposable을 통한 생성이다. BinaryDisposable은 두 개의 Disposable 객체를 인자로 받아 생성된다. 그리고 dispose 호출시 두 개의 Disposable의 dispose 메소드를 호출해준다. 12345678910111213141516171819202122232425262728293031323334353637383940414243private final class BinaryDisposable : DisposeBase, Cancelable { private let _isDisposed = AtomicInt(0) // state private var _disposable1: Disposable? private var _disposable2: Disposable? /// - returns: Was resource disposed. var isDisposed: Bool { return isFlagSet(self._isDisposed, 1) } /// Constructs new binary disposable from two disposables. /// /// - parameter disposable1: First disposable /// - parameter disposable2: Second disposable init(_ disposable1: Disposable, _ disposable2: Disposable) { self._disposable1 = disposable1 self._disposable2 = disposable2 super.init() } /// Calls the disposal action if and only if the current instance hasn't been disposed yet. /// /// After invoking disposal action, disposal action will be dereferenced. func dispose() { if fetchOr(self._isDisposed, 1) == 0 { self._disposable1?.dispose() self._disposable2?.dispose() self._disposable1 = nil self._disposable2 = nil } }}extension Disposables { /// Creates a disposable with the given disposables. public static func create(_ disposable1: Disposable, _ disposable2: Disposable) -&gt; Cancelable { return BinaryDisposable(disposable1, disposable2) }} subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable의 결과로 반환되는 Disposable은 BinaryDisposable이다. 그리고 이 BinaryDisposable은 onDisposed 인자값의 상태에 따라 만들어진 Disposable (AnonymousDisposable 혹은 NopDisposable)과 Observable에 대한 Observer의 구독 객체를 의미하는 Disposable로 만들어진다. Observable에 대한 Observer의 구독 객체는 우리가 Observable을 어떻게 생성하냐에 따라 다르다. 그럼 just를 통해 생성된 Observable을 예로 살펴보자. just just를 통해 생성된 Observable은 인자로 받은 단일 이벤트를 그 즉시 방출하고 바로 완료되어 Observable의 시퀀스가 종료된다. 먼저 just 메소드부터 살펴보자. 12345678910111213extension ObservableType { /** Returns an observable sequence that contains a single element. - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html) - parameter element: Single element in the resulting observable sequence. - returns: An observable sequence containing the single specified element. */ public static func just(_ element: Element) -&gt; Observable&lt;Element&gt; { return Just(element: element) }} Just 객체를 just(_:) 인자로 받은 Element로 생성하여 반환한다. 그럼 Just 정의부를 살펴보자. 12345678910111213final private class Just&lt;Element&gt;: Producer&lt;Element&gt; { private let _element: Element init(element: Element) { self._element = element } override func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element { observer.on(.next(self._element)) observer.on(.completed) return Disposables.create() }} 먼저 Just는 클래스로 Producer를 상속받는다. Producer는 Observable을 상속받는다. 여기선 이 정도만 알고 넘어가자. 끝까지 들어가니 머리가 뒤죽박죽이라 현재는 제대로 이해를 하지 못했다.😭 그리고 func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element 메소드를 오버라이딩하고 있다. just가 단일 이벤트를 방출하고 바로 종료된다는 뜻을 위의 코드를 통해 이해할 수 있을 것이다. 그리고 just는 NopDisposable을 생성한다. 그리고 Observable은 구독이 일어나기 전까지 이벤트를 방출하지 않는다는 의미를 여기서 코드로 이해할 수 있다. func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element가 호출됨에 따라 on(_:) 메소드가 호출되고 func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element 메소드는 subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable 메소드가 호출되어야 호출되는 메소드기 때문이다. 그럼 위에서 “ 일단 on(_:) 메소드가 호출되어야 한다는 사실만 기억하고 있자. “ 라고 했던 말을 여기서 확인할 수 있다. 뭔가 흐름이 잡힌 것 같으면서도 잡히지 않은 것 같은 느낌이 든다. 아직 왜 여기서 BinaryDisposable을 사용하는 이유는 잘 이해가 가질 않는다. 그래도 Observable의 생성되고 이벤트에 반응하는 것까지의 흐름을 파악할 수 있어서 유익한 시간이었다. 아직 100프로 이해하지 못한 부분들에 대해서는 추후에 계속해서 이해해보려 노력할 것이다. 참고자료 [RxSwift] Observer 나와 같이 Observer 존재에 대한 의문을 갖고 글을 작성하셨다. 덕분에 어디부터 어떻게 살펴보아야 할지 감을 잡을 수 있었다. RxSwift Disposable 역시 RxSwift의 코드를 열어보면서 코드들의 존재 이유에 대해 서술해주신 글이다.","link":"/2019/07/28/RxSwift-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0/"},{"title":"Specifying the Scenes Your App Support","text":"WWDC19에서 iOS 13이 발표되고 새로운 것들이 다수 생겼다. 바인딩을 지원하는 Combine, 선언형 UI 방식으로 UI를 구현할 수 있는 SwiftUI 프레임워크까지 많은 것들이 나왔다. 이와 함께 앱 생명주기와 관련된 새 공식 문서가 등장했는데 여기서 Scene이라는 개념이 등장한다. Managing Your App’s Life Cycle 문서를 살펴보기 전에 Specifying the Scenes Your App Support 문서를 먼저 살펴보며 Scene의 등장에 대한 이유를 이해하고자 한다. 참고로 아직은 베타 문서라 추후에 내용이 변경되거나 사용되는 클래스, 프로토콜 그리고 메소드 등의 이름이 변경될 수 있다. Overview iOS 13과 그 이상에서는 사용자가 앱 UI의 사본을 여러 개 만들어 앱 스위처 내에서 서로 전환할 수 있다. iPad에서 사용자는 또한 앱 UI의 사본과 사본을 나란히 디스플레이할 수 있다. 각각의 앱 UI 사본에 대해 Scene 객체를 사용하여 UI를 화면에 띄우는 윈도우, 뷰 그리고 뷰 컨트롤러를 관리한다. WWDC19 키노트에서는 이를 Multi-Window Capability라 설명하며 동일한 메모 앱 두 개를 나란히 실행시키는 모습을 보여주었다. 사용자가 새 Scene을 요청할 때, UIKit은 이에 해당하는 Scene 객체를 만들고 이것의 초기화 설정을 다룬다. 이를 위해 UIKit은 당신이 제공한 정보에 의존한다. 앱은 반드시 자신이 지원하는 Scene의 유형과 해당 Scene을 관리하는데 사용하는 객체를 선언해야 한다. 이 작업은 앱의 Info.plist에 정적으로 정의하거나, 런타임에 동적으로 정의할 수 있다. 중요 Scene을 앱에서 지원하는 것은 선택이지만, 앱의 UI 사본들을 동시에 보여주고 싶다면 반드시 지원해야 한다. Enable Scene Support in Your Project Settings 앱은 앱의 구성 설정을 갱신하여 Scene을 명시적으로 선택해야 한다. Xcode 프로젝트를 연다. General Settings로 이동한다. Deployment Info 섹션에서 “Support multiple windows” 체크박스를 활성화한다. 멀티플 윈도우 옵션을 활성화하면 Xcode는 앱의 Info.plist 파일에 UIApplicationSceneManifest 키를 추가한다. 이 키의 존재는 시스템에게 당신의 앱이 Scene을 지원한다는 사실을 전달한다. 이 키의 값은 딕셔너리로 초기에는 오직 UIApplicationSupportsMultipleScenes 키만 포함하고 있는 상태다. UIApplicationSupportMultipleScenes 키의 값은 당신의 앱이 실제로 동시에 여러 Scene을 지원하는지를 시스템에게 알린다. Xcode는 이 값을 기본적으로 true로 지정한다. 하지만 한 번에 하나의 Scene만 보여주고 싶으면 비활성화하면 된다. 멀티플 Scene을 지원하기 위해선 서로 다른 Scene들이 서로를 침범하지 않도록 방지하기 위한 추가 작업이 필요하다. 예를 들어 Scene에서 동일한 공유 데이터 구조를 사용하는 경우 앱 데이터 무결성을 유지하기 위해 해당 구조에 대한 접근을 조정해야 한다. Configure the Details for Each Scene UIKit은 당신이 제공한 정보를 사용해 앱의 Scene 생성을 담당한다. 가장 간단한 방법은 이 정보를 앱의 Info.plist를 사용하는 것이다. Xcode를 열고 Info.plist 파일을 선택한다. Application Scene Manifest 항목의 (+) 버튼을 누른다. 이 항목은 UIApplicationSceneManifest 키에 해당한다. 없는 경우 프로젝트 설정에서 위에서 언급한 대로 이를 추가하면 된다. 메뉴가 등장하면 Scene Configuration을 선택한다. Scene Configuration 항목에서 (+) 버튼을 클릭한다. 당신의 앱에 메인 Scene을 추가하기 위해 Application Session Role을 선택한다. 제공된 항목에 Scene의 상세 정보를 기입한다. 대부분의 앱은 오직 하나의 메인 Scene만 필요하지만 멀티플 Scene을 추가하고 각각을 다르게 구성할 수 있다. 예를 들어 알림과 관련된 컨텐츠를 보여주기 위한 두 번째 Scene을 포함시킬 수 있다. UIKit은 각 Scene에 대해 다음 정보를 필요로 한다. UIWindowScene 클래스의 이름 당신의 앱이 Scene을 관리하는데 사용하는 사용자 정의 델리게이트 객체 클래스의 이름. 이 클래스는 반드시 UIWindowSceneDelegate 프로토콜을 따라야 한다. 앱에서 Scene을 내부적으로 식별하는데 사용하는 고유한 이름 Scene의 초기 UI를 포함하는 스토리보드의 이름. .storyboard 파일 확장자를 제외한 이름을 명시한다. Scene을 구성하는데 필요한 정보 추가적인 정보는 UISceneConfigurations를 참고하라. Create the Interface for Your Scene 스토리보드를 사용해 Scene의 UI를 지정한다. UISceneStoryboardFile 키에 지정한 스토리보드는 Scene을 보여주는데 사용되는 초기 뷰 컨트롤러를 포함한다. Scene 객체를 생성하는 것 외에도 UIKit은 Scene에 대한 윈도우를 생성하고 Scene의 스토리보드에서 초기 뷰 컨트롤러 지정한다. UIWindowSceneDelegate 객체의 메소드를 사용해서 코드로 이 뷰 컨트롤러를 교체할 수 있다. 중요 스토리보드의 초기 뷰 컨트롤러를 지정하는 것을 잊지 말아야 한다. UIKit는 UI를 구성할 때 이 뷰 컨트롤러의 존재에 의존한다. Change Your Scene’s Configuration Dynamically 실제로 Scene 객체를 생성하기 전에 UIKit은 앱 델리게이트의 메소드인 application(_:configurationForConnecting:options:)를 호출하여 당신이 Scene과 연관된 상세 정보를 수정할 수 있도록 한다. 이 방법을 사용하여 UIKit에서 제공하는 옵션에 따라 Scene 구성을 조정할 수 있다. 예를 들어 시스템이 Scene에 알림 응답(Notification response)을 전달할 때 알림과 연관된 인터페이스와 함께 다른 스토리보드를 지정할 수 있다. 동적으로 Scene 구성을 구현하지 않으면 UIKit은 Scene을 생성하는데 Info.plist의 정보를 사용한다. Adopt Scene-Based Life-Cycle Semantices Scene에 대한 지원을 추가하면 앱이 생명 주기 이벤트에 대응하는 방식이 변경된다. Scene을 사용하지 않는 앱에선 앱 델리게이트 객체가 포그라운드 혹은 백그라운드로의 전환을 담당한다. 앱에서 Scene을 지원하게 되면 UIKit은 이러한 책임을 당신이 지정한 Scene 델리게이트 객체에 위임한다. Scene 생명 주기는 다른 Scene에 독립적이고, 앱 자체와도 독립적이다. 그러므로 당신이 지정한 Scene 델리게이트 객체가 이러한 전환을 담당해야 한다. 만일 앱이 iOS 12를 지원한다면 앱 델리게이트와 Scene 델리게이트 객체 모두에서 생명 주기 전환을 처리할 수 있다. UIKit은 오로지 하나의 델리게이트 객체에만 생명 주기 관련 이벤트 알림을 보낸다. iOS 13 이상에선 UIKit은 Scene 델리게이트 객체에 알림을 보내고, iOS 12 이하에선 UIKit은 앱 델리게이트에 해당 알림을 보낸다. 생명 주기 이벤트를 어떻게 다루는지에 대한 추가적인 정보는 Managing Your App’s Life Cycle를 참고하라.","link":"/2019/06/06/Specifying-the-Scenes-Your-App-Support/"},{"title":"SwiftUI Essentials (1)","text":"Views and modifiersView들은 UI를 구성하는 가장 기본적인 블록이다. UIKit의 UIView나 AppKit의 NSView와 같이 UI를 구성하는 기본적인 단위라고 할 수 있다. 다음 앱의 UI를 계층 구조로 살펴보자. 이 계층을 SwiftUI로 작성하면 다음과 같다. SwiftUI는 이러한 뷰의 계층을 코드로 표현한다. 왼쪽의 코드 구조는 오른쪽의 뷰 계층 구조와 상당히 흡사한 것을 확인할 수 있다. 또한 코드에서 살펴볼 수 있듯이 뷰 계층을 표현하는데 addSubview와 같은 메소드를 사용하지 않는다. SwiftUI는 하나의 계층 구조를 각 뷰 조각들로 구성하는 것이 아니라 계층 전체를 하나의 완전한 구조로 생성한다. 왜냐하면 SwiftUI는 뷰를 명령형(imperatively)과 반대인 선언형(declaratively)으로 정의하고 있기 때문이다. 명령형과 선언형의 차이점을 살펴보자. 명령형 코드 : 명시적인 명령(explicit commands)을 통해 결과를 구성 선언형 코드 : 묘사(describing) 통해 결과를 구성. 단 이를 어떻게 생성할지는 다른 주체에 의해 결정 둘의 차이가 정의로만은 부족할 수 있다. 상황을 예를 들어 둘의 차이를 살펴보자. 명령형 코드는 친구에게 아보카도 토스트를 만드는 방법을 알려주는 것과 같다. 선언형 코드는 아보카도 토스트를 만드는 요리사에게 토스트 주문을 하는 것과 같다. 친구에게 토스트 만드는 방법을 설명할 때는 7. 아보카도의 중심을 제거해라.와 같이 내가 직접 단계별로 필요한 결과를 전달한다. 반면, 요리사에게는 내가 원하는 토스트의 모습을 묘사하여 전달하고 그것을 어떻게 만드는지는 전적으로 요리사의 몫이다. 그리고 요리사가 전문가라면 우리는 항상 최상의 품질을 보장받을 수 있다. 이 두 상황을 통해 명령형 코드와 선언형 코드의 차이점을 보다 쉽게 이해할 수 있었다. SwiftUI가 요리사의 역할을 하는 것이다. 그럼 이제 SwiftUI의 요소들을 하나씩 살펴보자. View Container Syntax뷰 컨테이너는 여러 다른 컨텐트 뷰(Content View)들로 구성되어 있다. 뷰 컨테이너에는 VStack, HStack 등이 존재한다. 뷰 컨테이너의 일반적인 문법은 다음과 같다. VStack을 다음과 같이 사용할 수 있는 것과 같다. 12345VStack { Imgae(...) Text(...) Text(...)} Image, Text와 같은 컨텐트 뷰들은 뷰 빌더(View Builder)라는 클로저 안에 나열된다. 그리고 뷰 컨테이너의 생성자는 이 뷰 빌더 클로저를 인자로 받는다. addSubview와 같은 함수를 호출하는 대신 이 클로저 블록 안에 원하는 뷰를 순서대로 나열만 해주면 된다. 실제로 뷰 빌더가 내부적으로 어떻게 동작하는지 확인하기 위해 VStack API를 살펴보자. 생성자 인자 중 content에 @ViewBuilder 속성(attribute)이 붙어있는 것을 확인할 수 있다. 스위프트 컴파일러는 @ViewBuilder 속성이 붙어 있으면 해당 클로저를 우리가 나열한 컨텐트 뷰들이 포함된 단일 뷰를 반환하는 클로저로 변환한다. 이런 특수한 클로저를 뷰 컨테이너의 생성자에 전달해줌으로써 뷰 컨테이너와 컨텐트 뷰들은 들여 쓰기로 자연스레 구분될 수 있다. 또한 VStack은 alignment나 spacing과 같은 인자를 추가로 받아 정렬이나 간격을 조정해줄 수 있다. SwiftUI에서 VStack, HStack과 같이 컨트롤(Control)도 뷰 컨테이너의 종류로 다른 뷰를 컨텐트 뷰로 포함할 수 있다. Control에는 Button, Toggle Slider 등이 있다. 위의 코드에서처럼 Text뿐만 아니라 다른 뷰도 컨텐트 뷰로 포함할 수 있다. 컨트롤은 사용자와 상호작용할 수 있는 요소들을 말한다. 공식 문서를 통해 컨트롤에 어떤 것들이 있는지 알 수 있다. 컨트롤과 뷰 컨테이너는 추후에 더 자세히 살펴보도록 하고 이젠 $ 싸인에 주목해보자. Binding SyntaxStepper를 선언하는 코드를 살펴보자. order.quantity를 넘기는데 $ 싸인이 앞에 붙었다. 이는 단순히. order.quantity 값을 넘기는 것이 아닌 바인딩을 넘기는 것이다. 그럼 여기서 말하는 바인딩이란 뭘까? 영상의 예제 앱에서 Stepper는 OrderForm이란 뷰에 포함되어 있다. OrderForm은 현재 순서를 추적하기 위해 Order 타입에 의존하고 있다. 이 프로퍼티를 살펴보면 @State란 속성이 붙어있는 것을 확인할 수 있다. @State 속성이 붙어있으면 SwiftUI는 이를 보고 내부적으로 지속성 있는 상태(persistent state)를 생성하고 관리하며 상태의 값을 이 프로퍼티를 통해 접근하도록 한다. 우린 이 프로터티에 접근해 상태의 값을 읽거나 쓸 수 있다. 1Text(\"Quantity: \\(order.quantity)\") Stepper는 정적인 뷰가 아닌 컨트롤이다. 그 말은 사용자가 Stepper의 버튼을 누르면 그 상태가 변경될 수 있다는 의미다. 이를 위해선 단순히 읽기 전용인 값을 전달하는 것이 아니라 바인딩을 전달해야 한다. 바인딩은 일종의 관리되는 참조(managed reference)로 이를 통해 하나의 뷰가 다른 뷰의 상태를 변경할 수 있다. 이 예제에선 Stepper가 OrderForm의 상태를 $order.quantity를 통해 변경하고 있는 것이다. SwiftUI에서의 데이터 흐름에 대한 자세한 내용은 Data Flow Through SwiftUI 영상을 참고하자. 다시 예제 앱으로 돌아와 우리가 아직 살펴보지 못한 문법을 살펴보자. Modifier Text(&quot;Avocado Toast&quot;)에서 우린 font(.title)과 같은 메소드를 호출할 수 있다. 이 메소드가 하는 작업은 간단하다. 호출한 뷰로부터 새 뷰를 만들어내는 것이다. SwiftUI에서 이런 메소드를 변경자(Modifier)라 부른다. 이런 변경자에 의해 뷰 계층이 어떻게 변경되는지 살펴보자. Text(&quot;Avocado Toast&quot;)을 포함하는 VStack은 다음과 같은 계층 구조를 가진다. 하지만 여기에 font(.title) 변경자를 적용하면 뷰 계층은 다음과 같이 변경된다. 이렇게 변경자로 생성된 뷰는 기존의 뷰를 감싸고 뷰 계층에 포함된다. 이런 변경자는 다수의 변경자들과 함께 체이닝될 수 있다. 이렇게 변경자를 추가하게 되면 계층 구조는 빠른 속도로 비대해진다. 우리는 이전까지 이렇게 뷰 계층이 비대해지면 성능 이슈에 대해서 고민하곤 했다. 기존의 뷰 계층은 최대한 작고 가벼워야 했다. 하지만 SwiftUI는 이러한 부분에 대한 걱정을 덜어도 된다. 위에서 언급했듯이 우리는 선언형 코드를 작성한다. 우리는 단지 원하는 모습을 묘사할 뿐이고, SwiftUI가 이를 최적화한다. 우리가 아무리 많은 변경자를 사용해 Text를 여러 뷰로 감싸도 SwiftUI가 이를 보다 효율적인 자료구조로 최적화한다. 그리고 이렇게 최적화된 자료구조는 렌더링 시스템이 렌더링 하는데 사용한다. 이렇게 변경자 체이닝 문법은 성능 이슈에 대해 걱정할 필요 없이 많은 이점을 제공한다. 그중 하나로 변경자 체이닝은 시각적 요소의 직관적인 순서를 강제한다. 즉 체이닝에 참여하는 변경자의 순서에 따라 최종 렌더링 되는 모습이 달라진다는 것이다. 만약 이런 속성들을 변경자 체이닝으로 변경하는 것이 아닌 Text의 내부에 포함된 속성이라고 가정해보자. 우린 시행착오와 문서 없이는 각각의 속성들이 어떤 순서로 적용되는지 알 수 없을 것이다. 이런 속성들을 변경자를 통해 적용함으로써 우린 순서를 명시적으로 지정할 수 있다. 또한 이런 변경자들은 여러 뷰들에서 공유될 수 있다. 이렇게 변경자를 공유함으로써 각각의 뷰들은 보다 단순해질 수 있고 자신들만의 인터페이스에 집중할 수 있다. 이것이 SwiftUI의 기본 원칙이다. 더 작고 단일 목적의 뷰라는 원칙을 따름으로써 우리는 보다 이해하기 쉽고, 유지 보수가 쉬운 뷰를 만들 수 있다. 재사용성 역시 증가한다. 그리고 이렇게 각자의 역할별로 작게 나누어진 뷰들을 통해 보다 큰 뷰를 효과적으로 구성할 수 있다.","link":"/2019/12/21/SwiftUI-Essentials-1/"},{"title":"SwiftUI Essentials (2)","text":"Building custom viewsSwiftUI로 커스텀 뷰를 만드는 방식에 대해 이야기 해보자. 주문 내역을 보여주는 OrderHistory를 살펴보자. 위의 코드에서 먼저 살펴볼 부분은 바로 View 프로토콜을 따르고 있는 OrderHistory가 구조체로 선언되어 있다는 점이다. 일반적으로 UIKit으로 뷰를 만들면 프로토콜을 따르는 구조체가 아닌 공통 부모 클래스로부터 상속받는 클래스를 작성하곤 한다. OrderHistory를 UIKit으로 만든다면 다음과 같은 상속 관계를 가질 것이다. UIView는 alpha나 backgroundColor 같은 공통된 저장 프로퍼티(stored property)를 갖고 있다. OrderHistory는 자신의 previousOrders 프로퍼티와 더불어 부모 클래스의 프로퍼티까지 갖고 있게 된다. 반면에 SwiftUI는 어떨까? SwiftUI는 이런 공통된 저장 프로퍼티를 분리된 변경자로 관리하고 각각의 변경자는 자신들만의 뷰를 생성하게 된다. 그러므로 공통된 저장 프로퍼티는 뷰 계층 전반에 걸쳐 분산된다. 이러한 방식으로 뷰를 더 가볍게 해서 각 뷰의 고유 목적에 맞게 최적화한다. 이러한 방식 때문에 SwiftUI에서 뷰가 프로토콜이 된다고 할 수 있는 것이다. 그럼 뷰는 무엇을 하는 것일까? 뷰는 단지 UI의 한 조각을 정의할 뿐이고 우린 이런 뷰들을 이용하고 재사용하여 뷰 계층을 구성하는 것이다. View 프로토콜의 살펴보자. 위의 코드를 보고 있으면 어떤 생각이 드는가? 재귀적이지 않은가? 하나의 뷰가 있고 그 뷰의 body가 다른 뷰를 나타내고 그 뷰의 body가 또 다른 뷰를 나타내는 이런 구조를 보일 수 있다고 생각할 수 있는데 이는 지속되지 않는다. 그 이유는 SwiftUI가 스스로 컨텐츠를 갖지 않고 다른 뷰를 구성하는 아토믹(atomic)한 뷰인 원시 뷰(primitive view)를 제공하고 위와 같은 body 사슬의 끝은 결국 이런 원시 뷰이기 때문이다. 우리가 위에서 보았던 Text나 Image와 더불어 드로잉에 사용되는 Color와 Shape, 레이아웃에 사용되는 Spacer와 같은 다양한 원시 뷰를 제공한다. 다시 OrderHistory로 돌아와 클래스가 아닌 구조체로 정의된 것에 주목해보자. 클래스로 정의한 것이 아니기 때문에 OrderHistory는 더 이상 이벤트 기반으로 동작하는 명령형 코드로 갱신되는 영구적인 객체가 아니다. 대신 뷰는 Input에 따라 결과가 달라지는 함수와 같이 선언형 코드로 정의된다. 이 말은 Input이 변경되면 SwiftUI가 body 프로퍼티를 다시 호출해서 뷰를 갱신한다. 만일 이벤트 기반의 명령형 코드였다면 Input의 변경(삭제, 삽입 등)에 따른 갱신 코드를 작성해주어야 했는데, SwiftUI에서는 선언형 코드로 인풋이 변경되면 SwiftUI가 내부적으로 이전 데이터와 새 데이터를 비교해서 무엇이 변경되었는지를 비교 후 효율적으로 뷰를 갱신하게 된다. OrderHistory 코드를 계속해서 살펴보자. 조건에 따라 뷰의 유무를 표시할 때 우리는 다음과 같이 뷰 빌더 클로저 안에 조건문을 통해 이를 구현할 수 있다. 하지만 이런 조건문도 상황에 따라 제대로 사용해야 한다. 다음 상황의 코드를 살펴보자. flipped 값에 따라 아이콘의 각도를 다르게 보여주고 싶을 때 위와 같이 작성할 수 있다. 하지만 이는 잘못된 방법이다. 이런 코드는 부자연스러운 애니메이션을 만들게 된다. 이 코드는 SwiftUI에게 서로 다른 뷰 중 하나를 선택하게 하는 것이고 이는 곧 뷰의 추가와 삭제를 의미한다. 뷰의 추가와 삭제는 fade 애니메이션이 적용되기에 부자연스러운 애니메이션을 보게 되는 것이다. 우리가 원하는 자연스러운 애니메이션을 위해선 다음과 같이 코드를 작성해야 한다. 여기서 얻을 수 있는 교훈은 이런 조건에 따라 다른 값에 의한 뷰의 변화를 부드러운 애니메이션을 통해 제공하기 위해선 최대한 이를 변경자 내부에 위치시켜 SwiftUI가 변화를 감지하여 보다 부드러운 애니메이션을 제공하도록 해야 한다는 것이다. 또한 비대해진 OrderHistory를 우린 더 작은 뷰로 나누어 관리할 수도 있다. 만일 OrderHistory에 조건에 따라 또 다른 뷰가 추가되어야 한다면 코드를 어떻게 작성해야할까 위와 같은 방법은 확장성이 매우 떨어진다. 우리는 이런 상황에서 ForEach 뷰를 사용할 수 있다. ForEach는 하나의 뷰로 List와 마찬가지로 콜렉션 데이터 타입을 인자로 받는다. 그리고 뷰 빌더 클로저 안에 뷰를 나열하는데 이때 나열된 뷰는 ForEach에 추가되지 않고 ForEach의 상위 뷰에 추가된다. 지금까지 작성된 코드들을 보면 우리가 직접 작성하지 않고도 SwiftUI가 스스로 그리고 반응하며 갱신하는 것을 확인할 수 있었다. 이것이 바로 선언형 코드의 장점이라 할 수 있다. Composing Controls아보카도 토스트 주문을 넣는 화면을 다시 살펴보자. 이는 우리가 알고 있는 화면과 많이 다르다. 정확히 말하자면 정형화되지 않은 상태다. 이 뷰를 아래와 같이 우리가 익숙한 형태의 뷰로 변경해보자. 둘의 가장 큰 차이점은 컨테이너가 다르다는 것이다. 기존 뷰(왼쪽)의 컨테이너가 VStack이라면 우리가 익숙한 오른쪽 뷰의 컨테이너는 Form이다. Form 역시 뷰 컨테이너의 한 종류다. VStack과의 차이점에는 헤더, 섹션 등이 있어 보다 정형화된 그룹 스타일의 UI를 보다 쉽게 만들 수 있다. 그리고 이렇게 컨테이너가 바뀜에 따라 그 안에 속하는 컨트롤(버튼, 토글 등)도 그 모습이나 속성이 컨테이너에 따라 변한다. 또한 Form을 사용하면 서로 다른 플랫폼에서 다양한 룩앤필(Look and Feel)을 제공할 수 있다. 이렇게 SwiftUI가 UI를 그리기 때문에 우리는 기능에 보다 집중할 수 있다. 위의 화면에서 Button을 예로 들면 뷰 컨테이너가 바뀌면서 Button의 padding, alignment 등이 바뀐 것을 확인할 수 있다. 이번엔 Button 코드를 살펴보자. 위의 단일 코드로 여러 플랫폼에서 다양한 룩앤필을 제공할 수 있다. Button은 눌렸을 때 액션을 인자로 넣어주고 버튼의 상태와 목적을 나타내는 label을 뷰 빌더 클로저를 통해 제공해줄 수 있다. 그리고 앞에서 봐왔듯이 여러 변경자들을 통해 보다 쉽게 커스터마이징을 할 수 있다. 이를 통해 우리는 다양한 플랫폼의 다양한 버튼을 사용자에게 제공해줄 수 있다. 그렇기 때문에 SwiftUI에서 컨트롤은 적응형(adaptive) 컨트롤이라 할 수 있다. 적응형 컨트롤은 다음과 같은 특성을 갖는다. 컨트롤은 그 자체로 모양이 아닌 역할을 나타낸다. 이렇게 컨트롤이 역할을 의미하기 때문에 여러 플랫폼에 거쳐 재사용될 수 있는 것이다. 이렇게 컨트롤들은 역할이 있고 이런 역할은 목적에 의해 생겨나기 때문에 Toggle이나 Button들은 그들 각자의 목적이 존재한다. 그리고 이들은 사람이 읽을 수 있는 레이블을 포함하기 때문에 기본적으로 VoiceOver 기능을 지원한다. 그리고 레이블이 Text가 아니라 Image어도 Image에 설명을 위한 Text를 함께 제공하여 VoiceOver 기능을 제공할 수 있다. 또한 커스텀 뷰는 accessbility 변경자를 통해 이런 기능을 제공할 수 있다. 이렇게 컨트롤은 플랫폼에 따라 모양은 다를 수 있지만 본연의 목적을 수행하는 데 이는 SwiftUI의 핵심이라고 할 수 있다. SwiftUI는 한 번만 작성하고 어디에서나 실행할 수 있는 수단 일뿐만 아니라 이러한 핵심 개념을 배우고 다양한 컨텍스트와 플랫폼에서 사용할 수 있는 프레임 워크다. 그리고 우리가 뷰에서처럼 컨트롤에서도 변경자를 사용할 수 있다. 그리고 이는 뷰에서와 동일한 특성을 갖는다. 예를 들어 다음과 같이 컨트롤 계층 전반에 걸쳐 변경자를 공유할 수 있다. 다음으로 살펴볼 것은 환경(Environment)이다. 이는 일종의 모든 뷰에서 접근할 수 있는 특성의 집합으로 볼 수 있다. 그리고 자식 뷰는 부모 뷰의 환경 특성을 상속 받는다. 물론 필요에 따라 자식 뷰에서 이를 오버라이딩할 수 있다. 그리고 이 환경은 프리뷰에서 유용하게 사용되는데, 동일한 UI를 여러 문맥에 따라 다르게 보여주는 기능을 제공한다. 이를 통해 환경, 문맥에 따라 UI가 어떻게 바뀌는지 쉽게 확인할 수 있다. Navigating your appiOS에선 기본적으로 NavigationView를 통해 기본 내비게이션 스타일을 사용할 수 있으며 navigationBarTitle 변경자를 통해 타이틀을 지정할 수 있다. navigationBarTitle은 다른 변경자와 같이 아래를 향하지 않고 위를 향하는 특성을 갖는다. OrderForm에 변경자를 적용했지만, NavigationView에 반영된다는 것을 의미한다. 그리고 NavigationButton를 목적지와 함께 만들어 실질적인 화면 전환을 구현할 수 있다. TabbedView를 통해 성격이 다른 두 뷰를 탭 뷰로 묶어 관리할 수도 있다.","link":"/2019/12/26/SwiftUI-Essentials-2/"},{"title":"SwiftUI under the hood","text":"요즘 SwiftUI를 공부하면서 느낀 점은 마냥 쉽지만은 않다는 것이다. 흔히 SwiftUI를 소개할 때 매우 쉽게 UI를 그릴 수 있는 프레임워크로 소개하곤 하는데, 완전히 틀린 말은 아니지만 그렇다고 완전히 맞는 말도 아닌 것 같다. SwiftUI를 공부하면서 처음 iOS를 공부했을 때, 더 나아가 처음 프로그래밍을 공부했을 때가 종종 생각나곤 한다. 당시 처음으로 프로그래밍 언어를 가르쳐 주신 강사님으로부터 기본적인 C 언어 문법을 배우고 모든 걸 배운 것처럼 기세등등했던 적이 있다. 자신감이 한없이 하늘을 찌르고 있을 때 강사님은 다음과 같은 말씀을 해주셨다. *”원래 처음 프로그래밍을 배우고 기본 문법을 마친 사람들이 프로그래밍을 매우 쉽다고 생각하고 자만하게 됩니다. 하지만 공부를 하면 할수록 어렵게 느껴지고 자신감이 떨어질 수 있는 공부가 프로그래밍입니다.”* 비단 프로그래밍에만 국한되는 이야기는 아닌 것 같다. 당시에는 이해가 가질 않았으나, 본격적으로 학부 공부를 시작하고 취업 준비를 하면서 저 말이 계속해서 떠올랐고 자신감이 자주 떨어지곤 했다. SwiftUI를 공부하면서도 마찬가지였다. 처음 VStack, List 등을 사용하면서 그 간편함에 놀라고 매우 쉽다고 생각했다. 하지만 데이터의 흐름과 레이아웃이 결정되는 방식 등 깊게 파고들면 파고들수록 머릿속은 여러 개념들이 완전하지 않은 채 뒤엉키게 되었다. 그렇게 혼란스러워하던 중 한 컨퍼런스에서 Chris Eidhof가 “SwiftUI under the hood”란 주제로 발표한 영상을 보고 복잡하고 산발되어 있던 개념들이 어느 정도 정리가 되면서 여러 개념들의 존재 이유와 목적에 대해 감을 잡을 수 있었다. 오늘은 그 영상의 내용을 요약 및 정리해보는 시간을 가지려 한다. 영상 : Chris Eidhof - SwiftUI under the hood 영상에서 다루는 큰 주제는 레이아웃 알고리즘이다. 즉 SwiftUI가 어떤 방식으로 레이아웃을 그리는지에 대해 다룬다. 이를 설명하면서 GeometryReader, Preference 등 중요한 개념들이 자연스럽게 등장하며 설명을 돕는다. 서론이 너무 길었다. 바로 시작해보자. Layout Algorithm파란색 배경의 원 안에 텍스트가 존재하는 뷰를 만든다고 상상해보자. 원이 아닌 다양한 도형이 될 수 있다. 즉 매우 흔한 상황이다. 우리가 원하는 결과물은 다음과 같을 것이다. 매우 쉬워 보인다! 그럼 코드로 이를 만들어보자. 12345Text(\"Reset\") .background( Circle() .fill(Color.blue) ) 기대하던 모습이 나올까? 그렇지 않다. 그 모습은 우리가 기대하던 모습과 거리가 멀다. 이유가 무엇일까? 그 이유를 알기 위해선 SwiftUI의 레이아웃 알고리즘에 대한 이해가 있어야 한다. 모든 레이아웃은 다음 4가지 단계를 통해 그려진다. 컨테이너 뷰(직계 상위 뷰)가 사이즈를 제안한다. 하위 뷰가 자신의 사이즈를 결정한다. (하위 뷰는 상위 뷰가 제안한 사이즈를 그대로 사용하거나, 본인이 자신의 사이즈를 결정하기도 한다.) 하위 뷰가 컨테이너 뷰에 자신의 사이즈를 알린다. (2단계에서 결정된 사이즈로 컨테이너 뷰의 사이즈가 정해진다.) 컨테이너 뷰가 하위 뷰를 가운데 정렬 시킨다. (alignment) 이는 아주 기본적인 절차이고 여러 값들의 재정의를 통해 변경될 수 있다. 그럼 이 알고리즘을 바탕으로 위의 코드를 분석해보자. 먼저 위의 코드로 그려진 뷰의 계층을 뷰 디버깅을 통해 살펴보고 아래 설명을 따라가면서 이해해보자. 먼저 루트 뷰(root view)가 화면 전체 사이즈를 background에게 제안한다. 그리고 background는 이를 다시 Text에게 전달한다. Modifier는 새로운 뷰를 만들고 이전 뷰를 감싸서 반환한다는 것을 기억한다면 background가 Text를 감싸고 있다는 것을 이해할 수 있다. 하지만 Text는 자신이 담고 있는 내용만큼만 필요하기 때문에 &quot;Reset&quot;만큼만 사용할 것을 backgroud에 알린다. 그럼 다시 background는 이를 하위 뷰인 ShapeView에 알리고 ShapeView는 이를 Circle에게 알린다. (ShapeView와 Text는 형제-자매(sibling) 관계다.) Circle는 받은 크기(Text의 크기)를 그대로 사용해서 그 크기에 딱 맞는 원을 그린다. 그리고 이를 background에게 전달하고 background는 다시 이 크기를 루트 뷰에 전달하고 루트 뷰는 해당 뷰를 가운데 정렬한다. 뷰 계층과 알고리즘을 따라가보면 왜 우리가 원하는 레이아웃이 나오지 않았는지에 대해 이해할 수 있다. 그럼 우리가 원하는 레이아웃을 그리기 위해선 어떻게 해야 할까? 가장 먼저 떠오르는 생각은 frame 변경자를 사용하는 것이다. 사용하기에 앞서 frame 변경자의 특징을 알아야 한다. frame 변경자는 상위 뷰에서 오는 크기 정보나, 하위 뷰에서 알려주는 크기 정보를 모두 무시하고 자신의 인자로 넘어온 크기 정보만 사용한다. 이 점을 기억하고 아래 코드를 살펴보자. 12345678Text(\"Reset\")//.frame(width: 75, height: 75) // --- 1 .background( Circle() .fill(Color.blue)// .frame(width: 75, height: 75) // --- 2 )//.frame(width: 75, height: 75) // --- 3 frame 연산자를 1, 2번 두 곳 중 한 곳에만 위치시켜도 원하는 레이아웃을 그릴 수 있다. 하지만 두 곳 모두 문제점을 갖고 있다. 위에서 언급했듯이 frame은 하위 뷰에서 알려준 크기 정보도 무시한다. 즉 Text가 정한 크기도 무시한다는 뜻이다. 그렇기 때문에 이곳에 frame을 위치시면 길어진 문자열 크기를 Text가 아무리 frame에 알려도 frame은 자신의 정보로 크기를 결정하기 때문에 문자열은 75x75 영역 안에서 벗어날 수 없고, 해당 영역 안에 표시되지 못한 부분은 말 줄임표(...)로 나타나게 된다. frame 영역은 Circle에만 영향을 주기 때문에 문자열이 길어지면 원의 영역을 벗어난다. frame을 3번에 위치시키면 어떻게 될까? frame이 이 크기 정보(75x75)를 background에게 background가 다시 Text에 전달하지만 Text는 자신이 담고 있는 내용만큼만 사용한다고 background에 알리고 background는 이 정보를 다시 Circle에 전달하기 때문에 결과적으로 위에서 봤던 레이아웃과 동일한 것을 육안으로 확인할 수 있다. 육안으로 확인한 레이아웃이 같다고 실제로 그 둘이 같은 것은 아니다. 전체를 감싸고 있는 뷰의 크기 차이가 존재한다(파란 테두리가 감싸고 있는 영역). 그 이유는 위에서 언급했듯이 frame은 하위 뷰에서 보낸 정보도 무시하기 때문에 자신의 크기 정보(75x75)를 사용한다. 그렇기 때문에 전체를 감싸고 있는 뷰의 크기에 차이가 생기는 것이다. 문제를 해결하기 위해선 frame 안에 들어갈 값은 문자열의 길이에 따라 동적으로 변경되어야 한다. 정확히는 Text의 크기에 따라 변경되어야 한다. 그럼 Text의 크기는 어떻게 알 수 있을까? UIKit을 사용할 땐 객체에 직접 접근해 값을 가져올 수 있었다. 하지만 SwiftUI에선 불가능하다. 우리는 이 문제점을 GeometryReader를 사용해 해결해보려 한다. GeometryReaderGeometryReader는 SwiftUI에서 중요한 개념이지만 이번 포스팅에선 현재 상황에서 GeometryReader가 해결할 수 있는 부분에 대해서만 간단하게 설명해보고자 한다. GeometryReader는 컨테이너 뷰의 한 종류로 자신의 직계 상위 뷰의 기하학(Geometry) 정보(좌표, 크기 등)를 자신이 포함하는 자식 뷰에게 제공하는 역할을 한다. 그럼 바로 사용해보자. 12345678910111213Text(\"Reset\") .padding() .fixedSize() .background( GeometryReader { proxy in // proxy.size.width == Text(\"Reset\")'s width } ) .frame(width: 75, height: 75) .background( Circle() .fill(Color.blue) ) fixedSize 변경자는 Text에만 존재하는 변경자로 아무리 문자열이 길어져도 1줄에 보여주도록 강제한다. 이를 사용하면 위에서 보았던 이미지처럼 주어진 크기 안에서 문자열이 길어질 때 여러 줄과 함께 말 줄임표로 보여주는 것이 아니라 영역을 벗어나더라도 문자열을 1줄에 보여줄 수 있다. 단순히 직계 상위 뷰의 정보를 받아온다고 생각하지 말고 위에서 살펴보았던 레이아웃 결정 과정을 대입해서 생각해보자. background는 루트 뷰로부터 크기를 제안받는다. background는 그 크기를 Text에게 제안한다. Text는 자신이 포함하는 내용만을 담을 수 있는 크기를 사용하기로 결정하고 이를 background에게 알린다. background는 그 정보를 GeometryReader에게 알린다. 이런 순서로 GeometryReader는 직계 상위 뷰의 정보를 받아올 수 있는 것이다. 정확히 표현하자면 Text에 의해 결정된 크기를 사용하는 background의 크기 정보를 받아온 것이다. 그럼 우린 이 크기 정보를 사용하면 된다. 123456789101112131415@State private var width: CGFloat? = nilText(\"Reset\") .padding() .fixedSize() .background( GeometryReader { proxy in self.width = proxy.size.width } ) .frame(width: self.width, height: self.width) .background( Circle() .fill(Color.blue) ) 위와 같이 코드를 작성할 수 있을 것 같지만 실제로 이렇게 작성하면 에러가 발생한다. 왜냐하면 GeometryReader는 생성자로 @ViewBuilder를 받기 때문에 self.width = proxy.size.width와 같은 코드는 @ViewBuilder 안에 작성할 수 없다. 우린 이 시점에서 프록시(GeometryProxy)에 담긴 크기 정보를 바로 width 프로퍼티에 할당할 수 없다. 우린 이 정보를 뷰 계층 위로 전달해야 한다. 이렇게 하위 뷰에서 상위 뷰로 정보를 전달하기 위해서 사용하는 것이 바로 Preference다. PreferencePreference 역시 GeometryReader와 마찬가지로 굉장히 중요한 개념 중 하나이다. 하지만 마찬가지로 현재 상황에서 Preference가 해결할 수 있는 부분에 대해서만 간단하게 설명해보고자 한다. Preference는 키-밸류 메커니즘으로 하위 뷰 정보를 상위 뷰에 전달할 수 있는 수단이다. 이를 위해선 먼저 PreferenceKey 프로토콜을 따르는 키를 정의해주어야 한다. 12345struct SizeKey: PreferenceKey { static func reduce(value: inout CGFloat?, nextValue: () -&gt; CGFloat?) { value = nextValue() }} 간단하게 설명하자면 reduce 메소드는 SizeKey를 사용하는 하위 뷰들을 순회하면서 상위 뷰가 접근할 수 있는 값을 만들기 위해 이들의 값(SizeKey를 사용하는 하위 뷰의 값) 취합하는 역할을 한다. 이번 포스팅에선 단순히 PreferenceKey의 기능만을 소개하지만 추후 포스팅에서 더욱 자세히 다룰 예정이다. 하지만 당장 궁금하다면 이 글을 참고하면 좋을 것이다. 그리고 간단한 트릭(?)을 사용해서 우린 뷰 계층 위로 proxy 정보를 전달할 수 있다. 12345678910111213141516171819202122struct ContentView: View { @State private var width: CGFloat? = nil var body: some View { Text(\"Reset\") .padding() .fixedSize() .background( GeometryReader { proxy in Color.clear.preference(key: SizeKey.self, value: proxy.size.width) // --- 1 } ) .frame(width: self.width, height: self.width) .background( Circle() .fill(Color.blue) ) .onPreferenceChange(SizeKey.self) { value in // --- 2 self.width = value } }} Color도 View 프로토콜을 따른다. 그렇기 때문에 사용자는 볼 수 없는 Color.clear에 preference를 통해 proxy.size.width를 전달하고 있다. 상위 뷰(Text)에선 하위 뷰에서 전달한 정보를 onPreferenceChange를 통해 받을 수 있다. 이제 진짜 우리가 원하던 레이아웃을 확인할 수 있을 것이다. 정리하며간단한 레이아웃(?)을 그려보면서 SwiftUI를 관통하는 여러 개념들을 자연스럽게 접해볼 수 있던 영상이었다. SwiftUI가 레이아웃을 그리는 알고리즘에 대해 이해하고 나니 왜 그렇게 그려지는지 이해가 가지 않았던 부분들이 어느정 도 머릿속에 정리가 되는 시간이었다. 영상 말미에 한 가지 과제(?)를 주는데 이 부분은 github에 올려놓았습니다.","link":"/2020/02/15/SwiftUI-under-the-hood/"},{"title":"SwiftUI에서 여러 타입의 뷰 반환하기","text":"지난 포스팅에서 불투명 타입(Opaque Type)에 대해 공부했었다. 글 : Opaque Types in Swift 당시 우리는 불투명 타입을 반환할 땐 타입 정체성(Identity)를 잃지 않기 위해 한 가지 타입만 반환해야 한다고 공부했다. 하지만 개발을 하다 보면 여러 예외 상황을 마주하게 되는데 이는 불투명 타입도 마찬가지다. 먼저 SwiftUI로 프로젝트를 생성했을 때 마주하게 되는 기본 ContentView 코드를 살펴보자. 12345struct ContentView: View { var body: some View { return Text(\"Hello World\") }} body 프로퍼티는 some View 타입이기 때문에 한 가지 타입만 반환할 수 있다. 그래서 뷰 계층을 작성할 때 우리는 아래와 같은 구조에 익숙하다. 12345678910111213struct ContentView: View { var body: some View { ...View { ...View { ...View { ...View { } } } } }} some View를 반환해야 하기 때문에 위와 같은 구조의 코드에 익숙하다. 하지만 조건에 따라 다른 타입의 뷰를 보여주어야 한다면 어떻게 해야 할까? 123456789struct ContentView: View { var body: some View { if isLogIn { Image(\"User-Avatar\") }else { Text(\"Please Login\") } }} 이렇게 코드를 작성하면 우리는 Function declares an opaque return type, but has no return statements in its body from which to infer an underlying type와 같은 에러 메시지를 볼 수 있다. 하지만 언제나 방법은 있다! 게다가 두 가지씩이나! 그럼 그 두 가지를 살펴보자. Group Group은 어떠한 레이아웃 특성도 지니지 않는다. Group 안에서는 위와 같이 조건 분기를 통한 두 가지 타입을 반환할 수 있다. 1234567891011struct ContentView: View { var body: some View { Group { if isLogIn { Image(\"User-Avatar\") }else { Text(\"Please Login\") } } }} 오늘의 주제와 별개로 Group의 사용 예를 한 가지 더 들어보자면 기본적으로 뷰 빌더 안에는 최대 10개 뷰만 들어갈 수 있다. 10개가 넘어가면 에러 메시지를 출력하는데, 이때 우리는 Group을 사용해 레이아웃을 해치지 않으면서 10개 이상의 뷰를 추가할 수 있다. 12345678910111213141516171819202122232425262728293031struct ContentView: View { var body: some View { VStack { Group { Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") } Group { Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") Text(\"Text\") } } }} AnyViewGroup 말고도 우린 AnyView를 통해 두 가지 타입의 뷰를 반환할 수 있다. 정확하게는 타입을 지워(Type erase) 하나의 타입이 반환되는 것처럼 보이게 하는 것이다. 123456789struct ContentView: View { var body: some View { if isLogIn { return AnyView(Image(\"User-Avatar\")) }else { return AnyView(Text(\"Please Login\")) } }} 하지만 AnyView는 성능 비용이 높기 때문에 사용하는 것을 지양한다. AnyView의 공식 문서에는 다음과 같은 내용이 있다. Whenever the type of view used with an AnyView changes, the old hierarchy is destroyed and a new hierarchy is created for the new type AnyView와 함께 사용된 뷰가 변할 때마다 이전 뷰 계층을 파괴하고 새로 만들기 때문에 이 부분에서 성능 비용이 높다고 설명하는 것 같다. 하지만 또 이 부분에 대해 Group과 성능 비교를 한 글도 확인할 수 있었다. 이 비교 실험 글에 따르면 사실상 큰 차이는 없다고 나온다. 또한 이 글에선 body에서 뷰 상태의 바인딩을 최소한으로 하는 것이 성능 향상에 더 도움이 된다고 언급하고 있다. 상태에 의존하는 뷰가 많을수록 rebuild 횟수가 증가할 가능성이 크기 때문에 이렇게 말하고 있는 것으로 생각된다. 오늘은 SwiftUI에서 여러 타입의 뷰를 반환하는 두 가지 방법에 대해 알아보았다.","link":"/2020/01/08/SwiftUI%EC%97%90%EC%84%9C-%EC%97%AC%EB%9F%AC-%ED%83%80%EC%9E%85%EC%9D%98-%EB%B7%B0-%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0/"},{"title":"Universal Link &amp; Custom URL Scheme","text":"커스텀 스킴과 유니버셜 링크에 대해 알아보도록 하자. 이 둘에 대해 얼핏 많이 들어보았을 것이다. 단순히 말해 모두 딥링크를 지원하는 방법이다. 그렇다면 이 둘의 차이점은 무엇일까? 그리고 딥링크의 역할은 무엇이며 딥링크를 통해 우리는 어떤 이점을 얻을 수 있을까. 이것도 함께 알아보도록 하자. 딥 링크란?위키피디아의 정의에 따르면 딥링크는 특정 페이지에 도달할 수 있는 링크를 말한다. 링크란 단어는 실생활 대화에서도 많이 사용하고 실제로 링크도 많이 사용한다. *”야~ 내가 링크 보냈어 확인해봐”* 우리는 실생활에서 이런 말을 자주 하곤 한다. 그렇다면 위의 말에 담긴 뜻은 무엇일까? 그것은 바로 정보 전달이다. 정보 전달로는 부족하다. 편리한 정보 전달이다. 그럼 여기서 편리하다는 것은 무엇을 의미할까? 상대방이 내가 알려준 정보, 컨텐츠를 스스로 키워드를 이용하여 검색을 통해 접하는 것이 아닌 링크로 하여금 상대방에게 내가 전달하고자 하는 정보, 컨텐츠를 바로 노출시키는 것이 나는 편리한 정보 전달의 수단으로써의 링크라고 생각한다. 위의 *”야~ 내가 링크 보냈어 확인해봐”*의 링크가 딥링크다. 이 딥링크는 단순히 웹 브라우저 상에서만 존재하는 수단이 아니다. 우린 이런 딥링크를 이용해 특정 앱의 특정 컨텐츠를 상대방에게 편리하게 전달할 수 있다. 이렇게 우리는 딥링크를 통해 사용자에게 우리 앱의 컨텐츠를 Seamless하게 노출시킬 수 있다. 커스텀 URL 스킴이란?커스텀 스킴은 iOS에서 딥링크를 지원하는 방법 중 하나이다. 현재는 애플에서 유니버셜 링크를 사용하도록 강력하게 추천하고 있다. Universal links are strongly recommended as a best practice. 이 이유에 대해선 밑에서 천천히 살펴보도록 하자. 공식 문서에서 커스텀 URL 스킴을 앱 내의 자원에 접근할 수 있는 방법을 제공할 수 있는 방법이라고 설명하고 있다. 애플은 시스템 앱들에 대해 미리 정의된 앱 스킴을 제공한다. mailto, tel 그리고 facetime이 그것들이다. 커스텀 URL 스킴을 지원하는 방법은 어렵지 않다. 앱의 URL 포맷을 정의한다. 스킴을 등록해 시스템이 정의된 URL에 따라 알맞는 앱으로 사용자를 보낼 수 있도록 한다. 앱이 열린 URL을 적절히 처리해야 한다. URL은 반드시 정의된 커스텀 스킴 이름으로 시작해야 하며 파라미터를 함께 넘겨 이에 따른 별도의 동작을 처리하게 할 수도 있다. 1234567let url = URL(string: \"myphotoapp:Vacation?index=1\") UIApplication.shared.open(url!) { (result) in if result { // The URL was delivered successfully! }} 위와 같이 정의된 커스텀 스킴은 문서에서도 중복되지 않게 작성하라고 권고하고 있다. 그럼에도 불구하고 커스텀 스킴은 중복이 발생할 수 있다. 그리고 이렇게 중복된 스킴을 갖고 있는 두 앱이 존재한다면 시스템은 사용자가 의도하지 않은 다른 앱을 실행시키게 될 수 있다. 또한 앱이 설치되어 있지 않다면 스킴은 동작하지 않는다. canOpenURL(_:)를 통해 스킴에 해당하는 URL을 열 수 있는지를 검사할 수 있지만 앱이 설치되어 있지 않았을 때 우리가 원하는 궁극적인 행동은 커스텀 URL 스킴으로는 한계가 있다. 그렇다면 여기서 “우리가 궁극적인 행동”이란 무엇일까? 우리는 다른 앱에서 우리의 컨텐츠를 그대로 보여주는 것이 아닌 사용자가 우리 앱에서 우리의 컨텐츠를 소비할 수 있도록 이동시키고 싶을 것이다. (사파리를 통해 미디움의 컨텐츠를 보는 것보다, 미디움 앱을 통해 컨텐츠를 보는 것이 보다 쾌적한 사용자 경험을 제공할 수 있다.) 하지만 앱이 설치되어 있지 않았을 때 단순히 이동시키지 못하는 것에 그치지 않고 최소한 우리 앱을 설치할 수 있는 앱 스토어로 이동이라도 시켜준다면 우리 앱으로의 유입은 앞의 상황보다 더욱 나아질 수 있다. 위의 내용을 통해 우리는 커스텀 URL 스킴의 두 가지 단점을 알 수 있었다. 중복이 일어나 다른 앱을 실행시킬 수 있다. 앱이 설치되어 있지 않을 때 충분한 조치를 취할 수 없다. 그리고 1번의 이유는 치명적인 보안 이슈의 여부도 있기 때문에 애플은 이러한 커스텀 URL 스킴의 단점을 보완하고자 유니버셜 링크라는 것을 만들었다. 중요 iOS 9.0 이상의 앱에선 열고자 하는 앱의 커스텀 스킴을 Info.plist의 LSApplicationQueriesSchemes키의 값으로 반드시 등록을 해야 한다. 그렇지 않으면 설령 해당 스킴의 앱이 설치되어 있다 하더라도 canOpenURL(_:) 메소드는 항상 false를 반환할 것이다. 유니버셜 링크란?유니버셜 링크도 커스텀 URL 스킴과 동일하게 모바일 환경에서 딥링크를 지원하기 위한 수단이다. 하지만 유니버셜 링크는 앱이 설치되어 있지 않으면 웹 페이지를 통해 컨텐츠를 보여준다는 것이다. (물론 앱이 설치되어 있다면 바로 해당 앱을 실행시켜 컨텐츠를 보여준다.) 그렇기 때문에 유니버셜 링크는 표준 HTTP, HTTPS 링크다. 앱이 설치되어 있지 않을 경우 유니버셜 링크를 통해 컨텐츠를 웹을 통해 노출시키는 방법과 앱 스토어로 사용자를 보내는 방법이 있다. 서비스에 유니버셜 링크를 지원하기 위해선 웹 서버에서의 별도의 작업을 필요로 한다. 앱의 번들 ID와 앱이 열어야 할 경로(path)를 포함하는 AASA(Apple-App-Site-Association 파일이 웹 서버에 등록되어 있어야 한다. AASA 파일을 서버에 등록해야 하기 때문에 해당 도메인 소유자가 아닌 이상 등록을 할 수가 없다. 그렇기 때문에 고유하고 안전하게 딥링크를 지원할 수 있다. AASA 파일은 JSON 형태로 다음과 같이 작성되어야 한다. 12345678910111213{ \"applinks\": { \"apps\": [], \"details\": [{ \"appID\": \"D3KQX62K1A.com.example.photoapp\", \"paths\": [\"/albums\"] }, { \"appID\": \"D3KQX62K1A.com.example.videoapp\", \"paths\": [\"/videos\"] }] }} appID: .의 포맷의 값으로 앱의 식별자를 의미하는 값. paths: 앱에서 처리할 수 있는 링크 경로의 배열 와일드카드 문자를 사용해 보다 다양한 경로를 간편하게 지원할 수 있다. /videos/samples/201?/* : videos/sample에서 2010년대(201?)의 하위 모든 경로를 의미한다. 이미 웹 브라우저를 통해 컨텐츠를 즐기고 있던 사용자가 웹 브라우저 컨텐츠 내부의 유니버셜 링크를 클릭하면 웹 브라우저를 통해 계속해서 컨텐츠를 즐기수 있도록 한다. 계속해서 웹 브라우저에서 컨텐츠를 즐기던 사용자를 앱으로 보내버리는 것은 오히려 사용자 경험을 해칠 수 있기 때문이다. 사용자가 유니버셜 링크를 클릭하여 링크가 활성화되면 iOS는 앱을 실행시키고 NSUserActivity 객체에 정보를 담아보낸다. 그리고 사용자는 AppDelegate 메소드인 application(_:continue:restorationHandler:)를 오버라이딩하여 처리한다. 유니버셜 링크 활성화를 통해 전달된 NSUserActivity의 activityType은 NSUserActivityTypeBrowsingWeb이다. 또한 NSUserActivity 객체의 webpageURL 프로퍼티는 사용자가 클릭한 URL을 포함하고 있다. 그리고 NSURLComponents를 통해 URL의 경로나 파라미터를 추출해낼 수 있다. 1234567891011121314151617181920212223242526func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -&gt; Void) -&gt; Bool{ guard userActivity.activityType == NSUserActivityTypeBrowsingWeb, let incomingURL = userActivity.webpageURL, let components = NSURLComponents(url: incomingURL, resolvingAgainstBaseURL: true), let path = components.path, let params = components.queryItems else { return false } print(\"path = \\(path)\") if let albumName = params.first(where: { $0.name == \"albumname\" } )?.value, let photoIndex = params.first(where: { $0.name == \"index\" })?.value { print(\"album = \\(albumName)\") print(\"photoIndex = \\(photoIndex)\") return true } else { print(\"Either album name or photo index missing\") return false }} 번외일반적인 딥링크가 아닌 디퍼드 딥링크(Deferred)라는 개념이 존재한다. 그럼 디퍼드 딥링크는 기존의 딥링크와 다른 점은 무엇일까? 기존의 딥링크를 통해 우리가 할 수 있는 최선의 행동은 웹을 통해 컨텐츠를 보여주던지, 혹은 앱스토어로 사용자를 보내는 것에 불과하다. 디퍼드 딥링크를 굳이 번역해보자면 지연된 딥링크 정도로 해석해볼 수 있을 것이다. 그렇다면 여기서 무엇이 지연되었다는 것일까? 상황을 가정해보자. 앱이 설치되어 있지 않은 상태에서 기존의 딥링크를 통해 앱스토어까지 사용자를 보냈고 사용자가 앱을 설치했다. 딥링크의 궁극적인 목표는 앱의 설치가 아니라 특정 컨텐츠로 사용자를 보내는 것이다. 그렇기 때문에 현재 상황에서 딥링크 본연의 목적을 달성했다고 보기는 힘들다. 여기서 디퍼드 딥링크가 이런 문제를 해결해 줄 수 있다. 디퍼드 딥링크를 사용하면 링크를 통해 앱스토어로 보내진 사용자가 앱을 설치하고 최초로 앱을 실행시켰을 때 최초 링크를 통해 보여주었어야 할 컨텐츠로 사용자를 이동시킨다. 이렇게 앱스토어 &gt; 앱 설치 &gt; 앱 실행이라는 지연된 과정을 거쳐 컨텐츠를 사용자에게 보여줄 수 있는 기능의 딥링크를 디퍼드 딥링크라고 한다. 그렇다면 링크를 통해 앱을 설치하고 최초로 실행한 사용자와 일반적으로 앱 스토어에서 바로 앱을 설치하여 최초로 실행한 사용자를 어떻게 구분하여 컨텐츠를 보여줄까? 이 부분에 대해서 정확하게 설명된 내용을 찾기 힘들었지만 큰 그림에서 설명해준 글에선 이를 다음과 같이 설명하고 있다. Historically this has been done through fingerprinting. Fingerprinting works by generating a “fingerprint” of a web user consisting of a device’s IP address and user-agent (operating system, operating system version, and other device specific parameters) and generating another fingerprint when a user opens the app. Recent techniques like Branch’s People Based Attribution model have moved beyond fingerprinting to using an unique Identity Graph that matches a device’s unique browser identifier to its unique app identifier, tying it back to the actual user across web and app to achieve true cross platform attribution, giving better matching between link licks and app opens. 참고자료 Allowing Apps and Websites to Link to Your Content Universal links in iOS Deferred Deep Linking","link":"/2019/11/25/Universal-Link-Custom-URL-Scheme/"},{"title":"init?(coder:), init(nibName:, bundle:), awakeFromNib()","text":"평소에 뷰 컨트롤러나 뷰를 만들기 위해 스토리보드뿐만 아니라 .xib나 코드의 형태로 만들어 사용하기도 한다. 하지만 이들 각각의 방법으로 뷰 컨트롤러를 생성할 때 생성되는 시점이나 불리는 메소드를 명확히 알지 못해 매번 작성한 코드를 이리저리 움직여가며 동작을 확인했다. 오늘은 이렇게 정확하기 알지 못했던 개념을 개념을 더욱 명확하게 하기 위해 공부하고 기록한 내용이다. xib? nib? nib - NeXT Interface Builder xib - XML Interface Builder .xib와 .nib의 차이점은 무엇일까? 차이점이라기보단 .xib 파일은 빌드 시점에 .nib 파일의 형태로 바뀐다. 인터페이스 빌더로 작업한 UI는 .xib 파일의 형태로 저장되고 빌드 시점에 앱 번들로 복사되고 런타임에 로드된다. 또한 .xib 파일은 텍스트 기반의 파일로 바이너리 파일인 .nib 파일보다 소스 컨트롤에 용이하며 읽기에 용이하다. init?(coder:)xib 파일로 만든 뷰는 실제로 저장될 때 아카이빙 되어 저장된다. 그러므로 해당 뷰를 불러올 때는 언아카이빙를 통해 불러와야 한다. 스토리보드도 내부적으론 일종의 xib 파일들로 이루어져 있기 때문에 로그를 찍어보면 init?(coder:) 생성자가 불리는 것을 확인할 수 있다. 하지만 아직 이 시점에선 @IBOutlet이나 @IBAction은 준비되어 있지 않다. init(nibName:, bundle:) nib 파일명은 결국 우리가 생성해준 xib 파일이 바뀐 결과물이기 때문에 이 둘의 이름은 확장자를 제외하곤 동일하다. init(nibName:, bundle:) 생성자는 코드로 nib 파일로 만들어진 뷰를 불러올 때 사용하는 생성자이다. 이는 본인도 적지 않게 사용해봤다. 사용법은 nibName 아규먼트에는 nib파일의 이름에 해당하는 값을 넣어주는데 본인은 언제나 두 아규먼트 모두에 nil 값을 할당해주었다. 그 이유가 궁금해서 찾아봤는데 공식 문서는 이를 다음과 같이 설명하고 있었다. nibName 이 프로퍼티는 init(nibName:, bundle:) 생성자에 의해 생성되는 시점에 지정된 값을 포함한다. 이 프로퍼티는 nil일 수 있다. 뷰 컨트롤러의 뷰를 저장하기 위해 nib 파일을 사용한다면 뷰 컨트롤러를 생성하는 시점에 생성자에 해당 이름을 명시해주는 것을 추천한다. 하지만 만일 nib 파일 명을 지정해주지 않고 loadView를 오버라이딩하지 않는다면 뷰 컨트롤러는 xib 파일을 다른 방법을 이용해 이를 찾아낼 것이다. 구체적으로 말하자면 적절한 파일 이름 (.nib 확장자를 제외한)의 nib를 찾고 뷰를 필요로 할 때 이를 로드하여 사용할 것이다. 적절한 이름을 찾는 과정은 다음의 순서를 따라 찾는다. 만일 뷰 컨트롤러 클래스의 이름이 MyViewController와 같이 Controller 끝난다면 Controller를 제외한 MyView.nib 파일을 찾을 것이다. 뷰 컨트롤러와 이름이 동일한 nib 파일을 찾는다. MyViewController라면 MyViewController.nib 위와 같은 이유로 생성 시점에 아규먼트를 넘겨줘야 한다면 다음과 같이 생성자를 정의해줄 수 있다. 12345678910111213class MyViewController: UIViewController { private var prop: Int init(prop: Int) { self.prop = prop super.init(nibBundle: nil, bundle: nil) } // 사용자 정의 생성자를 작성해주었기 때문에 반드시 required 생성자를 구현해주어야 한다. required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) }} awakFromNib()사실 awakeFromNib()는 생성자가 아니다. 근데 생각보다 이를 생성자라고 생각하고 사용하는 경우가 적지 않은데 이를 잘못 이해한다면 원하는 결과물을 얻을 수 없을 것이다. 그럼 awakeFromNib은 무엇일까? 이 메소드는 init?(coder:)를 통해 뷰가 모두 언아카이빙된 후 호출된다. @IBOulet과 @IBAction이 모두 자리가 잡힌 후 호출되는 것이다. init?(coder:)가 언아카이빙의 시작점이라면 awakeFromNib()은 끝나는 시점이라고 할 수 있다. 이 세 메소드들을 공부하면서 각각 로그를 찍어보았는데 한곳에서 알 수 없는 현상이 발생하였다. 이는 다음과 같은 상황이었다. xib 파일을 하나 만들고 UIViewController를 상속받는 뷰 컨트롤러를 생성하였고 이를 xib 파일의 File's Owner로 지정하였다. 그리고 뷰 컨트롤러의 awakeFromNib() 메소드에 로그를 출력하도록 코드를 추가해보았지만 awakeFromNib()은 호출되지 않았다. 그 이유를 찾아본 결과 File's Owner는 이렇게 언아카이빙 되는 뷰 객체와 관련성이 없다. 위에서 언급했듯이 awakeFromNib() 언아카이빙이 모두 끝난 후 호출되는 메소드이다. File's Owner는 언아카이빙이 시작되기 전에 이미 존재하고 언아카이빙이 모두 끝난 후 해당 객체와 연결되기 때문에 File's Owner인 뷰 컨트롤러 안에서의 awakeFromNib()의 호출은 무의미하다. 하지만 스토리보드와 뷰 컨트롤러에선 얘기가 좀 달라진다. 스토리보드에 뷰 컨트롤러를 올리고 로그를 찍어보면 정상적으로 찍히는 것을 확인할 수 있다. 12ViewController - init(coder:)ViewController - awakeFromNib 그 이유는 해당 뷰 컨트롤러 객체 클래스를 File's Owner가 아닌 해당 뷰 컨트롤러 자체이기 때문이다. 그렇기 때문에 스토리보드 위에 올라가있는 뷰 컨트롤러는 언아키이빙 과정을 거치기 때문에 정상적으로 awakeFromNib()이 호출되는 것을 확인할 수 있다. 참고자료 iOS: initWithCoder:, initWithNibName:bundle:, awakeFromNib, loadView What’s up with the .NIB -&gt; .XIB?","link":"/2018/11/01/init-coder-init-nibName-bundle-awakeFromNib/"},{"title":"Meet WidgetKit","text":"링크 What makes a greate Widget? Glanceable 위젯은 미니앱이 아니다. 단순히 앱의 컨텐츠를 보여주는 것이므로, 컨텐츠에 집중해야하며 한 눈에 볼 수 있는(Glanceable) 컨텐츠를 제공해야 한다. Relevant스마트 스택을 이용해 특정 시점에 적절한 위젯을 보여주어야 한다. 즉 연관성이 있어야 한다. 연관성을 뒷받침 하는 요소들은 다음과 같다. Stacks use on-device intelligence Siri Shortcuts donation WidgetKit API 관련 WWDC 세션 - Add Configuration and intelligence to Your Widgets Personalized 위젯에는 세 가지 크기가 존재한다. 모든 크기를 지원할 필요는 없지만 최대한 많은 사이즈를 지원해 위젯의 개인화를 더욱 향상 시킬 수 있다. 또한 Shortcut에서 사용했던 Intent를 이용해 구성 옵션(Configuration Option)과 구성 화면(Configuration UI)를 쉽게 구현할 수 있다. How WidgetKit works위젯은 멀티플랫폼을 지원해야 하기 때문에 SwiftUI로 만들어졌다. 위젯은 위에서 언급했듯이 한 눈에 볼 수 있어야(Glanceable) 한다. 이를 위해 WidgetKit은 타임라인에 따른 연속된 뷰 계층을 반환해야 한다. 그렇기 때문에 이는 백그라운드 익스텐션에 속한다. 타임라인에 따른 연속된 뷰 계층을 패키징하여 홈 스크린에 전달하면 홈 스크린은 주어진 타임라인에 따라 정해진 뷰를 그리게 된다. 우리는 이런 메커니즘을 통해 런치 프로세스, 뷰 로딩 등을 피할 수 있다. 이를 통해 위젯은 항상 적절한 컨텐츠를 즉시 볼 수 있게끔 준비되어 있다. 이렇게 미리 뷰가 준비되어 있다는 것은 다른 곳에서 이를 재사용할 수 있다는 것을 의미한다. 아래는 이렇게 준비된 뷰가 위젯 갤러리에서 사용되는 모습이다. 이런 타임라인 메커니즘으로 우리는 위젯을 통해 항상 적절한 컨텐츠를 바로 볼 수 있다. 그리고 이런 타임라인은 메인 앱에서 사용자가 컨텐츠에 영향을 주는 데이터를 변경했을 때 갱신될 수 있다. 혹은 익스텐션에서 이러한 갱신을 스케쥴링해줄 수도 있다. 예를 들어 캘린더 위젯은 하루동안의 이벤트가 언제 일어날지에 대해 알고 있다. 익스텐션은 이 정보를 바탕으로 적절한 시간에 해당하는 뷰를 랜더링한다. How to make a great Widget?훌륭한 위젯을 만드는 방법을 아래 주제들을 통해 알아보자 Defining a widget Creating a glanceable experience Views, timelines and reloads Personaliztion and intelligence Defining a widget위젯을 정의하기 위해선 몇 가지 컨셉에 대해서 짚고 넢어가야한다. kind configuration supportFamilies placeholder 처음 위젯을 설계할 때 하나의 익스텐션으로 다양한 유형의 위젯을 지원할 수 있는 메커니즘을 구상했다. 주식 앱 익스텐션을 예로 들자면, 이는 몇 가지 종목에 대한 개요를 볼 수 있는 위젯을 제공한다. 하지만 추가로 한 가지 종목에 대한 상세 정보를 확인할 수 있는 위젯을 제공하거나 혹은 macOS의 알람 센터에서 확인할 수 있는 위젯을 제공한다. 위젯의 종류(kind)는 자신들이 어떤 유형의 Configuration을 지원하는지를 나타내기도 한다. 이런 Configuration에는 두 가지가 존재한다. StaticConfiguration IntentConfiguration StaticConfiguration 피트니스앱의 위젯은 단순히 현재 피트니스 상태를 알려주고, 딱히 사용자가 이를 구성할 수 있도록 지원할 필요는 없다. 이는 StaticConfiguration 타입이다. IntentConfiguration 다시 알림앱은 목록을 사용자가 수정하고 개인화할 수 있다. 이는 IntentConfiguration 타입에 해당한다. 위젯은 하나 혹은 다수의 supportedFamilies를 지원할 수 있다. 기본적으로 위젯은 모든 supportedFamilies 타입을 지원한다. placeholder는 위젯의 기본 컨텐츠(Default Content)가 된다. placeholder를 통해 위젯이 어떤 유형의 컨텐츠를 제공하는지만을 나타내야지 사용자 데이터가 포함되어 있어서는 안된다. 또한 placeholder는 자주 볼 수 있는 UI가 아니고 언제 보일지는 보장할 수 없다. 일반적으로 기기 환경 설정이 변경되었을 때 새 placeholder를 요청하곤 한다. 사용자에게 위젯이 어떤 유형의 컨텐츠를 제공하는지를 잘 나타내는 placeholder가 훌륭한 placeholder다. 아래의 코드는 위에서 살펴본 네 가지 키워드가 모두 담겨져있다. Creating a glanceable experience아래는 glanceable한 위젯의 예들이다. 위젯은 유용한 정보를 제공하며 사용자로 하여금 위젯을 탭 하여 더 많은 정보를 볼 수 있게끔 유도하고 있다. 한 눈에 보기 쉬운 위젯을 만들기 위한 요소 중 하나는 Stateless한 UI다. 이는 다음과 같은 특성을 갖는다. No Scrolling No videos or animated images Tap interactions 위젯은 딥 링크를 지원하므로, 탭을 통해 메인 앱의 특정 컨텐츠로 사용자를 유도할 수 있다. 이런 딥 링크는 widgetURL를 이용해 구현할 수 있다. Views, timelines and reloads뷰, 타임라인 그리고 갱신은 위젯의 엔진 역할을 한다. 뷰를 위한 세 가지 개념이 존재한다. Placeholder Snapshot Timeline Snapshot Snapshot은 시스템이 위젯을 빠르게 제공하기 위해 필요한 단일 진입점이다. 이를 위해 익스텐션은 이 뷰를 최대한 빨리 반환해주어야 한다. 그리고 이렇게 반환된 Snapshot은 위젯 갤러리에서 확인할 수 있다. 보통 Timeline의 첫 번째 진입점과 Snapshot은 동일한 진입점으로 반환될 수 있다. 그렇기 때문에 위젯 갤러리에서 보는 것은 사용자가 위젯을 디바이스에 추가했을 때의 보는 모습과 동일하다. Snapshot이 단지 하나의 단일 진입점이라면, 제시간에 보여지는 다수의 연속된 뷰는 Timeline이라고 할 수 있다. Timeline Timeline은 뷰와 날짜의 조합으로 어떤 뷰가 언제 보여져야 하는지를 나타낸다. Timeline은 다크모드, 라이트모드 모두 반환해야 한다. 익스텐션이 진입점을 제공하면 우리는 이 정보를 받아 디스크에 뷰 계층을 직렬화한다. 이를 통해 적절한 타이밍에 각 항목을 렌더링할 수 있다. 이런 방식으로 시스템은 수많은 Timeline을 통해 동시에 수많은 위젯에 이를 적용할 수 있다. 타임라인은 일반적으로 하루치 컨텐츠를 제공해야 한다. 그러나 주어진 시간에 따른 컨텐츠가 아닌 최신 정보를 보여주어야 할 때가 있다. 우린 이를 갱신(Reload)이라 부른다. Reload Reload란, 시스템이 익스텐션을 깨우고 각각의 위젯을 위한 새 Timeline을 요청하는 것을 말한다. Reload를 통해 사용자의 컨텐츠가 항상 최신 상태로 유지되도록 할 수 있다. 아래는 TimelineProvider 프로토콜로 WidgetKit에 언제 위젯을 갱신해주어여 하는지 알릴 때 사용된다. reloadPolicy 시스템에게 언제 다음 Timeline을 요청해야 하는지를 알려주는 일종의 갱신 정책이다. atEnd after(date: Date) never 관련 개발자 문서 시스템은 reloadPolicy를 받아 위젯을 갱신(reload)한다. 자주 보는 위젯은 더 자주 갱신될 것이고, 아닌 위젯은 덜 자주 갱실될 것이다. 또한 기기 환경 설정이 변경되면 시스템은 강제로 위젯을 갱신한다. 이렇게 시스템에 의한 위젯 갱신도 있지만 메인 앱 주도의 갱신도 존재한다. 백그라운드 노티피케이션 혹은 앱 내의 데이터 변경에 의해 위젯이 갱신될 수 있는데 이때 우리는 WidgetCenter를 사용해 위젯을 갱신해줄 수 있다. 서버로부터 받아온 정보를 바탕으로 위젯을 갱신해주기 위해선 백그라운드 세션을 사용해야 한다. 또한 서버 통신으로 만들어진 payload는 onBackgroundURLSesionEvents 변경자를 통해 전달된다. 요청은 일괄처리하고, 서버 통신은 필요한만큼만 사용해야 한다. 위젯은 매초마다 수행되는 작업이 아니다. 실시간 실행 환경도 아니다. 상태에 맞는 갱신 정책을 통해 위젯을 효율적으로 갱신해야 한다. Personalized and intelligence위젯의 개인화와 지능은 두 가지 요소로 결정된다. Intents Relevance Intents Intent는 사용자가 위젯을 구성하는데 사용되는 메커니즘이다. Intent를 통해 사용자에게 일종의 질문을 하고 (어떤 위치의 날씨 정보를 원하는지, 어떤 주식 종목을 원하는지) 시스템이나 앱은 이에 대한 응답으로 위젯을 갱신한다. 이를 통해 우린 위젯의 사용자화를 향상시킬 수 있다. Relevance 스마트 스택의 지능에 영향을 미칠 수 있는 요인 중 하나다. When users perform actions in your app, your app can donate shortcuts.If your widget is backed by the same INIntent, then your widget may be rotated to in the stack when the user would have typically perform that action. 또한 TimelineEntryRelevance 구조체의 score와 duration을 이용해 관련성(Relevance)에 영향을 줄 수 있다. [관련 WWDC 세션 - Add Configuration and intelligence to Your Widgets](","link":"/2020/09/20/Meet-WidgetKit/"},{"title":"Stacks, Grids, and Outlines in SwiftUI","text":"링크 SwiftUI은 기본 레이아웃 요소들은 Compositional 하게 사용 되도록 설계되었다. 이들 각각을 사용, 조합하여 원하는 레이아웃을 구성할 수 있다. Stacks우린 VStack과 HStack의 조합으로 아래와 같은 갤러리 레이아웃을 구성할 수 있다. 그리고 이들 Stack만으로는 스크롤이 불가능하기 때문에 ScrollView 안에 이들을 구성하였다. 하지만 갤러리 이미지가 많아질수록 그 모든 이미지를 한 번에 불러오는 데 있어 문제가 발생한다. 이는 반응성을 저해하는 요소가 될 수 있다. 이를 위해 Lazy 하게 컨텐츠를 불러올 수 있는, 즉 처음 랜더링될 때 필요한 컨텐츠만 불러오고 이후 필요할 때 나머지를 컨텐츠를 불러올 수 있는 LazyVStack과 LazyHStack이 새로 생겼다. 이들을 통해 메모리 공간이 불필요하게 커지는 것을 방지할 수 있다. 사용법은 매우 간단하다. 위의 갤러리 레이아웃에서 별점을 위한 HStack도 존재하는데, 이들 역시 Lazy 하게 구성해야 할까? 정답은 “아니오”다. 이들은 화면에 보여졌을 때 모든 컨텐츠를 한 번에 볼 수 있다. 그렇기 때문에 LazyHStack을 사용해서 그 어떤 이득도 볼 수 없다. 만일 일반 Stack과 Lazy Stack 중 어떤 것을 사용해야 할지 고민된다면 일반 Stack을 사용하는 걸 권장한다. Instruments를 사용해 프로파일링을 한 후 성능의 병목 현상을 발견했고 이를 해결할 때만 Lazy Stack을 사용하도록 하자 Grids그리드 레이아웃을 위한 새로운 기본 레이아웃이 추가되었는데 LazyVGrid와 LazyHGride가 그것이다. 이들의 사용법 역시 그리 어렵진 않다. LazyVGrid 기준으로 원하는 행의 구성 정보와 함께 기존의 VStack 코드를 대체하였다. 그리고 이런 행의 정보를 나타내는 GridItem 역시 새로 추가되었다. GridItem을 사용해 그리드 레이아웃의 각각의 아이템의 크기와 위치를 지정해 줄 수 있다. 이들은 기본적으로 유연하기(flexible) 때문에 위와 같이 세 개의 GridItem을 사용하면 각 행의 너비는 모두 동일한 너비를 갖게 된다. GridItem은 단순히 갯수만이 아닌 최소 너비 값과 같은 특정 사이즈 크기를 이용해 원하는 그리드 레이아웃을 구성하는데 사용할 수 있다. ListsList 역시 기본 레이아웃 구성 요소 중 하나로 스크롤과 선택된 항목(selection) 관리와 같은 인터렉션을 지원하는 레이아웃 요소이다. List는 항상 컨텐츠를 Lazy 하게 불러온다. 이뿐만 아니라 이번에 추가된 기능으로 우린 리스트를 통해 컨텐츠를 그룹화하여 표현할 수 있게 되었다. children keypath를 사용하는 생성자를 통해 우린 List의 컨텐츠를 쉽게 그룹화할 수 있게 되었다. 내부적으로 어떻게 이것이 가능한지 살펴보도록 하자. OutlinesOutlineGroup은 ForEach와 동일하게 데이터를 순회하지만 단일 계층의 flat 한 콜렉션 타입의 데이터를 순회하는 ForEach와 달리 OutlineGroup은 트리 구조 형태의 데이터 타입을 순회한다. OutlineGroup을 Section과 함께 사용하면 .listStyle(_:)에 따라 다양한 기본 스타일의 헤더 뷰를 사용할 수 있다. 이렇게 계층화된 데이터를 사용해 동일한 외형의 Row를 사용하는 것이 아니라 서로 다른 데이터 타입이지만 단순히 이들을 계층화하고, 보여주기와 숨기기 기능을 사용하고 싶다면 이번에 새로 추가된 DisclosureGroup을 사용하면 된다. OutlineGroup이 내부적으로 어떻게 동작하는지 살펴보자. 예제의 OutlineGroup은 graphics 모델을 사용한다. OutlineGroup은 동일한 모델을 사용하는 ForEach로 확장된다. ForEach의 body는 DisclosureGroup으로 graphics의 아이템 하나를 사용한다. DisclosureGroup은 다시 하나의 graphic를 데이터로 갖는 OutlineGroup을 body로 갖는다. 이런 1~4의 과정은 children이 없는 graphic을 찾을 때까지 반복된다. 이러한 계산 과정은 그룹이 확장되었을 때(사용자가 그룹을 확장시켰을 때)에만 진행되기 때문에 최소한의 과정만을 갖게 된다.","link":"/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/"},{"title":"Add configuration and intelligence to your widgets","text":"영상 링크 → 링크 Meet WidgetKit 정리 → 링크 함께 보면 좋은 문서 → Making a Configurable Widget Intro이 영상에선 위젯을 Configurable하게 만드는 방법과 Configurable한 위젯이 어떻게 시스템을 더욱 영리한 방식으로 작동하는데 도움을 줄 수 있는지에 대해 알아볼 것이다. 다음은 영상에서 살펴볼 예제 앱이다. 카드별 결제 내역을 보여주는 앱으로 최근 결제 내역, 납부일 및 납부해야 할 총 금액을 나타내는 두 가지 위젯을 제공한다. 이번 영상에서 다룰 주제의 목차는 다음과 같다. The Basics Types of data entry Configuration experience System intelligence 제일 먼저 위젯에 설정을 추가하는 방법을 살펴볼 것이다. 그 다음으로 사용자에게 입력하도록 요청할 수 있는 정보의 유형에 대해 설명하고, 앱의 데이터로 인터페이스를 채울 수 있는 방법을 살펴볼 것 이다. 이후엔 어떻게 위젯의 제목, 설명을 지정하고 배경색을 설정할 수 있는지에 대해 살펴볼 것이다. 마지막으론 스마트 스택에서 시스템이 여러분이 개발한 위젯이 노출되어야 할 시간을 보다 더 정확하게 예측할 수 있도록 설정을 추가하는 방법에 대해 살펴볼 예정이다. The Basics 위젯이 설정 가능하다면 위젯 뒷면에 사용자에게 입력을 요청할 수 있는 옵션들을 지정할 수 있고, 시스템은 이를 사용자에게 보여줄 것이다. 이런 옵션, 즉 사용자가 정보를 입력할 수 있는 요소들을 파라미터라고 한다. 예제 앱에선 Card 파리미터와 Category 파라미터를 지정하여 사용자가 원하는 카드의 원하는 카테고리의 최근 결제 내역을 위젯에 보여줄 수 있다. 이런 파라미터를 정의하기 위해 Siri와 Shortcut에서 사용하고 있는 Intent를 사용한다. Intent에 추가한 파라미터는 위젯에 하나의 행으로 사용자에게 보여진다. Xcode에서 Intent Definition 파일을 통해 Intent를 선언할 수 있다. 이 파일에는 Intent와 더불어 그들의 파라미터 등도 포함된다. 이 파일을 통해 시스템은 Intent의 정보를 읽을 수 있다. Intent를 정의하면 Xcode는 정의한 Intent와 이에 포함되는 파라미터를 프로퍼티로 갖는 클래스를 생성한다. 이 클래스의 인스턴스는 런타임 중 위젯 익스텐션에 전달되며 이를 통해 위젯은 사용자가 무엇을 설정했고 사용자에게 무엇을 보여주어야 하는지를 알 수 있다. Types of data entry위젯 설정에선 다양한 데이터 타입을 지원한다. String 타입의 파라미터를 지정하면 설정 화면은 텍스트 필드를 보여줄 것이고, Boolean 타입의 파라미터는 스위치를 보여줄 것이다. 그리고 숫자는 Int 타입의 파라미터는 스테퍼를, Decimal 타입의 파라미터는 슬라이더를 지원한다. 또한 설정 화면은 연락처 선택과 Location 타입의 파라미터를 위한 위치 선택 UI도 제공한다. 설정 화면은 열거형도 지원하는데, 정적 열거형과 동적 열거형을 통해 이를 활용할 수 있다. 여기서 동적 열거형이란 사용자마다 차이가 있을 수 있는 앱의 사용자 데이터를 의미한다. (사용자가 추가한 카드(Card)는 앱을 사용하는 사용자마다 달라질 수 있다.) 동적 옵션은 아래에서 더 자세히 살펴보도록 하자. 설정 화면은 위에서 언급한 것들 말고도 다수의 타입을 각각의 고유한 UI로 지원한다. Date components Duration URL Measurement Currency amount Payment method 또한 파라미터는 다수의 값을 가질 수 있으며, iOS 14에서 Intent는 고정된 크기의 배열을 지원한다. 이를 통해 정의된 갯수만큼의 아이템만 배열에 들어갈 수 있게 지정할 수 있다. 그리고 위젯의 크기에 따라 이 갯수를 별도로 지정해줄 수 있다. 영상의 06:43 ~ 09:39 구간에선 기본적으로 Intent Definition 파일에 Intent와 그의 파라미터를 입력하는 방법을 보여주고 있다. Dynamic Options and SearchDynamic Options 많은 경우, 위에서 언급한 사용자가 등록한 카드와 같이 위젯 설정에서 보여주고 싶은 데이터는 사용자마다 달라질 수 있다. 그리고 이런 유형의 데이터는 Intent Definition 파일에서 지정해줄 수 없다. 대신 Intent Definition 파일에서 Dynamic Options 체크박스를 체크하면 동적 옵션을 활성화할 수 있다. 이렇게 동적 옵션을 활성화하면 위젯 설정 화면에서 원하는 값을 직접 입력할 수 있는 대신 사용자가 선택할 수 있는 값을 검색하기 위해 앱에 요청해야 한다는 사실을 시스템에 알리게 된다. 이렇게 동적 옵션을 활성화하면 두 가지가 발생한다. 첫째, 위젯의 뒷면(설정 화면)의 동적 옵션이 활성화된 파라미터의 UI가 옵션의 목록을 보여주는 모달을 여는 버튼 모영으로 변경된다. 둘째, 여러분의 앱에서 구현해야 할 두 가지 메서드가 생성되는데, 하나는 선택 가능한 옵션을 제공하는 메서드, 나머지 하나는 기본 값을 제공하는 메서드이다. 이 메서드들은 Xcode가 생성해주는 Intent Handler 프로토콜의 일부이다. 여러분은 앱이나 Intent 익스텐션에서 이 프로토콜을 채택하는 클래스를 생성해야 한다. 이 클래스는 사용자가 위젯을 설정할 때 선택 가능한 옵션을 제공하기 위해 시스템에 의해 사용된다. 예제 앱에선 아래와 같이 선택 가능한 카드의 목록과 기본 선택 카드를 위의 메서드 구현을 통해 제공하고 있다. 선택 가능한 옵션을 제공하는 메서드를 사용하면 단순 리스트 형태로 옵션을 제공하거나 그룹화된 리스트 형태로 옵션을 제공할 수 있다. 아래는 그룹화된 리스트 형태로 옵션을 제공한 모습이다. Search 기본적으로 상단의 검색 바는 여러분이 제공한 옵션을 필터링하는 역할을 한다. 몇몇의 경우 옵션이 리스트에 한번에 보이지 않을 정도로 많을 때 검색을 활용할 수 있다. 이를 위해 Intent handler provides search results as the user types 체크박스를 활성화해야 한다. 또한 Prompt Label(검색에 도움을 줄 수 있는?)을 제공할 수도 있다. Intent handler provides search results as the user types 체크박스를 활성화하면 선택 가능한 옵션을 제공하는 메서드는 searchTerm 파라미터를 추가로 받게 된다. 처음 사용자가 리스트를 마주하면 이 메서드가 호출될 때 searchTerm은 nil로 전달된다. 그리고 이후에 사용자가 타이핑을 하기 시작하면 이 메서드는 입력된 문자열과 함께 다시 호출될 것이다. 영상의 12:23 ~ 15:11 구간에선 동적 옵션을 구현하는 방법을 직접 시현을 통해 소개하고 있다. Configuration experience이번엔 위젯의 설정 화면의 외형을 커스터마이징 해보자. 먼저 설정 화면의 제목과 설명을 configurationDisplayName 변경자와 description 변경자를 이용해 각각 지정해줄 수 있다. background와 accent 색상 역시 별도로 지정해줄 수 있다. 이를 위해선 먼저 위젯 익스텐션의 에셋 카탈로그에 색상의 이름과 함께 색상을 추가해야 한다. 그리고 이렇게 추가된 색상과 색상의 이름을 위젯 익스텐션의 build settings에서 각각 Global Accent Color Name과 Widget Background Name에 지정해주면 된다. 그리고 설정 화면에서 특정 파라미터의 값을 기반으로 다른 파라미터를 보여주거나 숨기고 싶을 수 있는 경우가 생길 수 있다. 위의 예제를 통해 두 파라미터의 관계를 살펴보면 Mirror Calendar App을 끄면, Calendar 파라미터가 나타나 어떤 캘린더가 보여야 하는지 수동으로 선택할 수 있어야 한다. 이를 위해 Intent Definition 파일 에서 Calendar 파라미터를 선택 후 Mirror Calendar App 파라미터를 Parent Parameter로 지정해주면 된다. 그리고 Mirror Calendar App이 false일 때만 Calendar가 보여야 하기 때문에 Show If Parent를 has exact value로, Value를 False로 지정해야 한다. System intelligence위젯은 단순히 하나만 배치할 수도 있지만 스택안에서 여러 위젯을 관리할 수 있다. 그리고 이 스택을 통해 적절한 타이밍에 특정 위젯을 최상단으로 올려 사용자에게 매번 적절한 위젯을 보여줄 수 있다. 이렇게 시스템이 적절한 타이밍과 위젯을 고르는데 영향을 미치는 것이 바로 intelligence, 즉 지능이다. 이번 챕터에선 다음의 두 가지 물음에 대해 살펴볼 예정이다. How do stacks behave intelligently? How can i appear at just the right time? 첫 스택 지능을 구현하는 기본 설계 원리를 살펴보고 여러분이 개발한 앱을 이번에 새롭게 등장한 홈 스크린 경험(스택)의 일부에 포함시키기 위해선 어떻게 새 API들을 구현해야 하는지를 살펴볼 것이다. How do stacks behave intelligently?어떤 것이 좋은 스마트 스택을 만들수 있을까? 스택은 사용자에게 분명한 가치를 적절한 타이밍에 한눈에 볼 수 있는 정보를 제공해야 한다. 예를 들어 뇌우가 오고 있다는 사실을 앱이 안다면 사용자에게 단순히 온도를 주기적으로 갱신해주는 것보다 뇌우가 오고 있다는 사실을 알려주는 것이 더 직관적이다. 시스템은 위젯을 올릴 때 두 가지 요인에 기반한다. 첫 번째는 사용자 행동 기반(behavior-based)이다. 시스템은 사용자가 특정 시간에 주로 찾는 정보를 제공하는 위젯을 해당 시간에 위로 올린다. 날씨 앱을 자주 들여다보는 사용자에겐 날씨 앱을 위로 올려 사용자가 이를 통해 날씨 정보를 빠르게 찾을 수 있도록 한다. 두 번째는 여러분의 앱이 제공하는 관련성 정보(relevant information)이다. 예를 들어 날씨 앱의 경우 뇌우가 왔을 때 위젯이 이를 시스템에 매우 관련성이 높은 정보가 있음을 알릴 수 있으며, 스택은 이를 통해 위젯을 위로 올릴지를 결정한다. How can i appear at just the right time?시스템이 위젯을 올리는데 필요한 정보를 제공하는데 사용할 수 있는 API들에 대해 살펴보도록 하자. Behavior-based 먼저 행동 기반 요인에 영향을 줄 수 있는 API에 대해 살펴보자. iOS 12에서 등장한 Shortcuts와 사용자 정의 Intent donations를 통해 여러분의 앱에서 사용자가 무엇을 했는지 시스템에 알릴 수 있게 되었다. 그리고 시스템은 이 정보를 바탕으로 Spotlight에서 그 다음 행동을 예측 및 추천할 수 있다. iOS 14에서 시스템은 동일한 정보를 바탕으로 언제 여러분의 위젯을 위로 올릴 것인지를 결정한다. 예제 앱에서 사용자가 앱에서 특정 카드를 확인했을 때 이 사실을 시스템에 알릴 건데, 이를 Intent donation을 통해 시스템에 알릴 것이다. 내부적으로 이게 어떻게 동작하는지 알아보기 전에 먼저 이를 위한 세팅을 하는 법에 대해 살펴보자. 먼저 기존의 Intent Definition 파일에서 Intent is elligible for Siri Suggestions 항목을 활성화한다. 해당 항목이 활성화되면 아래 Suggestions 필드가 추가된다. 우린 사용자가 앱에서 특정 카드를 확인했을 때 해당 카드의 내역을 보여주도록 구성된 위젯을 상단으로 올려야 하기 때문에 Supported Combinations에 card 파라미터를 추가해야 한다. 이렇게 설정을 마쳤고, 앱에서 사용자가 카드를 확인했을 때 이 사실을 시스템에 알릴 수 있도록(donate) 코드를 작성해주어야 한다. 예제 앱에서 사용되는 ViewRecentPurchasesIntent를 생성하고 여기에 현재 사용자가 확인한 Card 인스턴스를 담아 이를 donate하는 코드이다. 위에서 Supported Combinations에 Card 파라미터만 추가했기 때문에 Category 파라미터를 추가해도 시스템은 Card만 고려한다. 그럼 시스템이 이를 통해 어떻게 동작하는지를 살펴보도록 하자. 사용자가 식료품 가게에선 정오에 AcmeCard로 주로 결제하고 저녁은 주로 SoupPay로 결제한다고 했을 때 donate된 정보를 바탕으로 시스템은 각각 AcmeCard는 정오에, SoupPay는 저녁에 사용된다는 사실을 알 수 있기 때문에 카테고리에 상관없이 AcmeCard로 구성된 위젯을 정오에 위로 올릴 것이다. 만약에 Supported Combinations에 Category를 추가하고 Intent에 Category를 함께 donate한다면 시스템은 사용자가 명확하게 AcmeCard와 Groceries 카테고리로 설정한 위젯만 위로 올릴 것이다. 즉 Supported Combinations은 시스템과 소통하는 방법이다. 위의 과정을 요약하자면 아래와 같다. Relevant Information 이번에 살펴볼 API는 앱에서 중요하고 관련된 정보가 생겼을 때 시스템이 해당 위젯을 위로 올리는데 사용되는 API다. 먼저 Timeline을 간략하게 살펴보면, WidgetKit을 사용하여 다양한 시점에서 위젯의 모양을 결정하는 Timeline을 제공할 수 있다. 또한 최근 구매 내역과 같이 구매가 발생했을 때 각각에 해당하는 entry를 제공함으로써 위젯이 이를 사용해 실시간으로 새 정보에 반응할 수 있다. 예제 앱에서 사용자가 $50 이상의 구매가 발생하면 알람을 받기 원한다고 가정했을 때, 어떻게하면 시스템에게 예제 앱 위젯이 관련성 높은 정보($50 이상의 구매가 발생)를 갖게 되었다고 알릴 수 있을까? TimelineEntryRelevance 객체를 TimelineEntry와 함께 제공함으로써 이런 정보를 시스템에 전달할 수 있다. TimelineEntry는 세 가지 요소로 이루어져 있다. Date는 이 entry가 언제 랜더링되어야 하는지를 나타내고, View는 랜더링되어야 할 뷰를 의미한다. 그리고 이 entry의 연관성을 나타내는 Relevance는 TimelineEntryRelevance 객체로 score와 duration 프로퍼티를 갖는다. score를 먼저 살펴보자면, score는 과거에 제공된 모든 entry들과 비교했을 때 이 entry가 얼마나 연관되어 있는지를 나타낸다. 시스템은 다른 entry들과 관련하여 score만을 고려하기 때문에 범위와 스케일은 정의하기에 달려 있다. 예외적으로 0과 그 이하의 score는 시스템에게 현재 위젯이 관련 정보를 갖고 있지 않고, 위로 올라오지 말아야 한다고 알리는데 사용된다. 예제 앱으로 돌아와서 우리가 의도한대로 동작하기 위해 $50 이상의 구매가 발생했을 때는 1, 최근 구매 내역이 없으면 0 그리고 이외의 구매 내역은 0.1로 score로 지정해보자. 이렇게 score를 지정하면 사소한 구매 내역에 대해선 위젯이 올라올 수 있는 기회가 적지만 대신 굵직한 구매 내역은 확실한 우선순위를 갖을 수 있다. 다른 위젯들이 제공하는 score는 상관없음을 기억하자. score는 오로지 여러분이 제공한 score랑만 비교된다. 이번엔 결제 금액을 score로 사용해보자. 이를 통해 특정 금액을 넘는지 아닌지가 아닌 결제 금액에 따른 우선순위가 정해진다. score를 살펴보았고 이제 duration을 살펴보자. duration은 잘 정의된 일정 시간동안 관련성 점수(score)를 고정할 때 사용된다. 그렇지 않으면 duration을 0으로 두면 된다. 이는 관련성 점수가 다음 TimelineEntryRelevance가 수신될 때 까지만 지속된다는 것을 의미한다. 다은 duration을 활용한 예제이다. 농구 게임의 진행 상태를 알려주는 위젯으로 게임 시작 전에는 score를 0으로 지정하고 게임이 시작하면 score를 1로 지정하고 이를 게임이 진행되는 동안 고정하기 위해 duration을 3시간으로 지정하였다. 그리고 게임이 진행되는동안 관련성 점수에 영향을 미치지 않도록 TimelineEntryRelevance를 nil로 두고 TimelineEntry를 갱신할 수 있다. 스택의 지능(intelligence)에 정리해보자. 우린 스마트 스택을 이용해 특정 위젯을 스택의 최상단으로 올릴 수 있는 기회를 갖는다. 이를 가능하게 하는 방법은 다음 두 가지다. Donate INIntents that match your configuration intent (User behavior-based) Provide TimelineEntryRelevance for important information (Relevance information)","link":"/2020/10/07/Add-configuration-and-intelligence-to-your-widgets/"}],"tags":[{"name":"이직","slug":"이직","link":"/tags/%EC%9D%B4%EC%A7%81/"},{"name":"Swift5","slug":"Swift5","link":"/tags/Swift5/"},{"name":"ABI Stability","slug":"ABI-Stability","link":"/tags/ABI-Stability/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"Scene","slug":"Scene","link":"/tags/Scene/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"WindowGroup","slug":"WindowGroup","link":"/tags/WindowGroup/"},{"name":"Bitcode","slug":"Bitcode","link":"/tags/Bitcode/"},{"name":"App Thinning","slug":"App-Thinning","link":"/tags/App-Thinning/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"GeometryReader","slug":"GeometryReader","link":"/tags/GeometryReader/"},{"name":"Opaque Type","slug":"Opaque-Type","link":"/tags/Opaque-Type/"},{"name":"some","slug":"some","link":"/tags/some/"},{"name":"OptionSet","slug":"OptionSet","link":"/tags/OptionSet/"},{"name":"enum","slug":"enum","link":"/tags/enum/"},{"name":"@Binding","slug":"Binding","link":"/tags/Binding/"},{"name":"@State","slug":"State","link":"/tags/State/"},{"name":"Property Wrappers","slug":"Property-Wrappers","link":"/tags/Property-Wrappers/"},{"name":"RxSwift","slug":"RxSwift","link":"/tags/RxSwift/"},{"name":"WWDC19","slug":"WWDC19","link":"/tags/WWDC19/"},{"name":"iOS 13","slug":"iOS-13","link":"/tags/iOS-13/"},{"name":"WWDC","slug":"WWDC","link":"/tags/WWDC/"},{"name":"SwiftUI","slug":"SwiftUI","link":"/tags/SwiftUI/"},{"name":"PreferenceKey","slug":"PreferenceKey","link":"/tags/PreferenceKey/"},{"name":"AnyView","slug":"AnyView","link":"/tags/AnyView/"},{"name":"Group","slug":"Group","link":"/tags/Group/"},{"name":"Universal Links","slug":"Universal-Links","link":"/tags/Universal-Links/"},{"name":"Custom URL Scheme","slug":"Custom-URL-Scheme","link":"/tags/Custom-URL-Scheme/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"WidgetKit","slug":"WidgetKit","link":"/tags/WidgetKit/"},{"name":"Widget Configuration","slug":"Widget-Configuration","link":"/tags/Widget-Configuration/"},{"name":"Intent","slug":"Intent","link":"/tags/Intent/"}],"categories":[{"name":"Swift","slug":"Swift","link":"/categories/Swift/"},{"name":"WWDC","slug":"WWDC","link":"/categories/WWDC/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"SwiftUI","slug":"SwiftUI","link":"/categories/SwiftUI/"},{"name":"SwiftUI","slug":"WWDC/SwiftUI","link":"/categories/WWDC/SwiftUI/"},{"name":"RxSwift","slug":"RxSwift","link":"/categories/RxSwift/"},{"name":"Swift","slug":"WWDC/Swift","link":"/categories/WWDC/Swift/"},{"name":"WidgetKit","slug":"WWDC/SwiftUI/WidgetKit","link":"/categories/WWDC/SwiftUI/WidgetKit/"}]}