---
title: 문자열 안의 문자들이 고유한지 확인하기
subtitle: Algorithm
date: 2018-12-09 12:16:42
tags: ["String", "Algorithm"]
category: ["Algorithm"]
---

오늘은 문자열 안의 문자들이 고유한지 검사하는 알고리즘에 대해 공부해보았다. 단순한 알고리즘일 것 같았지만 주어지는 여러 조건들에 따라 접근 방법이 달랐으며 이 과정에서 알고리즘 초보로써 배운 것들이 흥미로워 포스팅을 한다.

> [엔지니어대한민국](https://youtu.be/xnGyjBptpZ4)이라는 유투브 채널을 통해 공부하고 기록한 내용입니다. 

---

### ASCII 코드로만 이루어져있는 문자열

먼저 [ASCII 코드](https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html)는 모두 128가지다. 여기서 바로 알 수 있는 것은 문자열의 길이가 128이 넘어간다면 무조건 중복이 발생했다는 것이다. 그리고 ASCII 코드의 가짓수 만큼의 `[Bool]` 형의 배열을 만들어 `false`로 초기화한 후 나온 것들을 하나씩 `true`로 바꾸어 검사하는 방법이다. 

```swift
func isUnique(_ string: String) -> Bool {
    guard string.count <= 128 else { return false } 
    
    var asciiArray = Array(repeating: false, count: 128)
    
    for character in string {
        guard let unsigned = character.unicodeScalars.first?.value else { return false }
        
        let value = Int(unsigned) // UInt32 -> Int

        guard !asciiArray[value] else { return false }

        asciiArray[value] = true
    }

    return true
}
```

하지만 만일 ASCII 코드뿐만 아니라 Unicode까지 포함한다면 어떻게 될까?

---

### Unicode를 포함하는 문자열

유니코드가 들어간다면 위와는 조건이 좀 달라진다. 현재 유니코드는 총 1,114,112개이다. 적지 않은 크기이다. 이 크기만큼의 배열을 만드는 것이 효율적일까? 그렇지 않다고 본다. 여기서 우리는 해시를 사용하여 문제를 해결할 수 있다. 

```swift
func isUnique(_ string: String) -> Bool {
    var unicodeDict: [Int : Bool] = [:]

    for character in string {
        guard let unsigned = character.unicodeScalars.first?.value else { return false }
        
        let value = Int(unsigned)
        
        guard !unicodeDict.keys.contains(value) else { return false }
        
        unicodeDict[value] = true
    }

    return true
}
```

바로 키 값이 이미 존재한다면 이는 이전에 한번 등장했던 문자라는 것을 의미하므로 키 값 검사를 통해 문자의 중복을 검사할 수 있다. 

여기서 조금 재미있는 조건이 등장한다. 만약에 문자열이 소문자로만 이루어져있으며 배열이나 해시같은 자료구조를 사용하지 못한다면 우리는 문자의 중복을 어떻게 검사할 수 있을까?

---

### 소문자로만 이루어져 있는 문자열 (배열이나 해시 사용 금지)

우리는 비트 연산을 통해 배열이나 해시와 같은 추가적인 자료 구조를 사용하지 않고 이 문제를 해결할 수 있다. 여기서 사용할 비트 연산은 총 세 가지이다.

1. **Left Shift** 연산 - 2진수를 왼쪽으로 주어진 숫자만큼 쉬프트하는 연산이다. 예를들어 1이라는 2진수가 존재하고 1만큼 쉬프트 연산을 한다면 10이 되고 이를 10진수로 바꾼다면 2가 된다. (Swift : `<<`)
2. **AND** 연산 - 두 2진수를 AND 연산한다면 동일한 자리수의 숫자가 모두 1인 경우만 연산의 결과가 1이고 나머지는 0이 되는 연산이다. (Swift : `&`)
3. **OR** 연산 - 두 2진수를 OR 연산한다면 동일한 자리수의 숫자가 모두 0일 경우만 연산의 결과가 0이고 나머지는 모두 1이 되는 연산이다. (Swift : `|`)

그럼 이러한 연산을 통해 우리는 어떻게 중복을 가려내는지 코드를 통해 살펴보도록 하자.

```swift
func isUnique(_ string: String) -> Bool {
    var checker = 0
    
    for character in string {
        guard let unsigned = character.unicodeScalars.first?.value else { return false }
        
        let value = Int(unsigned) - 97 // --- 1
        
        if checker & ( 1 << value ) > 0 { // --- 2
            return false
        }
        
        checker = checker | ( 1 << value ) // --- 3
    }
    
    return true
}
```

ASCII 테이블에서 영어 소문자를 찾아보면 a ~ z는 97 ~ 122인 것을 확인할 수 있다. 

1. 우리는 이 각각의 숫자에서 97을 뺀 후 그 값만큼 쉬프트 연산을 진행할 것이다. 
2. 그리고 `checker` 값과 AND 연산을 통해 이전에 나왔던 값인지를 검사하는데 이는 3번을 보면 이해할 수 있다. 
3. 만일 나온적이 없는 값이라면 `checker`와 쉬프트 연산의 결과물을 OR 연산을 진행한다. 검사가 완료된 값을 저장한다고 이해하면 된다. 

문자열이 `cbc`라고 가정해보자. 

```
c를 검사
ㄴ c = 99 
ㄴ value = 99 - 97 = 2
ㄴ 1 << 2 
ㄴ 100
ㄴ checker = 000 
ㄴ checker(000) & 100 = 000 (조건문 통과)
ㄴ checker(000) | 100 = 100 (현재 checker = 100)

b를 검사
ㄴ b = 98 
ㄴ value = 98 - 97 = 1
ㄴ 1 << 1
ㄴ 10
ㄴ checker = 100 
ㄴ checker(100) & 010 = 000 (조건문 통과)
ㄴ checker(100) | 010 = 110 (현재 checker = 110)

c를 검사
ㄴ c = 98
ㄴ value = 99 - 97 = 2
ㄴ 1 << 2 
ㄴ 100
ㄴ checker = 110
ㄴ checker(110) & 100 = 100 > 0 (조건문을 통과하지 못함)
ㄴ return false
```

우리는 위와 같은 과정을 통해 문자의 중복을 검사할 수 있다. 하지만 아직은 찜찜하다. 조금 더 자세히 살펴보자. 

이 조건에서 우리가 검사할 문자는 한정되어 있다. 그리고 그 문자에는 이미 고유한 값들이 할당되어 있다. 그렇기 때문에 97를 빼도 각 숫자는 고유한 값을 갖는다. 그렇기 때문에 `a`의 경우 97번을 쉬프트하는 것보다 0번 쉬프트를 하는 것이 수월하다. 

`a`의 경우 이 코드에서 값은 0이다. 1을 0번 쉬프트하면 그 결과는 2진수 1이다. 

```
...0001
```

`b`의 경우 이 코드에서 값은 1이다. 1을 1번 쉬프트하면 그 결과는 2진수 10이다. 

```
...0010
```

즉 각 문자에 해당하는 자리가 생기는 것이다. 해당 2진수 자리수의 숫자가 1이면 이전에 나왔다는 문자라는 것을 의미하며 같은 자릿수의 숫자 즉 같은 문자를 AND연산하면 둘다 1이고 그 결과는 0보다 크고 이는 중복된다는 것을 의미하기 때문에 `false`를 반환한다. 

여기서 재미있는 조건을 하나 더 추가하고자 한다. 어떤 문자가 와도 상관없지만 위에서 봐왔던 예제들과는 다르게 (배열, 해시, 변수) 어떠한 추가적인 저장소를 허용하지 않는다면 우리는 어떻게 문제를 해결할 수 있을까?

---

### 어떠한 추가 저장소도 허용하지 않는 경우

이 경우 우리는 2중 for문을 돌면서 검사하는 방법이 있다. 

```swift
func isUnique(_ string: String) -> Bool {
    let list = string.map {$0}
    
    for i in 0..<list.count {
        for j in i+1..<list.count {
            if list[i] == list[j] {
                return false
            }
        }
    }
    
    return true
}
```

한 문자를 잡고 (`list[i]`) 해당 문자 이후의 문자들을 (`list[j]`) 하나씩 대조하는 것이다. 이 경우 시간복잡도는 `O(n^2)`이 된다. 

하지만 만약에 문자열을 이루고 있는 문자들을 정렬할 수 있다면 우리는 이 시간복잡도를 조금 더 줄일 수 있다. 

```swift
func isUnique(_ string: String) -> Bool {
    let sorted = string.sorted()

    for i in 1..<sorted.count {
        if sorted[i] == sorted[i-1] {
            return false
        }
    }
    return true
}
```

정렬하는 알고리즘이 퀵 정렬임을 가정하면 퀵 정렬의 평균 시간복잡도는 `nlog(n)`이고 정렬되어 있는 경우 바로 이전의 값과만 비교하면 되기 때문에 이 알고리즘의 시간복잡도는 `nlog(n)`이 되는 것을 알 수 있다. 