<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: Swift - Corn the blog</title><meta property="og:type" content="blog"><meta property="og:title" content="Corn the blog"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="Corn the blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://yoursite.com/images/avatar.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="images/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"Corn the blog","image":["http://yoursite.com/images/avatar.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="3144516292555438" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Swift</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-03T12:27:18.000Z" title="2020-01-03T12:27:18.000Z">2020-01-03</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">9 minutes read (About 1323 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/03/Property-Wrappers-in-Swift/">Property Wrappers in Swift</a></h1><div class="content"><p>Property wrapper는 프로퍼티를 정의하는 코드(<em>code that defines a property</em>)와 프로퍼티가 어떻게 저장되는지를 관리하는 코드(<em>code that manages how a property is stored</em>) 사이의 계층(<em>layer</em>)이다.</p>
<p><img src="/2020/01/03/Property-Wrappers-in-Swift/property_wrapper.png" alt=""></p>
<p>Property wrapper를 사용하면 정의할 때 관리 코드(management code)를 한 번만 작성하고 여러 프로퍼티에 <strong>재사용</strong>할 수 있다. 사실 이런 wrapper 개념은 이번에 갑자기 나타난 것이 아니다. <code>lazy</code>나 <code>@NSCopying</code> 같은 키워드도 wrapper의 한 종류다. 하지만 Swift 5.1에선 개발자가 이런 wrapper를 직접 만들 수 있게 되었다.</p>
<p>Property wrapper를 이해하기 위해선 Property wrapper가 어떤 문제를 해결할 수 있는지를 보면 된다. 객체 안의 프로퍼티에 값이 할당될 때마다 로그를 출력해주어야 한다고 가정해보자. 우린 다음과 같이 코드를 작성할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; _x &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      _x = newValue</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"New value is \(newValue)"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="type">Bar</span>()</span><br><span class="line">bar.x = <span class="number">1</span> <span class="comment">// Prints 'New value is 1'</span></span><br></pre></td></tr></table></figure>

<p>가장 직관적인 방법이다. 하지만 객체 안에 <code>x</code>뿐만 아니라 수많은 프로퍼티가 존재하고 이런 프로퍼티 모두가 값이 할당될 때마다 로그를 출력해주어야 한다면 상황은 달라진다. </p>
<p>이런 상황을 해결하기 위해 우린 새로운 타입을 정의해줄 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = wrappedValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; </span><br><span class="line">      value = newValue</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"New value is \(newValue)"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 기존의 <code>Bar</code> 구조체를 아래와 같이 <code>ConsoleLogged</code> 타입을 사용해 바꿀 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _x = <span class="type">ConsoleLogged</span>&lt;<span class="type">Int</span>&gt;(wrappedValue: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; _x.wrappedValue &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; _x.wrappedValue = newValue &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="type">Bar</span>()</span><br><span class="line">bar.x = <span class="number">1</span> <span class="comment">// Prints 'New value is 1'</span></span><br></pre></td></tr></table></figure>

<p>이렇게 <code>ConsoleLogged</code> 타입을 사용해 중복 코드를 줄일 수 있다. Swift 5.1에선 이런 패턴을 Property wrapper라는 <em>Syntatic Sugar</em>로 제공한다. 사용 방법은 매우 간단하다. 기존의 <code>ConsoleLogged</code>에 <code>@propertyWrapper</code>만 붙이면 된다. <code>@propertyWrapper</code>를 타입(<code>struct</code>, <code>class</code>, <code>enum</code>) 앞에 붙이고 <code>wrappedValue</code>만 정의해주면 된다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConsoleLogged</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> value: <span class="type">Value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(wrappedValue: <span class="type">Value</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.value = wrappedValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">Value</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; value &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; </span><br><span class="line">      value = newValue</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"New value is \(newValue)"</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>프로퍼티가 어떻게 저장되는지를 관리하는 코드(<em>code that manages how a property is stored</em>) </p>
</blockquote>
<p>이렇게 선언한 Property wrapper는 사용하기도 쉽다. 아래와 같이 두 가지 방법으로 Property wrapper를 사용할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span> </span>&#123; </span><br><span class="line">  @<span class="type">ConsoleLogged</span> <span class="keyword">var</span> x = <span class="number">0</span> <span class="comment">// 1</span></span><br><span class="line">  @<span class="type">ConsoleLogged</span>(wrappedValue: <span class="number">2</span>) <span class="keyword">var</span> y <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>프로퍼티를 정의하는 코드(<em>code that defines a property</em>)</p>
</blockquote>
<p>Property wrapper 안에는 <code>wrappedValue</code>와 같이 프로퍼티뿐만 아니라 메소드도 정의할 수 있다. 하지만 안에 정의된 메소드를 사용할 땐 스코프(<em>scope</em>)에 주의할 필요가 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Foo"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 Property wrapper안에 <code>foo</code>라는 메소드를 정의했다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HasWrapper</span> </span>&#123;</span><br><span class="line">    @<span class="type">Wrapper</span> <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; _x.foo() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그럼 당연히 <code>Wrapper</code>를 Property wrapper로 사용하는 객체 내부에선 <code>foo</code> 메소드를 사용할 수 있다. (<code>_x.foo()</code>)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">HasWrapper</span>()</span><br><span class="line">a._x.foo() <span class="comment">// ❌ '_x' is inaccessible due to 'private' protection level</span></span><br></pre></td></tr></table></figure>

<p>하지만 위와 같이 외부에서의 접근은 불가능하다. 이유는 <code>private</code> 수준의 접근 제어를 갖기 때문이다. 물론 외부에서 접근할 수 있는 방법은 존재한다. <code>projectedValue</code>를 사용하면 된다. </p>
<p>우리는 <code>projectedValue</code>를 통해 부수적인 API를 외부에 노출시킬 수 있다. <code>wrappedValue</code>와 다르게 <code>projectedValue</code>는 타입의 제한이 없다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">T</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> projectedValue: <span class="type">Wrapper</span>&lt;<span class="type">T</span>&gt; &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Foo"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 우리는 <code>projectedValue</code>를 <code>x</code>에 <code>$</code>을 붙여 접근할 수 있다.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">HasWrapper</span>()</span><br><span class="line">a.$x.foo() <span class="comment">// Prints 'Foo'</span></span><br></pre></td></tr></table></figure>

<p>SwiftUI엔 <code>@State</code>, <code>@Binding</code>과 같은 빌트인 Property wrapper가 존재한다. 이에 대해선 추후 다루게 될 SwiftUI 포스팅에서 하나씩 살펴보도록 하자. </p>
<p>이번 포스팅에선 간단한 예로 <code>UserDefaults</code>를 Property wrapper를 통해 보다 간편하게 사용할 수 있는 예제를 살펴보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserDefault</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> key: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> initialValue: <span class="type">T</span></span><br><span class="line">  <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123; <span class="type">UserDefaults</span>.standard.<span class="keyword">set</span>(newValue, forKey: key) &#125;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="type">UserDefaults</span>.standard.object(forKey: key) <span class="keyword">as</span>? <span class="type">T</span> ?? initialValue &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>먼저 <code>UserDefault</code>라는 Property wrapper를 위와 같이 정의했다. <code>initialValue</code>를 통해 값이 존재하지 않을 때 초기값을 제공할 수 있다. 그리고 아래와 같이 사용할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">  @<span class="type">UserDefault</span>(key: <span class="string">"isCheatModeEnabled"</span>, initialValue: <span class="literal">false</span>) <span class="keyword">static</span> <span class="keyword">var</span> isCheatModeEnabled: <span class="type">Bool</span></span><br><span class="line">  @<span class="type">UserDefault</span>(key: <span class="string">"highestScore"</span>, initialValue: <span class="number">10000</span>) <span class="keyword">static</span> <span class="keyword">var</span> highestScore: <span class="type">Int</span></span><br><span class="line">  @<span class="type">UserDefault</span>(key: <span class="string">"nickname"</span>, initialValue: <span class="string">"cloudstrife97"</span>) <span class="keyword">static</span> <span class="keyword">var</span> nickname: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">UserPreferences</span>.isCheatModeEnabled = <span class="literal">true</span></span><br><span class="line"><span class="type">UserPreferences</span>.highestScore = <span class="number">25000</span></span><br><span class="line"><span class="type">UserPreferences</span>.nickname = <span class="string">"squallleonhart"</span></span><br></pre></td></tr></table></figure>

<p>물론 Property wrapper로 선언된 프로퍼티에도 한계가 존재한다. </p>
<ul>
<li>하위 클래스에서 오버라이딩될 수 없다. </li>
<li><code>lazy</code>, <code>weak</code>, <code>@NSCopying</code>과 같이 사용할 수 없다. </li>
<li>커스텀 <code>set</code>, <code>get</code>을 사용할 수 없다.</li>
<li>프로토콜이나 익스텐션에서 선언될 수 없다. </li>
</ul>
<p>오늘은 Swift 5.1에 새로 추가된 Property wrapper에 대해 매우 간단히 알아보았다. 이후에는 SwiftUI에서 사용되고 있는 Property wrapper들에 대해서 소개해보려 한다. </p>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://devsday.ru/blog/details/3752">The Complete Guide to Property Wrappers in Swift5</a></li>
<li><a href="https://medium.com/swlh/understanding-property-wrappers-in-swift-by-examples-604206022b5c">Understanding Property Wrappers in Swift By Examples</a></li>
<li><a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html">Swift Docs</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-12T11:59:12.000Z" title="2019-12-12T11:59:12.000Z">2019-12-12</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">16 minutes read (About 2450 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/12/Opaque-Types-in-Swift/">Opaque Types in Swift</a></h1><div class="content"><p>오늘은 Swift 5.1에서 처음 소개된 <strong>불투명 타입(Opaque Type)</strong>에 대해 공부해보고 기록해보려 한다. 사실 SwiftUI를 본격적으로 공부하려다 <code>some</code> 키워드에 막혀 이게 무엇인지 알아보려다 여기까지 오게 되었다. </p>
<blockquote>
<p> 이렇게 SwiftUI는 다시금 뒤로 미뤄졌다.🙄 진짜 제대로 시작해야 하는데..</p>
</blockquote>
<p>불투명 타입을 공부하면서 명확하게 이해가 된 부분도 있지만, 아직은 불투명하게 다가온 부분도 있었다. 그 이유는 아무래도 어느 문법을 공부해도 마찬가지겠지만, 직접 프로젝트에 사용하여 필요성을 느껴보지 못해서 그런 것 같다. </p>
<blockquote>
<p>@escaping 클로저를 처음 배웠을 때도 이와 비슷한 느낌이었다. </p>
</blockquote>
<p>오늘은 단순히 문법적 이해를 위한 기록으로 작성하고 추후 기회가 된다면 직접 사용해보고 이 문법이 왜 도입되었고, 언제 사용하면 좋을지 다른 사람들이 소개한 케이스가 아닌 내가 경험한 케이스를 소개해보려 한다. </p>
<hr>
<h3 id="Type-Identity"><a href="#Type-Identity" class="headerlink" title="Type Identity"></a>Type Identity</h3><p>불투명 타입을 소개하기 전 가장 먼저 본인이 불투명 타입을 공부하면서 헷갈렸던 부분을 먼저 소개해보려 한다. 스위프트 공식 문서나 여러 해외 블로그들을 읽다 보면 불투명 타입을 설명하는 데 있어 <strong>정체성(Identity)</strong>를 자주 언급하는 것을 확인할 수 있다. 정확하게 말하면 <strong>타입 정체성(Type Identity)</strong>이다.</p>
<p>타입 정체성이란 무엇일까? 몇 개의 글과 함께 예제 코드를 보고서야 조금은 감을 잡을 수 있었다. 내가 이해한 타입 정체성은 다음과 같다. </p>
<p>우린 스위프트에서 프로토콜을 타입으로써 사용할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Analytics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirebaseAnalytics</span>: <span class="title">Analytics</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlurryAnalytics</span>: <span class="title">Analytics</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnalyticsManager</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> analytics: <span class="type">Analytics</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> analytics: <span class="type">Analytics</span>) &#123; </span><br><span class="line">    <span class="keyword">self</span>.analytics = analytics</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">sendLog</span><span class="params">()</span></span> &#123; </span><br><span class="line">    analytics.log()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager1 = <span class="type">AnalyticsManager</span>(<span class="type">FirebaseAnalytics</span>())</span><br><span class="line"><span class="keyword">let</span> manager2 = <span class="type">AnalyticsManager</span>(<span class="type">FlurryAnalytics</span>())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>전적으로 예제를 위한 예제 코드다. </p>
</blockquote>
<p><code>AnalyticsManager</code>는 어떤 애널리틱스 툴을 사용해도 로그만 전송하면 된다. 우리는 보통 이런 경우 위와 같이 프로토콜을 만들고 행위를 정의한다. 그리고 행위를 구현한 구현체를 프로토콜 타입으로써 주입해준다. </p>
<p><code>AnalyticsManager</code>가 <code>sendLog</code>를 호출할 때 <code>AnalyticsManager</code>는 <code>FirebaseAnalytics</code>나 <code>FlurryAnalytics</code>가 아닌 단지 <code>Analytics</code> 타입으로 <code>analytics</code> 프로퍼티를 사용한다. 이렇게 프로토콜 타입은 사용되는 시점에 자신의 실제 타입에 대한 정체성을 잃게 된다.</p>
<p>“잃게 된다”라는 어감(?) 때문인지 부정적으로 다가올 수 있지만 이게 프로토콜 타입을 사용하는 이유다.</p>
<blockquote>
<p>추상화의 의미를 생각해보면 정체성을 잃는다는 것을 보다 쉽게 받아들일 수 있다.</p>
</blockquote>
<p>그리고 이런 프로토콜 타입은 프로그램에 유연성을 제공해주기 때문에 의존성 주입 등 코드 작성 전반에 걸쳐 유용하게 사용된다. </p>
<p>하지만 이러한 유연성이 때로는 코드 복잡성을 야기할 수 있다. 일반적인 프로토콜 타입에는 해당하지 않지만 <code>associatedtype</code>이나 <code>Self</code>를 사용하는 프로토콜 타입은 타입으로써 반환되거나, 파라미터로 전달, 프로퍼티로 사용될 수 없다. 만일 그렇게 사용하면 우린 굉장히 익숙한 에러 메세지를 볼 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol &#39;SomeProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements</span><br></pre></td></tr></table></figure>

<p>너무 돌아왔다. 결국 <strong>프로토콜 타입은 타입 정체성을 잃고 유연성을 제공</strong>한다는 것에 주목하자!</p>
<hr>
<h3 id="Opaque-Types"><a href="#Opaque-Types" class="headerlink" title="Opaque Types"></a>Opaque Types</h3><p>불투명 타입의 사용법은 간단하다. 반환되는 프로토콜 타입 앞에 <code>some</code> 키워드를 붙여주면 끝이다. 하지만 단순히 문법의 사용법만 가지곤 문법을 활용할 수 없다. 언제 불투명 타입을 사용할 수 있고, 불투명 타입을 왜 사용하는지에 대해 알아보았다. </p>
<p>이를 위해 불투명 타입이 없던 Swift 5.1 이전으로 돌아가 보자. 결제수단을 제공하는 프레임워크를 작성한다고 가정해보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">favoriteCreditCard</span><span class="params">()</span></span> -&gt; <span class="type">CreditCard</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같은 방식으로 사용자가 최근에 사용한 카드를 사용자가 선호하는 카드로 반환해줄 수 있다. 하지만 이러한 과정에서 우리는 굳이 사용자가 알 필요 없고, 알아서는 안되는 <code>CreditCard</code>라는 타입을 노출시킨다. </p>
<p>우리는 이런 문제를 프로토콜을 사용하여 해결하려 한다.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PaymentType</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CreditCard</span>: <span class="title">PaymentType</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ApplePay</span>: <span class="title">PaymentType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">favoritePaymentType</span><span class="params">()</span></span> -&gt; <span class="type">PaymentType</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> likesApplyPay &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="type">ApplePay</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>얼핏 보면 해결된 것처럼 보일 수 있지만 사용자가 <code>PaymentType</code>을 비교해야 한다면 얘기는 달라진다.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PaymentType</span>: <span class="title">Equatable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Equatable</code> 타입은 내부적으로 <code>Self</code>를 사용한다.</p>
</blockquote>
<p>이렇게 결제수단의 비교를 위해 <code>Equatable</code>을 사용하면 타입 정체성에서 언급한 에러 메세지를 보게 된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Protocol &#39;PaymentType&#39; can only be used as a generic constraint because it has Self or associated type requirements</span><br></pre></td></tr></table></figure>

<p>물론 이런 문제를 제네릭과 타입 제거 기법(type erasure techniques)을 통해 해결할 수 있다. 하지만 이는 프레임워크의 사용을 더욱 어렵게 만들며 역시 의도치 않게 내부 타입을 노출시킬 수 있다. </p>
<p>불투명 타입이 이런 문제를 해결할 수 있다. 방법은 매우 간단하다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">favoriteCreditCard</span><span class="params">()</span></span> -&gt; some <span class="type">PaymentType</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>물론 방법이 매우 간단한 만큼 한계도 존재한다. 불투명 타입을 반환하는 함수는 오로지 하나의 타입만 반환할 수 있다. 위의 코드에서 함수의 반환 타입은 <code>CreditCard</code>다. 하지만 컴파일러가 이를 <code>PaymentType</code>인 것 마냥 다룬다. 내부적으론 실제 타입을 반환하는 것이기 때문에 실제 타입으로 할 수 있는 모든 것들은 할 수 있다. 즉 <strong>타입 정체성이 보장</strong>된다는 것이다. 타입의 정체성이 보장되기 때문에 <code>associatedtype</code>이나 <code>Self</code>를 사용하는 프로토콜도 반환 타입으로 바로 사용할 수 있다.</p>
<p>물론 불투명 타입의 한계도 존재한다. 이런 타입의 정체성을 보장하기 위해 하나의 타입만을 반환할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">favoritePaymentType</span><span class="params">()</span></span> -&gt; some <span class="type">PaymentType</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> likesApplyPay &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="type">ApplePay</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>즉 위와 같은 코드는 사용할 수 없다는 뜻이다. </p>
<p>다시 불투명 타입을 사용하면 어떤 점이 좋은지 이야기해보자. 위에서 언급했듯이 불투명 타입은 모듈 내부의 타입을 노출시키지 않을 수 있다. 이게 단순히 하나의 타입을 노출시키지 않는다는 것을 의미하기도 하지만, 타입이 내부적으로 어떤 타입들로 구성되어 있는지도 숨길 수 있다. </p>
<p>SwiftUI를 예로 들어보자. SwiftUI 프로젝트를 생성하면 하나의 템플릿 코드를 확인할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>바로 내가 SwiftUI 공부를 멈추고 불투명 타입을 공부하기 시작하게 된 코드다. </p>
</blockquote>
<p>이 코드에서 <code>some</code> 키워드를 사용한 이유가 뭘까? <code>some</code> 키워드를 지우면 컴파일이 되지 않는 걸까? 그렇지 않다. <code>some</code> 키워드가 없이도 충분히 프로그램을 만들 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: <span class="type">Text</span> &#123; </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>some</code> 키워드를 사용하지 않고 SwiftUI로 화면을 만들어보자. SwiftUI에선 <code>VStack</code>을 이용해 스택 뷰의 형태를 구현할 수 있다. 그리고 SwiftUI에서 이런 컨테이너 타입들은 모두 제네릭 타입이다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Image</span>)&gt;&gt; &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"video.fill"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.</p>
<p>.</p>
<p>🤔</p>
<p>자자..! 일단 계속 만들어보자. 하나의 텍스트를 더 추가해보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Text</span>, <span class="type">Image</span>)&gt;&gt; &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">          	<span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"My name is Corn"</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"video.fill"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>좀 더 복잡한 레이아웃을 그려보자!</p>
<p>.</p>
<p>.</p>
<p><img src="https://i.ytimg.com/vi/-2Z0Y3Kk8nU/maxresdefault.jpg" alt=""></p>
<p>.</p>
<p>.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">List</span>&lt;<span class="type">Never</span>, <span class="type">TupleView</span>&lt;(<span class="type">HStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Text</span>)&gt;&gt;, <span class="type">Text</span>)&gt;&gt;, <span class="type">HStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Text</span>)&gt;&gt;, <span class="type">Text</span>)&gt;&gt;)&gt;&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">      .....</span><br><span class="line">      ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자 완성했다! 근데 중간 어디쯤에 있는 <code>Text</code>를 <code>Image</code>로 바꾸려 한다! 그러면…🤯</p>
<p>이쯤 되면 왜 불투명 타입이 필요한지 절실히 깨달을 수 있다. 우린 단지 <code>body</code>가 <em>어떤(some)</em> <code>View</code> 타입을 반환한다 정도만 알고 싶은 것이다. 그리고 그 정도의 정보만 필요하다. </p>
<p>우린 <code>some</code> 키워드로 <code>body</code>는 단지 <code>View</code> 타입을 반환한다는 사실을 명시해줄 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      .....</span><br><span class="line">      ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>아직은 내가 직접 작성한 모듈 혹은 프로젝트에서 불투명 타입을 사용해보진 못했다. 하지만 이젠 불투명 타입의 존재와 언제 사용하면 좋을지에 대해 훑어보았기 때문에 다음에 기회가 왔을 때 불투명 타입 사용을 고려해볼 수 있게 되었다. </p>
<blockquote>
<p>SwiftUI 공부도 다시 시작할 수 있다!</p>
</blockquote>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://medium.com/@PhiJay/whats-this-some-in-swiftui-34e2c126d4c4">What’s this “some” in SwiftUI</a></li>
<li><a href="https://swiftrocks.com/understanding-opaque-return-types-in-swift.html">Understanding Opaque Return Types in Swift</a></li>
<li><a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html">Opaque Types</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-23T11:12:09.000Z" title="2019-03-23T11:12:09.000Z">2019-03-23</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">8 minutes read (About 1196 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/23/OptionSet/">OptionSet</a></h1><div class="content"><p>오늘은 회사 과제를 진행하던 중 처음 접한 스위프트의 <code>OptionSet</code>이라는 친구를 살펴보려 한다. 처음 접한 개념이지만 알아보니 그렇게 어렵지 않은 개념이면서도 유용하게 사용할 수 있을 것 같은 개념이어서 이렇게 기록해보려 한다. </p>
<hr>
<p>먼저 그 개념을 공식 문서를 통해 살펴보도록 하자. </p>
<p><code>OptionSet</code> 프로토콜은 비트들 각각이 집합의 요소를 표현하는 비트 집합 타입을 표현하는데 사용된다. 이 프로토콜을 채택한 사용자 정의 타입에선 요소 검사(해당 요소가 집합에 속하는지), 합집합, 교집합 연산과 같은 집한 연산들을 수행할 수 있다. </p>
<p>옵션 집합(<code>OptionSet</code> 프로토콜을 채택한 사용자 정의 타입)을 만들기 위해선 타입 선언 부분에 <code>rawValue</code>를 포함시켜야 한다. 사용자 정의 타입으로 만든 옵션 집합이 기본 집합 연산을 수행하기 위해선 <code>rawValue</code> 프로퍼티는 반드시 <code>FixedWidthInteger</code> 프로토콜을 따르고 있는 타입(<code>Int</code>, <code>UInt8</code> 등등)이어야 한다. 다음으로는 정적(<em>static</em>) 변수로 고유한 2의 거듭제곱 값(1, 2, 4, 8, …)을 <code>rawValue</code>로 갖는 옵션들을 생성한다. 이렇게 2의 거듭제곱 값을 <code>rawValue</code>로 가져야 각각의 옵션들은 단일 비트로 표현이 가능하기 때문이다.</p>
<p><code>OptionSet</code>은 다음과 같이 정의할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ShippingOptions</span>: <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rawValue: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> nextDay    = <span class="type">ShippingOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// 0001</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> secondDay  = <span class="type">ShippingOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 0010</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> priority   = <span class="type">ShippingOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// 0100</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> standard   = <span class="type">ShippingOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">3</span>) <span class="comment">// 1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> express: <span class="type">ShippingOptions</span> = [.nextDay, .secondDay] <span class="comment">// ?? </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> all: <span class="type">ShippingOptions</span> = [.express, .priority, .standard] <span class="comment">// ??</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>먼저 왜 2의 거듭제곱 값으로 표현되어야 할까?</p>
<p>그 이유는 위에서 언급되었듯이 단일 비트로 각각의 값을 표현할 수 있기 때문이다. (Bitmask)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0001 &#x2F;&#x2F; 1</span><br><span class="line">0010 &#x2F;&#x2F; 2</span><br><span class="line">0100 &#x2F;&#x2F; 4</span><br><span class="line">1000 &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure>

<p>만일 2의 거듭제곱이 아니라면 어떻게 될까? 이에 대해서는 밑에서 얘기해보자. </p>
<p>처음 <code>OptionSet</code>을 봤을 때 가장 먼저 든 생각은 *”열거형(enum)이랑 뭐가 다른거지!?”* 였다. 그 생각을 몇몇의 글들을 읽어보면서 정리해보았다.</p>
<p><strong>열거형과 <code>OptionSet</code>을 채택한 타입과의 가장 큰 차이점은 단일 타입 변수가 가질 수 있는 경우의 수의 차이다.</strong> 열거형 타입은 해당 타입의 케이스를 하나만 나타낼 수 있다. 하지만 <code>OptionSet</code> 여러 케이스를 하나의 변수로 표현할 수 있다. 열거형에서 이를 표현하려면 여러 케이스에 해당하는 열거형 타입을 배열과 같은 콜렉션 타입으로 표현해야 한다. </p>
<p><strong><code>OptionSet</code>은 여러 케이스를 하나의 변수로 담을 수 있기 때문에 각각의 케이스는 유일해야 한다.</strong> 그리고 이를 위해 우리는 비트 값으로 이를 표현한 것이고 2의 거듭제곱으로 표현한 것도 그와 같은 이유다. 실제로 <strong>여러 케이스를 표현한다고 여러 값을 갖고 있을 필요는 없다.</strong> 위의 <code>ShippingOptions</code>을 살펴보자. </p>
<p><code>express</code>는 <code>[.nextDay, .secondDay]</code>로 표현된다. 하지만 <code>[ShippingOptions]</code>이 아닌 <code>ShippingOptions</code> 타입 변수에 할당된다. 2의 거듭제곱으로 표현되고 있다는 걸 상기시켜보면 실제로 <code>express</code>의 값은 <code>.nextDay(0001)</code>과 <code>.secondDay(0010)</code>을 더한 <code>0011</code>인 것이다. 그리고 모든 원시 값이 2의 거듭제곱이기 때문에 <code>0011</code>만 보아도 <code>0001</code>과 <code>0010</code>의 조합인 걸 알 수 있다.   </p>
<p>여기서 2의 거듭제곱으로 해야 하는 이유가 나온다. 만일 2의 거듭제곱 값이 아닌 <code>0011</code> , 즉 3을 원시 값으로 갖는 케이스가 있다면 <code>.express</code>와 구분이 되지 않기 때문이다. </p>
<p>또한 서버에 값을 전송할 때 리스트 형태의 값을 전달하는 것보다 이렇게 비트 마스크로 표현된 값을 보내는 것이 더 수월할 수 있다. (물론 서버 개발자와의 확실한 상호 협의가 요구되지만)</p>
<p>그리고 위에서 언급했듯이 <code>OptionSet</code>을 따르는 프로토콜은 <strong>집합 연산</strong>을 수행할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> normal: <span class="type">Pet</span> = [.nextDay, .secondDay]</span><br><span class="line"><span class="keyword">let</span> options2: <span class="type">Pet</span> = [.nextDay, .priority, .standard]</span><br><span class="line"><span class="keyword">let</span> intersection = options1.intersection(options2)</span><br><span class="line"><span class="built_in">print</span>(intersection) <span class="comment">// ShippingOptions(rawValue: 1) 👉 nextDay</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> union = options1.union(options2)</span><br><span class="line"><span class="built_in">print</span>(union) <span class="comment">// ShippingOptions(rawValue: 15) 👉 nextDay, secondDay, priority &amp; standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subtracting = options1.subtracting(options2)</span><br><span class="line"><span class="built_in">print</span>(subtracting) <span class="comment">// ShippingOptions(rawValue: 2) 👉 secondDay</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">contains</span> = options1.<span class="built_in">contains</span>(.standard)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">contains</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</b>

<p>오늘은 이렇게 간단히 <code>OptionSet</code>에 대해 알아보았다. 이를 사용한다면 보다 여러 케이스를 포함하는 상황에서 보다 적은 코드로  각각의 상황에 대응할 수 있을 것 같다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-09T12:44:58.000Z" title="2019-03-09T12:44:58.000Z">2019-03-09</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">17 minutes read (About 2491 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/09/ABI-Stability/">ABI Stability</a></h1><div class="content"><p>스위프트 5.0에서 가장 많이 주목을 받고 있는 부분이 바로 ABI 안정화(Stability)이다. 대체 ABI가 안정화된다는 것이 무엇을 의미하는지, 왜 ABI 안정화를 지원하게 됬는지 ABI 자체가 무엇인지에 대해 알아보려 한다. </p>
<p>기본적으로 <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md">Swift ABI Stability Manifesto</a> 글을 기반으로 각종 블로그 글들을 참고하면서 나름대로 정리해보았다. </p>
<hr>
<h3 id="The-Big-Picture"><a href="#The-Big-Picture" class="headerlink" title="The Big Picture"></a>The Big Picture</h3><p>현재 스위프트의 가장 최우선 순위는 향후 스위프트 버전과의 <strong>호환성(compatibilty)</strong>이다. 호환성은 다음의 두 가지 목표를 갖고 있다.</p>
<ol>
<li><strong>소스 호환성(Source compatibility)</strong>은 새 컴파일러가 구 버전의 스위프트를 컴파일 할 수 있다는 것을 의미한다. 이는 새 스위프트 버전이 나오면 스위프트 개발자들이 직면했던 마이그레이션의 고통을 줄여주는 목적을 갖고 있다. 소스 호환성 없이는 프로젝트는 <strong>버전 잠금(version-lock)</strong>에 직면하는데 이는 프로젝트와 패키지 내부의 모든 소스코드가 동일한 스위프트 버전으로 작성되어야 한다는 것을 의미한다. 소스 호환성이 존재한다면 패키지 작성자는 그들의 사용자가 새로운 버전의 스위프트를 사용할 수 있도록 하며 여러 스위프트 버전을 단일 코드 기반으로 유지할 수 있다. </li>
<li><strong>바이너리 프레임워크와 런타임 호환성(Binary framwork &amp; runtime compatibility)</strong>은 다양한 스위프트 버전에서 동작할 수 있는 바이너리 형태의 프레임워크 배포를 가능하게 한다. 바이너리 프레임워크는 프레임워크 API의 소스-레벨 정보와 통신하는 <em>스위프트 모듈 파일(Swift module file)</em>과 런타임 중 로드되는 컴파일된 구현체인 <em>공유 라이브러리(shared library)</em>를 포함한다. 따라서 바이너리 프레임워크 호환성(binary framework compatibility)은 두 가지 목적을 갖고 있다. <ul>
<li><strong>모듈 포맷 안정성(Module format stability)</strong>은 컴파일러가 프레임워크의 공개 인터페이스를 나타내는 모듈 파일을 안정화시킨다. 이는 API의 선언과 inlineable 코드를 포함한다. 이 모듈 파일은 컴파일러가 프레임워크를 사용하는 클라이언트 코드를 컴파일 할 때 타입 검사, 코드 생성 등과 같은 필수 작업을 진행하는데 사용된다. </li>
<li><strong>ABI 안전성(ABI stability)</strong>은 서로 다른 스위프트 버전으로 컴파일된 어플리케이션과 라이브러리 사이의 바이너리 호환성을 가능하게 한다. </li>
</ul>
</li>
</ol>
<h3 id="What-is-ABI"><a href="#What-is-ABI" class="headerlink" title="What is ABI?"></a>What is ABI?</h3><p>런타임 중에 스위프트 프로그램 바이너리는 ABI를 통해 다른 라이브러리와 요소들과 상호작용한다. ABI는 Application Binary Interface를 의미하며 독립적으로 컴파일된 바이너리 엔티티(실체)들이 서로 연결되고 실행되기 위해서 반드시 따라야 규격이다. 이러한 바이너리 엔티티들은 함수를 호출하는 방법, 메모리에서 데이터가 표현되는 방법 그리고 그들의 메타데이터가 어디에 존재해야하는지 그리고 어떻게 접근해야하는지 등의 저수준의 상세 사항들을 따라야 한다. </p>
<blockquote>
<p>API를 사용할 때 우리는 사용하려는 기능의 내부 로직은 크게 신경쓰지 않고 API의 원하는 기능을 취할 수 있다.  라이브러리가 업데이트되어도 우리가 호출하는 API의 메소드의 외형은 동일하게 사용할 수 있어야 한다. 라이브러리가 업데이트될 때마다 외형이 변경된다면 우리는 계속해서 우리의 코드를 이에 맞춰 수정해야 한다. </p>
<p>ABI도 마찬가지라고 생각한다. ABI의 안정화 없이 스위프트 버전이 올라가게 되면 우리는 프로젝트에서 사용되는 스위프트를 새 버전의 스위프트로 계속해서 마이그레이션 해야 한다. </p>
</blockquote>
<h3 id="What-is-ABI-Stability"><a href="#What-is-ABI-Stability" class="headerlink" title="What is ABI Stability?"></a>What is ABI Stability?</h3><p>ABI 안정화란 향후 새로운 버전의 컴파일러가 안정환된 ABI 규격을 따르는 바이너리를 생성할 수 있는 수준으로 만드는 것을 의미한다. </p>
<p>ABI 안정화는 오직 외부에 노출되는 공공 인터페이스와 심볼의 불변성에만 영향을 미친다. 내부 심볼, 컨벤션 그리고 레이아웃은 ABI 규격을 깰 필요 없이 지속해서 변경할 수 있다. 예를 들어 미래의 컴파일러는 공개되어 있는 공공 인터페이스를 유지하는한 내부 함수 호출의 호출 규칙을 자유롭게 변경할 수 있다.</p>
<h3 id="What-Does-ABI-Stability-Enable"><a href="#What-Does-ABI-Stability-Enable" class="headerlink" title="What Does ABI Stability Enable?"></a>What Does ABI Stability Enable?</h3><p>ABI 안정화는 OS 공급자가 운영체제에 스위프트 표준 라이브러리와 구 버전 혹은 새 버전의 스위프트로 만들어진 어플리케이션과의 호환성을 갖는 런타임을 내장할 수 있도록 한다. 이렇게 되면 이러한 플랫폼 상의 앱을 배포할 때 표준 라이브러리를 앱 내에 포함시켜 배포할 필요가 없어진다. 이는 도구의 의존성을 줄여주고 운영체제에 보다 우수한 조화를 가능하게 한다. </p>
<blockquote>
<p>기존의 iOS 앱 번들에는 해당 앱을 만드는데 사용한 버전의 스위프트 표준 라이브러리를 포함하고 있었다. 즉 스위프트 4.2로 만들어진 앱은 스위프트 4.2 ABI를 포함하는 스위프트 4.2 동적 라이브러리를 앱 번들 내에 포함하고 있었고 스위프트 3.0으로 만들어진 앱은 3.0 ABI를 포함하는 동적 라이브러리를 앱 번들 내에 포함하고 있었다는 것이다. </p>
<p>즉 각각의 언어는 각각의 OS 버전과 서로 다른 ABI 규격을 갖고 있었기 때문에 다른 버전의 OS에서 앱이 실행되기 위해선 앱 번들 자체에 스위프트 동적 라이브러리를 포함했어야 했다.</p>
<p>ABI가 안정화되면 이렇게 앱 번들 내에 해당 버전의 스위프트 다이나믹 라이브러리를 포함할 필요가 없기 때문에 앱 사이즈는 줄어들 수 있다. 왜냐하면 OS와 스위프트의 버전 차이가 존재해도 ABI 규격은 동일하기 때문이다. 스위프트 표준 라이브러리와 스위프트 런타임이 OS에 내장되는 것이다. </p>
</blockquote>
<h3 id="Module-Stability"><a href="#Module-Stability" class="headerlink" title="Module Stability"></a>Module Stability</h3><p>ABI 안정화는 런타임 중의 스위프트 버전들의 혼용에 관한 것이다. 컴파일 시점은 어떤가? 스위프트는 “swiftmodule”이라는 불투명한 아카이브 포맷을 사용해 수동으로 작성된 헤더 파일이 아닌 “MagicKt” 프레임워크와 같은 라이브러이의 인터페이스를 나타낸다. 그러나 “swiftmodule” 포맷 역시 현재 컴파일러 버전에 묶여잇고 이는 만일 “MagicKit”이 다른 스위프트 버전으로 만들어졌다면 개발자는 <code>import MagicKit</code>을 통해 해당 프레임워크를 사용할 수 없다는 것을 의미한다. 즉 앱 개발자와 라이브러리 제작자는 반드시 같은 버전의 컴파일러를 사용해야 한다. </p>
<p>이러한 제한 사항을 없애기 위해 라이브러리 제작자는 현재 구현중인 현재는 구현되고 있는 <strong>모듈 안전성(module stability)</strong>라 불리는 기능을 필요로 한다. 이를 통해 라이브러리를 사용하는 개발자는 모듈이 어떤 컴파일러로 만들어졌는지 생각할 필요 없이 모듈을 사용할 수 있다. </p>
<p><img src="https://swift.org/assets/images/abi-stability-blog/module-stability.png" alt=""></p>
<p>예를들어 스위프트6 그리고 스위프트7 컴파일러는 스위프트6로 만들어진 프레임워크의 인터페이스를 읽을 수 있는 것이다. </p>
<h3 id="Libraray-Evolution"><a href="#Libraray-Evolution" class="headerlink" title="Libraray Evolution"></a>Libraray Evolution</h3><p>우리는 지금까지 컴파일러 교체에 관해 얘기했지만 스위프트 코드도 동일하다. 오늘날 스위프트 라이브러리가 변경되면 해당 스위프트 라이브러리를 사용하는 앱은 재컴파일 되어야 한다. 이는 몇 가지 장점이 있는데 컴파일러가 앱이 사용하는 라이브러리의 버전을 정확히 알고 있기 때문에 코드 크기를 줄일 수 있는 추가적인 가정(assumption)을 할 수 있고 앱을 보다 빠르게 실행시킬 수 있다. 하지만 이러한 가정은 다음 라이브러리 버전에는 맞지 않을 수 있다. </p>
<p><strong>Library Evolution</strong> 기능은 앱을 재컴파일 할 필요 없이 새로운 버전의 라이브러리의 기능을 사용할 수 있도록 하는 것이다. </p>
<p><img src="https://swift.org/assets/images/abi-stability-blog/library-evolution.png" alt=""></p>
<p>위의 예제에서 앱은 노란색 버전으로 만들어진 프레임워크로 만들어졌다. library evolution과 함께 노란색 버전을 가진 시스템에서의 실행은 물론이고 새롭게 개선된 빨간색 버전에서도 실행될 수 있다.</p>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://swift.org/blog/abi-stability-and-more/">ABI Stability and More</a></li>
<li><a href="https://medium.com/swift-india/swift-5-abi-stability-769ccb986d79">Swift 5 ABI Stability</a></li>
<li><a href="https://zeddios.tistory.com/654">Zedd님의 ABI Stability</a></li>
</ul>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Corn"></figure><p class="title is-size-4 is-block line-height-inherit">Corn</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/protocorn93" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/RxSwift/"><span class="level-start"><span class="level-item">RxSwift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/"><span class="level-start"><span class="level-item">WWDC</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/WWDC/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-23T07:22:27.000Z">2020-08-23</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/23/Embrace-Swift-type-inference/">Embrace Swift type inference</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/Swift/">Swift</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-26T08:37:48.000Z">2020-07-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/26/GeometryReader-in-SwiftUI/">GeometryReader in SwiftUI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-19T10:36:32.000Z">2020-07-19</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/19/App-essentials-in-SwiftUI/">App essentials in SwiftUI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-15T08:26:52.000Z">2020-02-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/15/SwiftUI-under-the-hood/">SwiftUI under the hood</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-01-08T11:16:48.000Z">2020-01-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/01/08/SwiftUI%EC%97%90%EC%84%9C-%EC%97%AC%EB%9F%AC-%ED%83%80%EC%9E%85%EC%9D%98-%EB%B7%B0-%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0/">SwiftUI에서 여러 타입의 뷰 반환하기</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/03/"><span class="level-start"><span class="level-item">March 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Binding/"><span class="tag">@Binding</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/State/"><span class="tag">@State</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ABI-Stability/"><span class="tag">ABI Stability</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AnyView/"><span class="tag">AnyView</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App/"><span class="tag">App</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Thinning/"><span class="tag">App Thinning</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bitcode/"><span class="tag">Bitcode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Custom-URL-Scheme/"><span class="tag">Custom URL Scheme</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GeometryReader/"><span class="tag">GeometryReader</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Group/"><span class="tag">Group</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Opaque-Type/"><span class="tag">Opaque Type</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OptionSet/"><span class="tag">OptionSet</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PreferenceKey/"><span class="tag">PreferenceKey</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Property-Wrappers/"><span class="tag">Property Wrappers</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxSwift/"><span class="tag">RxSwift</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scene/"><span class="tag">Scene</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift5/"><span class="tag">Swift5</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SwiftUI/"><span class="tag">SwiftUI</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Universal-Links/"><span class="tag">Universal Links</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/View/"><span class="tag">View</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC/"><span class="tag">WWDC</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC19/"><span class="tag">WWDC19</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WindowGroup/"><span class="tag">WindowGroup</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/enum/"><span class="tag">enum</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS-13/"><span class="tag">iOS 13</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/some/"><span class="tag">some</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%9D%B4%EC%A7%81/"><span class="tag">이직</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Corn the blog" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>