<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Corn the blog</title><meta property="og:type" content="blog"><meta property="og:title" content="Corn the blog"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="Corn the blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://yoursite.com/images/avatar.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="images/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"Corn the blog","image":["http://yoursite.com/images/avatar.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="ca-pub-3144516292555438" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-12T11:59:12.000Z" title="2019-12-12T11:59:12.000Z">2019-12-12</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">16 minutes read (About 2450 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/12/Opaque-Types-in-Swift/">Opaque Types in Swift</a></h1><div class="content"><p>오늘은 Swift 5.1에서 처음 소개된 <strong>불투명 타입(Opaque Type)</strong>에 대해 공부해보고 기록해보려 한다. 사실 SwiftUI를 본격적으로 공부하려다 <code>some</code> 키워드에 막혀 이게 무엇인지 알아보려다 여기까지 오게 되었다. </p>
<blockquote>
<p> 이렇게 SwiftUI는 다시금 뒤로 미뤄졌다.🙄 진짜 제대로 시작해야 하는데..</p>
</blockquote>
<p>불투명 타입을 공부하면서 명확하게 이해가 된 부분도 있지만, 아직은 불투명하게 다가온 부분도 있었다. 그 이유는 아무래도 어느 문법을 공부해도 마찬가지겠지만, 직접 프로젝트에 사용하여 필요성을 느껴보지 못해서 그런 것 같다. </p>
<blockquote>
<p>@escaping 클로저를 처음 배웠을 때도 이와 비슷한 느낌이었다. </p>
</blockquote>
<p>오늘은 단순히 문법적 이해를 위한 기록으로 작성하고 추후 기회가 된다면 직접 사용해보고 이 문법이 왜 도입되었고, 언제 사용하면 좋을지 다른 사람들이 소개한 케이스가 아닌 내가 경험한 케이스를 소개해보려 한다. </p>
<hr>
<h3 id="Type-Identity"><a href="#Type-Identity" class="headerlink" title="Type Identity"></a>Type Identity</h3><p>불투명 타입을 소개하기 전 가장 먼저 본인이 불투명 타입을 공부하면서 헷갈렸던 부분을 먼저 소개해보려 한다. 스위프트 공식 문서나 여러 해외 블로그들을 읽다 보면 불투명 타입을 설명하는 데 있어 <strong>정체성(Identity)</strong>를 자주 언급하는 것을 확인할 수 있다. 정확하게 말하면 <strong>타입 정체성(Type Identity)</strong>이다.</p>
<p>타입 정체성이란 무엇일까? 몇 개의 글과 함께 예제 코드를 보고서야 조금은 감을 잡을 수 있었다. 내가 이해한 타입 정체성은 다음과 같다. </p>
<p>우린 스위프트에서 프로토콜을 타입으로써 사용할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Analytics</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirebaseAnalytics</span>: <span class="title">Analytics</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlurryAnalytics</span>: <span class="title">Analytics</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnalyticsManager</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> analytics: <span class="type">Analytics</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> analytics: <span class="type">Analytics</span>) &#123; </span><br><span class="line">    <span class="keyword">self</span>.analytics = analytics</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">sendLog</span><span class="params">()</span></span> &#123; </span><br><span class="line">    analytics.log()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager1 = <span class="type">AnalyticsManager</span>(<span class="type">FirebaseAnalytics</span>())</span><br><span class="line"><span class="keyword">let</span> manager2 = <span class="type">AnalyticsManager</span>(<span class="type">FlurryAnalytics</span>())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>전적으로 예제를 위한 예제 코드다. </p>
</blockquote>
<p><code>AnalyticsManager</code>는 어떤 애널리틱스 툴을 사용해도 로그만 전송하면 된다. 우리는 보통 이런 경우 위와 같이 프로토콜을 만들고 행위를 정의한다. 그리고 행위를 구현한 구현체를 프로토콜 타입으로써 주입해준다. </p>
<p><code>AnalyticsManager</code>가 <code>sendLog</code>를 호출할 때 <code>AnalyticsManager</code>는 <code>FirebaseAnalytics</code>나 <code>FlurryAnalytics</code>가 아닌 단지 <code>Analytics</code> 타입으로 <code>analytics</code> 프로퍼티를 사용한다. 이렇게 프로토콜 타입은 사용되는 시점에 자신의 실제 타입에 대한 정체성을 잃게 된다.</p>
<p>“잃게 된다”라는 어감(?) 때문인지 부정적으로 다가올 수 있지만 이게 프로토콜 타입을 사용하는 이유다.</p>
<blockquote>
<p>추상화의 의미를 생각해보면 정체성을 잃는다는 것을 보다 쉽게 받아들일 수 있다.</p>
</blockquote>
<p>그리고 이런 프로토콜 타입은 프로그램에 유연성을 제공해주기 때문에 의존성 주입 등 코드 작성 전반에 걸쳐 유용하게 사용된다. </p>
<p>하지만 이러한 유연성이 때로는 코드 복잡성을 야기할 수 있다. 일반적인 프로토콜 타입에는 해당하지 않지만 <code>associatedtype</code>이나 <code>Self</code>를 사용하는 프로토콜 타입은 타입으로써 반환되거나, 파라미터로 전달, 프로퍼티로 사용될 수 없다. 만일 그렇게 사용하면 우린 굉장히 익숙한 에러 메세지를 볼 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Protocol &#39;SomeProtocol&#39; can only be used as a generic constraint because it has Self or associated type requirements</span><br></pre></td></tr></table></figure>

<p>너무 돌아왔다. 결국 <strong>프로토콜 타입은 타입 정체성을 잃고 유연성을 제공</strong>한다는 것에 주목하자!</p>
<hr>
<h3 id="Opaque-Types"><a href="#Opaque-Types" class="headerlink" title="Opaque Types"></a>Opaque Types</h3><p>불투명 타입의 사용법은 간단하다. 반환되는 프로토콜 타입 앞에 <code>some</code> 키워드를 붙여주면 끝이다. 하지만 단순히 문법의 사용법만 가지곤 문법을 활용할 수 없다. 언제 불투명 타입을 사용할 수 있고, 불투명 타입을 왜 사용하는지에 대해 알아보았다. </p>
<p>이를 위해 불투명 타입이 없던 Swift 5.1 이전으로 돌아가 보자. 결제수단을 제공하는 프레임워크를 작성한다고 가정해보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">favoriteCreditCard</span><span class="params">()</span></span> -&gt; <span class="type">CreditCard</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같은 방식으로 사용자가 최근에 사용한 카드를 사용자가 선호하는 카드로 반환해줄 수 있다. 하지만 이러한 과정에서 우리는 굳이 사용자가 알 필요 없고, 알아서는 안되는 <code>CreditCard</code>라는 타입을 노출시킨다. </p>
<p>우리는 이런 문제를 프로토콜을 사용하여 해결하려 한다.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PaymentType</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CreditCard</span>: <span class="title">PaymentType</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ApplePay</span>: <span class="title">PaymentType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">favoritePaymentType</span><span class="params">()</span></span> -&gt; <span class="type">PaymentType</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> likesApplyPay &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="type">ApplePay</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>얼핏 보면 해결된 것처럼 보일 수 있지만 사용자가 <code>PaymentType</code>을 비교해야 한다면 얘기는 달라진다.  </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PaymentType</span>: <span class="title">Equatable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Equatable</code> 타입은 내부적으로 <code>Self</code>를 사용한다.</p>
</blockquote>
<p>이렇게 결제수단의 비교를 위해 <code>Equatable</code>을 사용하면 타입 정체성에서 언급한 에러 메세지를 보게 된다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Protocol &#39;PaymentType&#39; can only be used as a generic constraint because it has Self or associated type requirements</span><br></pre></td></tr></table></figure>

<p>물론 이런 문제를 제네릭과 타입 제거 기법(type erasure techniques)을 통해 해결할 수 있다. 하지만 이는 프레임워크의 사용을 더욱 어렵게 만들며 역시 의도치 않게 내부 타입을 노출시킬 수 있다. </p>
<p>불투명 타입이 이런 문제를 해결할 수 있다. 방법은 매우 간단하다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">favoriteCreditCard</span><span class="params">()</span></span> -&gt; some <span class="type">PaymentType</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>물론 방법이 매우 간단한 만큼 한계도 존재한다. 불투명 타입을 반환하는 함수는 오로지 하나의 타입만 반환할 수 있다. 위의 코드에서 함수의 반환 타입은 <code>CreditCard</code>다. 하지만 컴파일러가 이를 <code>PaymentType</code>인 것 마냥 다룬다. 내부적으론 실제 타입을 반환하는 것이기 때문에 실제 타입으로 할 수 있는 모든 것들은 할 수 있다. 즉 <strong>타입 정체성이 보장</strong>된다는 것이다. 타입의 정체성이 보장되기 때문에 <code>associatedtype</code>이나 <code>Self</code>를 사용하는 프로토콜도 반환 타입으로 바로 사용할 수 있다.</p>
<p>물론 불투명 타입의 한계도 존재한다. 이런 타입의 정체성을 보장하기 위해 하나의 타입만을 반환할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">favoritePaymentType</span><span class="params">()</span></span> -&gt; some <span class="type">PaymentType</span> &#123; </span><br><span class="line">  <span class="keyword">if</span> likesApplyPay &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="type">ApplePay</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getLastUsedCreditCard()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>즉 위와 같은 코드는 사용할 수 없다는 뜻이다. </p>
<p>다시 불투명 타입을 사용하면 어떤 점이 좋은지 이야기해보자. 위에서 언급했듯이 불투명 타입은 모듈 내부의 타입을 노출시키지 않을 수 있다. 이게 단순히 하나의 타입을 노출시키지 않는다는 것을 의미하기도 하지만, 타입이 내부적으로 어떤 타입들로 구성되어 있는지도 숨길 수 있다. </p>
<p>SwiftUI를 예로 들어보자. SwiftUI 프로젝트를 생성하면 하나의 템플릿 코드를 확인할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123; </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>바로 내가 SwiftUI 공부를 멈추고 불투명 타입을 공부하기 시작하게 된 코드다. </p>
</blockquote>
<p>이 코드에서 <code>some</code> 키워드를 사용한 이유가 뭘까? <code>some</code> 키워드를 지우면 컴파일이 되지 않는 걸까? 그렇지 않다. <code>some</code> 키워드가 없이도 충분히 프로그램을 만들 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> body: <span class="type">Text</span> &#123; </span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>some</code> 키워드를 사용하지 않고 SwiftUI로 화면을 만들어보자. SwiftUI에선 <code>VStack</code>을 이용해 스택 뷰의 형태를 구현할 수 있다. 그리고 SwiftUI에서 이런 컨테이너 타입들은 모두 제네릭 타입이다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Image</span>)&gt;&gt; &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"video.fill"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.</p>
<p>.</p>
<p>🤔</p>
<p>자자..! 일단 계속 만들어보자. 하나의 텍스트를 더 추가해보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Text</span>, <span class="type">Image</span>)&gt;&gt; &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">          	<span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"My name is Corn"</span>)</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"video.fill"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>좀 더 복잡한 레이아웃을 그려보자!</p>
<p>.</p>
<p>.</p>
<p><img src="https://i.ytimg.com/vi/-2Z0Y3Kk8nU/maxresdefault.jpg" alt=""></p>
<p>.</p>
<p>.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="type">List</span>&lt;<span class="type">Never</span>, <span class="type">TupleView</span>&lt;(<span class="type">HStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Text</span>)&gt;&gt;, <span class="type">Text</span>)&gt;&gt;, <span class="type">HStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">VStack</span>&lt;<span class="type">TupleView</span>&lt;(<span class="type">Text</span>, <span class="type">Text</span>)&gt;&gt;, <span class="type">Text</span>)&gt;&gt;)&gt;&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">      .....</span><br><span class="line">      ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자 완성했다! 근데 중간 어디쯤에 있는 <code>Text</code>를 <code>Image</code>로 바꾸려 한다! 그러면…🤯</p>
<p>이쯤 되면 왜 불투명 타입이 필요한지 절실히 깨달을 수 있다. 우린 단지 <code>body</code>가 <em>어떤(some)</em> <code>View</code> 타입을 반환한다 정도만 알고 싶은 것이다. 그리고 그 정도의 정보만 필요하다. </p>
<p>우린 <code>some</code> 키워드로 <code>body</code>는 단지 <code>View</code> 타입을 반환한다는 사실을 명시해줄 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      .....</span><br><span class="line">      ........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>아직은 내가 직접 작성한 모듈 혹은 프로젝트에서 불투명 타입을 사용해보진 못했다. 하지만 이젠 불투명 타입의 존재와 언제 사용하면 좋을지에 대해 훑어보았기 때문에 다음에 기회가 왔을 때 불투명 타입 사용을 고려해볼 수 있게 되었다. </p>
<blockquote>
<p>SwiftUI 공부도 다시 시작할 수 있다!</p>
</blockquote>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://medium.com/@PhiJay/whats-this-some-in-swiftui-34e2c126d4c4">What’s this “some” in SwiftUI</a></li>
<li><a href="https://swiftrocks.com/understanding-opaque-return-types-in-swift.html">Understanding Opaque Return Types in Swift</a></li>
<li><a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html">Opaque Types</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-25T12:53:20.000Z" title="2019-11-25T12:53:20.000Z">2019-11-25</time><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">20 minutes read (About 3016 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/25/Universal-Link-Custom-URL-Scheme/">Universal Link &amp; Custom URL Scheme</a></h1><div class="content"><p>커스텀 스킴과 유니버셜 링크에 대해 알아보도록 하자. </p>
<p>이 둘에 대해 얼핏 많이 들어보았을 것이다. 단순히 말해 모두 딥링크를 지원하는 방법이다. 그렇다면 이 둘의 차이점은 무엇일까? 그리고 딥링크의 역할은 무엇이며 딥링크를 통해 우리는 어떤 이점을 얻을 수 있을까. 이것도 함께 알아보도록 하자. </p>
<h3 id="딥-링크란"><a href="#딥-링크란" class="headerlink" title="딥 링크란?"></a>딥 링크란?</h3><p>위키피디아의 정의에 따르면 딥링크는 <strong>특정 페이지에 도달할 수 있는 링크</strong>를 말한다. 링크란 단어는 실생활 대화에서도 많이 사용하고 실제로 링크도 많이 사용한다. </p>
<p>*”야~ 내가 링크 보냈어 확인해봐”*</p>
<p>우리는 실생활에서 이런 말을 자주 하곤 한다. 그렇다면 위의 말에 담긴 뜻은 무엇일까? 그것은 바로 정보 전달이다. 정보 전달로는 부족하다. 편리한 정보 전달이다. 그럼 여기서 편리하다는 것은 무엇을 의미할까?</p>
<p>상대방이 내가 알려준 정보, 컨텐츠를 스스로 키워드를 이용하여 검색을 통해 접하는 것이 아닌 링크로 하여금 상대방에게 내가 전달하고자 하는 정보, 컨텐츠를 바로 노출시키는 것이 나는 <strong>편리한 정보 전달의 수단</strong>으로써의 링크라고 생각한다.</p>
<p>위의 *”야~ 내가 링크 보냈어 확인해봐”*의 링크가 딥링크다. 이 딥링크는 단순히 웹 브라우저 상에서만 존재하는 수단이 아니다. 우린 이런 딥링크를 이용해 특정 앱의 특정 컨텐츠를 상대방에게 편리하게 전달할 수 있다. </p>
<p>이렇게 우리는 딥링크를 통해 사용자에게 우리 앱의 컨텐츠를 <strong>Seamless</strong>하게 노출시킬 수 있다. </p>
<hr>
<h3 id="커스텀-URL-스킴이란"><a href="#커스텀-URL-스킴이란" class="headerlink" title="커스텀 URL 스킴이란?"></a>커스텀 URL 스킴이란?</h3><p>커스텀 스킴은 iOS에서 딥링크를 지원하는 방법 중 하나이다.</p>
<blockquote>
<p>현재는 애플에서 유니버셜 링크를 사용하도록 강력하게 추천하고 있다. </p>
<p>Universal links are strongly recommended as a best practice.</p>
<p>이 이유에 대해선 밑에서 천천히 살펴보도록 하자. </p>
</blockquote>
<p>공식 문서에서 커스텀 URL 스킴을 <u>앱 내의 자원에 접근할 수 있는 방법을 제공할 수 있는 방법</u>이라고 설명하고 있다. 애플은 시스템 앱들에 대해 미리 정의된 앱 스킴을 제공한다. <code>mailto</code>, <code>tel</code> 그리고 <code>facetime</code>이 그것들이다.</p>
<p>커스텀 URL 스킴을 지원하는 방법은 어렵지 않다. </p>
<ol>
<li><p>앱의 URL 포맷을 정의한다. </p>
</li>
<li><p>스킴을 등록해 시스템이 정의된 URL에 따라 알맞는 앱으로 사용자를 보낼 수 있도록 한다. </p>
<p><img src="https://docs-assets.developer.apple.com/published/3dcc25d414/8239bd2e-1dd6-414e-9754-63f9ac3b0633.png" alt=""></p>
</li>
<li><p>앱이 열린 URL을 적절히 처리해야 한다. </p>
</li>
</ol>
<p>URL은 반드시 정의된 커스텀 스킴 이름으로 시작해야 하며 파라미터를 함께 넘겨 이에 따른 별도의 동작을 처리하게 할 수도 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"myphotoapp:Vacation?index=1"</span>)</span><br><span class="line">       </span><br><span class="line"><span class="type">UIApplication</span>.shared.<span class="keyword">open</span>(url!) &#123; (result) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> result &#123;</span><br><span class="line">       <span class="comment">// The URL was delivered successfully!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 정의된 커스텀 스킴은 문서에서도 중복되지 않게 작성하라고 권고하고 있다. 그럼에도 불구하고 커스텀 스킴은 중복이 발생할 수 있다. 그리고 이렇게 중복된 스킴을 갖고 있는 두 앱이 존재한다면 시스템은 사용자가 의도하지 않은 다른 앱을 실행시키게 될 수 있다. </p>
<p>또한 앱이 설치되어 있지 않다면 스킴은 동작하지 않는다. <a href="https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl"><code>canOpenURL(_:)</code></a>를 통해 스킴에 해당하는 URL을 열 수 있는지를 검사할 수 있지만 앱이 설치되어 있지 않았을 때 우리가 원하는 궁극적인 행동은 커스텀 URL 스킴으로는 한계가 있다. </p>
<p>그렇다면 여기서 “우리가 궁극적인 행동”이란 무엇일까? </p>
<p>우리는 다른 앱에서 우리의 컨텐츠를 그대로 보여주는 것이 아닌 사용자가 우리 앱에서 우리의 컨텐츠를 소비할 수 있도록 이동시키고 싶을 것이다. (사파리를 통해 미디움의 컨텐츠를 보는 것보다, 미디움 앱을 통해 컨텐츠를 보는 것이 보다 쾌적한 사용자 경험을 제공할 수 있다.)</p>
<p>하지만 앱이 설치되어 있지 않았을 때 단순히 이동시키지 못하는 것에 그치지 않고 최소한 우리 앱을 설치할 수 있는 앱 스토어로 이동이라도 시켜준다면 우리 앱으로의 유입은 앞의 상황보다 더욱 나아질 수 있다. </p>
<p>위의 내용을 통해 우리는 커스텀 URL 스킴의 두 가지 단점을 알 수 있었다.</p>
<ol>
<li>중복이 일어나 다른 앱을 실행시킬 수 있다.</li>
<li>앱이 설치되어 있지 않을 때 충분한 조치를 취할 수 없다. </li>
</ol>
<p>그리고 1번의 이유는 치명적인 보안 이슈의 여부도 있기 때문에 애플은 이러한 커스텀 URL 스킴의 단점을 보완하고자 유니버셜 링크라는 것을 만들었다.</p>
<blockquote>
<p><strong>중요</strong></p>
<p>iOS 9.0 이상의 앱에선 열고자 하는 앱의 커스텀 스킴을 <code>Info.plist</code>의 <code>LSApplicationQueriesSchemes</code>키의 값으로 반드시 등록을 해야 한다. 그렇지 않으면 설령 해당 스킴의 앱이 설치되어 있다 하더라도 <code>canOpenURL(_:)</code> 메소드는 항상 <code>false</code>를 반환할 것이다.</p>
</blockquote>
<hr>
<h3 id="유니버셜-링크란"><a href="#유니버셜-링크란" class="headerlink" title="유니버셜 링크란?"></a>유니버셜 링크란?</h3><p>유니버셜 링크도 커스텀 URL 스킴과 동일하게 모바일 환경에서 딥링크를 지원하기 위한 수단이다. 하지만 유니버셜 링크는 앱이 설치되어 있지 않으면 웹 페이지를 통해 컨텐츠를 보여준다는 것이다. (물론 앱이 설치되어 있다면 바로 해당 앱을 실행시켜 컨텐츠를 보여준다.) 그렇기 때문에 유니버셜 링크는 표준 HTTP, HTTPS 링크다.</p>
<blockquote>
<p>앱이 설치되어 있지 않을 경우 유니버셜 링크를 통해 컨텐츠를 웹을 통해 노출시키는 방법과 앱 스토어로 사용자를 보내는 방법이 있다.</p>
</blockquote>
<p>서비스에 유니버셜 링크를 지원하기 위해선 웹 서버에서의 별도의 작업을 필요로 한다. 앱의 번들 ID와 앱이 열어야 할 경로(path)를 포함하는 <strong>AASA(Apple-App-Site-Association</strong> 파일이 웹 서버에 등록되어 있어야 한다. </p>
<p>AASA 파일을 서버에 등록해야 하기 때문에 해당 도메인 소유자가 아닌 이상 등록을 할 수가 없다. 그렇기 때문에 고유하고 안전하게 딥링크를 지원할 수 있다. </p>
<p>AASA 파일은 JSON 형태로 다음과 같이 작성되어야 한다. </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"applinks"</span>: &#123;</span><br><span class="line">        <span class="attr">"apps"</span>: [],</span><br><span class="line">        <span class="attr">"details"</span>: [&#123;</span><br><span class="line">            <span class="attr">"appID"</span>: <span class="string">"D3KQX62K1A.com.example.photoapp"</span>,</span><br><span class="line">            <span class="attr">"paths"</span>: [<span class="string">"/albums"</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="attr">"appID"</span>: <span class="string">"D3KQX62K1A.com.example.videoapp"</span>,</span><br><span class="line">            <span class="attr">"paths"</span>: [<span class="string">"/videos"</span>]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>appID: <team identifier>.<bundle identifier>의 포맷의 값으로 앱의 식별자를 의미하는 값. </p>
</li>
<li><p>paths: 앱에서 처리할 수 있는 링크 경로의 배열</p>
<blockquote>
<p>와일드카드 문자를 사용해 보다 다양한 경로를 간편하게 지원할 수 있다. </p>
<p><code>/videos/samples/201?/*</code> : <code>videos/sample</code>에서 2010년대(<code>201?</code>)의 하위 모든 경로를 의미한다.  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>이미 웹 브라우저를 통해 컨텐츠를 즐기고 있던 사용자가 웹 브라우저 컨텐츠 내부의 유니버셜 링크를 클릭하면 웹 브라우저를 통해 계속해서 컨텐츠를 즐기수 있도록 한다. 계속해서 웹 브라우저에서 컨텐츠를 즐기던 사용자를 앱으로 보내버리는 것은 오히려 사용자 경험을 해칠 수 있기 때문이다.</p>
</blockquote>
<p>사용자가 유니버셜 링크를 클릭하여 링크가 활성화되면 iOS는 앱을 실행시키고 <a href="https://developer.apple.com/documentation/foundation/nsuseractivity"><code>NSUserActivity</code></a> 객체에 정보를 담아보낸다. 그리고 사용자는 <code>AppDelegate</code> 메소드인 <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623072-application">application(_:continue:restorationHandler:)</a>를 오버라이딩하여 처리한다.</p>
<p>유니버셜 링크 활성화를 통해 전달된 <code>NSUserActivity</code>의 <code>activityType</code>은 <a href="https://developer.apple.com/documentation/foundation/nsuseractivitytypebrowsingweb"><code>NSUserActivityTypeBrowsingWeb</code></a>이다. 또한 <code>NSUserActivity</code> 객체의 <a href="https://developer.apple.com/documentation/foundation/nsuseractivity/1418086-webpageurl"><code>webpageURL</code></a> 프로퍼티는 사용자가 클릭한 URL을 포함하고 있다. 그리고 <a href="https://developer.apple.com/documentation/foundation/nsurlcomponents"><code>NSURLComponents</code></a>를 통해 URL의 경로나 파라미터를 추출해낼 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">continue</span> userActivity: NSUserActivity,</span></span></span><br><span class="line"><span class="function"><span class="params">                 restorationHandler: @escaping <span class="params">([<span class="keyword">Any</span>]?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">guard</span> userActivity.activityType == <span class="type">NSUserActivityTypeBrowsingWeb</span>,</span><br><span class="line">  <span class="keyword">let</span> incomingURL = userActivity.webpageURL,</span><br><span class="line">  <span class="keyword">let</span> components = <span class="type">NSURLComponents</span>(url: incomingURL, resolvingAgainstBaseURL: <span class="literal">true</span>),</span><br><span class="line">  <span class="keyword">let</span> path = components.path,</span><br><span class="line">  <span class="keyword">let</span> params = components.queryItems <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"path = \(path)"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> albumName = params.first(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.name == <span class="string">"albumname"</span> &#125; )?.value,</span><br><span class="line">  <span class="keyword">let</span> photoIndex = params.first(<span class="keyword">where</span>: &#123; $<span class="number">0</span>.name == <span class="string">"index"</span> &#125;)?.value &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"album = \(albumName)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"photoIndex = \(photoIndex)"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Either album name or photo index missing"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="번외"><a href="#번외" class="headerlink" title="번외"></a>번외</h3><p>일반적인 딥링크가 아닌 <strong>디퍼드 딥링크(Deferred)</strong>라는 개념이 존재한다. 그럼 디퍼드 딥링크는 기존의 딥링크와 다른 점은 무엇일까? </p>
<p>기존의 딥링크를 통해 우리가 할 수 있는 최선의 행동은 웹을 통해 컨텐츠를 보여주던지, 혹은 앱스토어로 사용자를 보내는 것에 불과하다. 디퍼드 딥링크를 굳이 번역해보자면 <strong>지연된 딥링크</strong> 정도로 해석해볼 수 있을 것이다. 그렇다면 여기서 무엇이 지연되었다는 것일까? </p>
<p>상황을 가정해보자. 앱이 설치되어 있지 않은 상태에서 기존의 딥링크를 통해 앱스토어까지 사용자를 보냈고 사용자가 앱을 설치했다. 딥링크의 궁극적인 목표는 앱의 설치가 아니라 특정 컨텐츠로 사용자를 보내는 것이다. 그렇기 때문에 현재 상황에서 딥링크 본연의 목적을 달성했다고 보기는 힘들다. 여기서 디퍼드 딥링크가 이런 문제를 해결해 줄 수 있다.</p>
<p>디퍼드 딥링크를 사용하면 링크를 통해 앱스토어로 보내진 사용자가 앱을 설치하고 최초로 앱을 실행시켰을 때 최초 링크를 통해 보여주었어야 할 컨텐츠로 사용자를 이동시킨다. 이렇게 앱스토어 &gt; 앱 설치 &gt; 앱 실행이라는 지연된 과정을 거쳐 컨텐츠를 사용자에게 보여줄 수 있는 기능의 딥링크를 디퍼드 딥링크라고 한다.</p>
<p>그렇다면 링크를 통해 앱을 설치하고 최초로 실행한 사용자와 일반적으로 앱 스토어에서 바로 앱을 설치하여 최초로 실행한 사용자를 어떻게 구분하여 컨텐츠를 보여줄까? 이 부분에 대해서 정확하게 설명된 내용을 찾기 힘들었지만 큰 그림에서 설명해준 글에선 이를 다음과 같이 설명하고 있다. </p>
<p> <em>Historically <strong>this has been done through fingerprinting.</strong> Fingerprinting works by generating a “fingerprint” of a web user <strong>consisting of a device’s IP address and user-agent (operating system, operating system version, and other device specific parameters)</strong> and generating another fingerprint when a user opens the app. Recent techniques like Branch’s People Based Attribution model have moved beyond fingerprinting to using an unique Identity Graph that matches a device’s unique browser identifier to its unique app identifier, tying it back to the actual user across web and app to achieve true cross platform attribution, giving better matching between link licks and app opens.</em></p>
<hr>
<p><strong>참고자료</strong></p>
<ol>
<li><a href="https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content">Allowing Apps and Websites to Link to Your Content</a></li>
<li><a href="https://medium.com/@abhimuralidharan/universal-links-in-ios-79c4ee038272">Universal links in iOS</a></li>
<li><a href="https://branch.io/glossary/deferred-deep-linking/">Deferred Deep Linking</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-10-13T11:42:03.000Z" title="2019-10-13T11:42:03.000Z">2019-10-13</time><span class="level-item">24 minutes read (About 3610 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/10/13/8%EC%9B%94-%EB%A7%90%EB%B6%80%ED%84%B0-%EC%A7%80%EA%B8%88%EA%B9%8C%EC%A7%80%EC%9D%98-%EA%B7%BC%ED%99%A9-feat-%EC%9D%B4%EC%A7%81%EA%B8%B0/">이직기 (feat. 근황)</a></h1><div class="content"><h3 id="근황-👣"><a href="#근황-👣" class="headerlink" title="근황 👣"></a>근황 👣</h3><p>이직을 하게 되었고 퇴사를 했다.</p>
<p>10월 중순에 퇴사를 하고 새 회사로 출근하는 것으로 정해졌지만 전 회사 사정으로 의도치 않게 9월까지 마무리하는 것으로 결정나서 애매하게 시간이 떠버리게 되었다.</p>
<p>그래서 나만의 시간, 가족과의 시간을 보내게 되었다. </p>
<p>10월 첫째 주는 제주도로 혼자 여행을 떠났고, 10월 둘째 주는 가족과 예정되어 있던 코타키나발루로 떠나게 되었다. 그리고 출근 마지막 주인 10월 셋째 주는 학교도 방문하고, 다시 출근을 하면 만나기 힘들 것 같은 지인들도 만나려 한다. </p>
<p>그리고 틈틈이 평소에 읽고 싶었던 문서나 책을 읽으며 시간을 보내고 있다. (효율적으로 시간을 보내고 있는 것 같지는 않다.😅) </p>
<p>나만의 시간을 보내게 되어 나태해졌는지 블로그에 소홀해졌다. 그래서 이렇게 근황과 이직기를 시작으로 다시금 글을 써보려 한다.</p>
<h3 id="이직기-🏢-➡️-🏬"><a href="#이직기-🏢-➡️-🏬" class="headerlink" title="이직기 🏢 ➡️ 🏬"></a>이직기 🏢 ➡️ 🏬</h3><p><strong>이직을 결심하게 된 이유</strong></p>
<p>군대와 동아리 등 여러 단체 생활을 하면서 느낀 점은 누구와 함께 하는지가 가장 중요하다는 것이었다. 이는 직장 생활에서도 동일하게 작용한다고 생각한다. 어쩌면 직장 생활에서 가장 중요한 부분 중 하나라고 생각한다. </p>
<p>다행히 전 직장을 포함해서 난 <strong>사람 운</strong>은 정말 좋았다고 생각한다. 팀원들과 의사소통을 하면서 내가 부족한 점이 무엇인지를 많이 깨닫게 되었고 또한 팀원들을 보면서 스스로 어떻게 개선해야 할지도 깨닫게 되었다. 기술적인 토론도 심심치 않게 나누어 팀원들의 훌륭한 지식도 여러 방면으로 습득하게 되었다. 위의 내용을 한 줄로 요약하자면 <strong>사람 때문에 이직하게 된 것은 아니다.</strong> 오히려 사람 때문에 아쉬움이 컸다.</p>
<p>내가 이직을 하게 된 계기는 서비스에 있다. 결정적인 이유는 서비스와 내가 맞지 않았다고 생각한다. 나는 퇴근을 하고선 이슈가 터지지 않는 이상 회사 앱을 켜본 기억이 드물다. 내가 만들고 있는 앱이지만 내가 사용하지 않았단 이야기다. 개인적으로 나는 내가 잘 사용할 수 있는 서비스를, 내가 필요한 서비스를 만들 때 스스로 더 재미를 느끼고 개발을 하는 것 같다. </p>
<p>물론 평생 나와 맞는 것, 내가 재미를 느끼는 것만 개발할 수 있다고는 생각하지 않는다. 하지만 적어도 주니어 개발자에겐 재미를 느끼고 개발한다는 동기부여가 필요하다고 생각한다. 이런 나의 가치관과 전 회사의 서비스는 맞지 않았다. </p>
<p>또한 전 회사의 서비스는 비교적 보편적인 서비스는 아니었다고 생각한다. 현재는 특수한 목적을 갖고 서비스를 사용하는 사용자가 대다수였다. 개인적으로 나는 사람들의 일상에 녹아있는 보편적인 서비스를 개발하고 싶은 마음이 컸다. </p>
<p>위의 내용을 토대로 다음 회사는 다음의 세 가지를 충족하길 원했다.</p>
<ol>
<li>커뮤니케이션이 활발한 조직</li>
<li>내가 자주 사용할 수 있는 서비스 </li>
<li>보편적인 서비스</li>
</ol>
<p>물론 주변의 많은 사람들이 *”적어도 2년, 아니 1년이라도 채우고 움직여라”<em>라는 조언을 많이 해주었다. 내가 생각해도 그 조언은 틀리지 않았고 나 같아도 주변에 그렇게 조언을 해줄 것 같다. 하지만 내가 1년도 채우지 않고 이직을 하기로 결정하게 된 계기는 나에겐 *”1년도 채우지 않고 이직했다”</em>라는 꼬리표를 감수할 수 있을 만큼 위에 나열된 부분에 대한 욕망이 더욱 컸기 때문이라고 생각한다. 어쩌면 나는 평생 다른 사람들에게 이러한 이유들을 수없이 “해명”해야 할 수도 있다. 하지만 그런 점을 감수하고도 보다 빨리 내 개발 가치관과 맞는 회사를 찾는 것이 중요하다고 판단한 것이다.</p>
<p><strong>내가 문을 두드렸던 기업 리스트</strong></p>
<p>많은 기업에 지원한 것은 아니지만 그 나름대로 의미가 있을 것이라고 생각하여 이렇게 기록을 해본다. </p>
<blockquote>
<p>순서는 무관하며 기업명은 밝히지 않도록 하겠습니다. 기업을 설명하는 코멘트는 개인적인 주관이 포함되어 있을 수 있습니다. </p>
</blockquote>
<ul>
<li><p><strong>국내 OTT 서비스 중 가장 영향력이 높다고 생각하는 W사</strong></p>
<ul>
<li><p><strong>지원 경로</strong> : 프로그래머스 2019 앱 개발자 온라인 잡 페어</p>
</li>
<li><p><strong>채용 프로세스</strong> : </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/grepp-cloudfront/programmers_imgs/competition-imgs/+webdev-process.png" alt=""></p>
<blockquote>
<p>W사는 기업 개별 전형에선 과제 전형을 진행</p>
</blockquote>
</li>
<li><p><strong>결과</strong> : 과제 전형에서 <strong>탈락</strong></p>
</li>
<li><p>개인적으로 네이버 핵데이를 통해서 잠깐 경험했던 미디어 프로그래밍에 대해 관심도 있었고, 서비스 자체도 애용했던 서비스라 지원을 하게 되었다. 과제 전형을 진행하게 되었고, 과제 전형에선 어떤 라이브러리를 사용해도 무관하다고 안내받았다. 48시간이라는 시간 내에 주어진 과제를 제출해야 했다. 처음엔 48시간이 충분하다고 생각했으나 일과 병행하려니 시간은 생각보다 많이 촉박했다. 기능 구현에 대한 고민과 더불어 프로그램 구조에 대한 고민을 함께 하려니 나에겐 턱없이 부족한 시간이었다. 어찌어찌 제출은 하였으나 내가 생각해도 완성도가 높진 않았다고 생각했고, 결과는 내가 예상한 것에서 벗어나지 않았다. </p>
</li>
<li><p><strong>채용 과정에서 좋았던 점</strong> : 과제에 대한 결과와 더불어 과제에 대한 피드백이 주어졌다는 점에서 무엇이 부족했는지 납득할 수 있었고 내 코드를 되돌아볼 수 있는 계기가 되었다. </p>
</li>
<li><p><strong>채용 과정에서 아쉬웠던 점</strong> : 과제 안내 메일에서 자사 서비스 UI를 참고하여 개발하되 동일할 필요는 없다고 언급하였으나 피드백에선 “<em>UI 구현에서 자사 서비스 앱과 비슷하게 구현하셨으면 했습니다.</em>“라는 피드백을 받아 이 피드백에 대해선 조금은 납득하기 어려웠다. 하지만 과제를 내는 기업 입장에선 자사 서비스와 유사하게 구현되어 있으면 당연히 좋은 인상을 받을 수 있다는 것은 부인하기 힘든 사실인 것 같다.</p>
</li>
</ul>
</li>
<li><p><strong>동네 기반 중고 직거래 플랫폼 서비스 D사</strong></p>
<ul>
<li><p><strong>지원 경로</strong> : W사와 동일</p>
</li>
<li><p><strong>채용 프로세스</strong> : W사와 동일</p>
<blockquote>
<p>D사는 기업 개별 전형에서 전화 면접을 진행</p>
</blockquote>
</li>
<li><p><strong>결과</strong> : 최종 면접에서 <strong>탈락</strong></p>
</li>
<li><p>서비스를 사용하면서 굉장히 만족도가 높았던 서비스였고, 기타 다른 중고 거래 플랫폼들에 비해 신뢰도가 상당히 높았던 서비스였다. 또한 슈퍼 개발자분들이 모여 계신 기업으로 iOS 개발자분도 유명하신 분이시라 더욱 함께하고 싶은 마음이 컸다. 전화 면접에서는 iOS 전반에 걸친 질문들을 해주셨고, 간단한 CS에 관한 질문도 해주셨다. 전화 면접을 통과하고 최종 면접을 진행했고, 합류하고 싶었던 마음이 컸던지 다른 기업 면접과는 비교가 안될 정도로 크게 긴장하였다. 그로 인해 알고 있던 내용들도 제대로 답하지 못했다. 또한 끝나고 들었던 생각이지만 너무 내 의견만을 고집했던 경향이 없지 않아 있었던 것 같다. 하지만 덕분에 보다 사고적으로 열릴 수 있었던 계기였다. </p>
</li>
<li><p><strong>채용 과정에서 좋았던 점</strong> : 확실히 유연한 분위기 속에서 면접이 진행되었고, 면접관으로 들어오신 분들 모두가 지원자를 배려하려는 마음이 느껴져서 좋았다. 또한 면접비도 제공이 되었다.🤑 시간이 어느 정도 흐르고 한 개발자 컨퍼런스에서 면접관으로 들어오셨던 분이 나를 알아보시고 말씀을 걸어주셔서 굉장히 감사하게 생각했다.</p>
</li>
</ul>
</li>
<li><p><strong>한국의 글로벌 키즈 컨텐츠 기업 S사</strong></p>
<ul>
<li><strong>지원 경로</strong> : 지인의 추천</li>
<li><strong>채용 프로세스</strong> : 서류 전형 ➡️ 1차 실무진 면접 ➡️ 2차 CEO 및 인사팀 면접 (최종 면접)</li>
<li><strong>결과</strong> : <strong>최종 합격</strong></li>
<li>이 회사는 D사 최종 면접을 보러 갔던 날 마주쳤던 지인의 추천으로 지원하게 된 기업이다. 이 기업은 미국에 거주하는 어린 조카들을 통해 먼저 알게 되었고, 국내 기업이라는 점에서 적지 않게 놀랐던 기억이 난다. 글로벌 컨텐츠로는 국내에서 높은 지위를 갖고 있는 기업이라고 생각이 든다. 서류 전형을 거쳐 진행한 1차 실무진 면접의 난이도는 꽤나 높았던 것으로 기억한다. 부족한 CS 지식에 대해 깊이 파고드는 질문들이 이어졌고 만족스러운 답변을 하지 못했던 것 같다. 또한 iOS에 관한 질문에서도 평소에는 그냥 넘어갔을 부분에 대해 질문이 들어와 적지 않게 당황했던 기억이 난다. 1차 면접을 그리 잘 보지 않았던 터라 기대는 하지 않았으나 1차 면접에 합격하여 최종 면접에 임했고 최종 면접답게 조금은 추상적인 질문들을 주고받으며 면접을 진행했다. 그리고 얼마 뒤 최종 합격 통보를 받았다.</li>
<li><strong>채용 과정에서 좋았던 점</strong> : 모든 채용 프로세스가 신속하게 진행되었다. 역시 면접관으로 들어오셨던 분들의 배려로 편안한 분위기 속에서 면접을 진행할 수 있었다.</li>
</ul>
</li>
<li><p><strong>일상에서 누구나 누릴 수 있는 금융의 이로운 흐름을 만드는 K사</strong></p>
<ul>
<li><strong>지원 경로</strong> : 헤드헌팅</li>
<li><strong>채용 프로세스</strong> : 서류 전형 ➡️ 과제 전형 ➡️ 1차 실무진 면접 ➡️ 2차 CTO 및 인사팀 면접 (최종 면접)</li>
<li><strong>결과</strong> : <strong>최종 합격</strong></li>
<li>헤드헌터를 통한 대규모 채용을 진행하고 있던 기업이었고, 나 역시 헤드헌터로부터 채용 관련 연락을 받았다. 내가 일상에서 상당히 애용하고 있는 간편 결제 서비스를 제공하는 기업으로 앱 역시 상당히 잘 만들어져 있다는 인상을 받고 있던 터라 주저 없이 지원을 하게 되었다. 서류 전형 이후 주어진 과제는 재직자를 감안하여 2주라는 넉넉한 시간이 주어졌고, 덕분에 기능 외적으로 구조적인 부분에 대해 많은 고민을 할 수 있었다. 과제를 완성하고 관련 도큐먼트를 작성하는데도 적지 않은 노력을 기울였다. 과제 전형 합격 이후 1차 면접에선 주어진 시간 중 90%는 과제 리뷰로 진행되었다. 내가 작성한 코드에 대해 면접관분들과 많은 의견을 나누었고, 이러한 과정 속에서 내가 생각한 의도를 충분히 전달할 수 있었다.  1차 면접 과정은 굉장히 즐거운 시간으로 기억된다. 의견을 나누는 과정에서 무엇이 서툴렀고, 무엇을 잘못 생각했는지 깨달을 수 있던 시간이었다. 그리고 1차 면접을 보고 돌아오는 길에 합격 통보를 받았고 2차 면접 일정을 잡았다. 금요일에 진행된 2차 면접은 CTO님과 두 분의 인사담당분들이 함께 했다. 1차 면접과는 사뭇 분위기가 달랐고 조금 더 경직된 분위기에서 면접은 진행되었다. 그리고 1시간 30분 넘게 진행되었던 1차 면접과는 다르게 40분 만에 면접이 끝났다. 이로 인한 불안감은 있었지만 월요일에 최종 합격 통보를 받을 수 있었다.</li>
<li><strong>채용 과정에서 좋았던 점</strong> : 모든 채용 프로세스가 신속하게 진행되었다. 1차 실무진 면접은 면접이라는 상황을 떠나 굉장히 즐거운 경험으로 기억된다. 과제 전형 역시 프로그램 전반적으로 많은 고민을 해볼 수 있는 경험이었다. 채용 프로세스를 진행하면서 이렇게 간절함이 컸던 회사는 처음이었다. </li>
</ul>
</li>
</ul>
<p>결과적으로 내가 일상에서 상당히 자주 애용하는 서비스를 운영하는 <strong>K사를 선택하였다.</strong> 그리고 끝이 아닌 새로운 시작이라고 생각하며 해당 서비스에 기여하고 싶은 마음이 상당히 크다. 더 많은 개발자분들과 더 많은 대화를 나눌 수 있다는 기대감도 크다. 그리고 그런 과정에서 느끼고 배운 것들을 주기적으로 글을 통해 기록해보려 한다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-07-28T04:55:49.000Z" title="2019-07-28T04:55:49.000Z">2019-07-28</time><span class="level-item"><a class="link-muted" href="/categories/RxSwift/">RxSwift</a></span><span class="level-item">25 minutes read (About 3745 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/28/RxSwift-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0/">RxSwift 들여다보기</a></h1><div class="content"><h3 id="RxSwift-들여다보기"><a href="#RxSwift-들여다보기" class="headerlink" title="RxSwift 들여다보기"></a>RxSwift 들여다보기</h3><hr>
<p>RxSwift를 들여다보려 한다. 이유는 간단하다. 내부 동작 원리가 궁금했다. </p>
<p>이 궁금증의 시작은 RxSwift의 대표적인 개념에서부터 시작했다. 정확히 말하자면 RxSwift만의 대표적인 개념이 아니라 리액티브 프로그래밍 언어들에서 볼 수 있는 대표적인 개념들이다. </p>
<ul>
<li><code>Observable</code></li>
<li><code>Observer</code></li>
<li><code>Subscription</code></li>
</ul>
<p>리액티브 프로그래밍 언어에서 <code>Observable</code>은 이벤트 스트림을 흘려보내고 <code>Observer</code>는 이를 <code>Subscription</code>하여 이벤트에 반응하게 된다. </p>
<p>처음 RxSwift를 접했을 때 이 문장을 읽고 이해하는데 그렇게 오랜 시간이 걸리지 않았다. 하지만 코드를 작성하고 읽기 시작하면서 하나의 의문점이 생겼는데, 계속 공부를 하면 해결이 될까 했던 궁금증이 여전히 해결되지 않는 모습을 보였다. </p>
<p>그 궁금증의 주체는 바로 <code>Observer</code>다. 간단한 코드를 살펴보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.just(<span class="string">"Hello World"</span>).subscribe(onNext: &#123; </span><br><span class="line">  <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>이 곳에서 위에서 언급된 대표적인 개념들을 찾아보자. </p>
<p><code>Observable</code>과 <code>Subscription</code>은 육안으로 확인할 수 있다. 그렇다면 <code>Observer</code>는 어디 있을까. 이게 내 궁금증의 시작이었다. 코드를 그대로 해석하면 <code>Observable</code>을 바로 <code>Subscription</code>하는 모습을 확인할 수 있다.</p>
<p> *”여기서 <code>Observer</code>는 누구지 “* </p>
<p>그래서 RxSwift 소스 코드를 열어보았다. </p>
<h3 id="ObservableType"><a href="#ObservableType" class="headerlink" title="ObservableType"></a>ObservableType</h3><hr>
<p>먼저 <code>ObservableType</code>부터 살펴보자. <code>ObservableType</code>은 프로토콜로 <code>Observable</code>은 <code>ObservableType</code>을 따른다. <code>ObservableType</code>을 바로 보기 전에 앞서 <code>ObservableType+Extensions.swift</code> 파일 안의 <code>extension</code>부터 시작해보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(onNext: <span class="params">(<span class="params">(Element)</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>, onError: ((<span class="type">Swift</span>.<span class="type">Error</span>) -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>, onCompleted: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>, onDisposed: (() -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>)</span><br><span class="line">    -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> disposable: <span class="type">Disposable</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">            disposable = <span class="type">Disposables</span>.create(with: disposed)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            disposable = <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">            <span class="keyword">let</span> synchronizationTracker = <span class="type">SynchronizationTracker</span>()</span><br><span class="line">        #endif</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> callStack = <span class="type">Hooks</span>.recordCallStackOnError ? <span class="type">Hooks</span>.customCaptureSubscriptionCallstack() : []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">Element</span>&gt; &#123; event <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">                synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">                <span class="keyword">defer</span> &#123; synchronizationTracker.unregister() &#125;</span><br><span class="line">            #endif</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">switch</span> event &#123;</span><br><span class="line">            <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">                onNext?(value)</span><br><span class="line">            <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">                    onError(error)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">                &#125;</span><br><span class="line">                disposable.dispose()</span><br><span class="line">            <span class="keyword">case</span> .completed:</span><br><span class="line">                onCompleted?()</span><br><span class="line">                disposable.dispose()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create(</span><br><span class="line">            <span class="keyword">self</span>.asObservable().subscribe(observer),</span><br><span class="line">            disposable</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⁉️</p>
<p>벌써 첫 번째 궁금증이 해결되었다! <code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code> 내부적에서 생성되고 있었다. </p>
<p>우리가 넘겨준 <code>onNext</code>, <code>onError</code>, <code>onCompleted</code> 그리고 <code>onDisposed</code>들이 내부적으로 어떻게 사용되고 있는지 살펴보자. 꽤나 직관적인 걸 알 수 있다. 하지만 첫 번째 궁금증이 해결된 것과 동시에 여러 궁금증들이 생겼다.</p>
<p>직관적이어도 정확히 어떻게 동작하는지는 이 코드만 봐서 나는 모두 알 수 없었다. 그래서 하나씩 따라 들어가 보았다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> disposed = onDisposed &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create(with: disposed)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  disposable = <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>먼저 <code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code> 메소드에 <code>onDisposed</code> 클로저가 넘어왔다면 이를 이용해 <code>Disposable</code>을 만들고 넘어오지 않았다면 빈 <code>Disposable</code>을 생성한다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span>&lt;<span class="type">Element</span>&gt; &#123; event <span class="keyword">in</span>            </span><br><span class="line">  #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">    synchronizationTracker.register(synchronizationErrorMessage: .<span class="keyword">default</span>)</span><br><span class="line">    <span class="keyword">defer</span> &#123; synchronizationTracker.unregister() &#125;</span><br><span class="line">  #endif</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> event &#123;</span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> value):</span><br><span class="line">    	onNext?(value)</span><br><span class="line">    <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> onError = onError &#123;</span><br><span class="line">        onError(error)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Hooks</span>.defaultErrorHandler(callStack, error)</span><br><span class="line">      &#125;</span><br><span class="line">    disposable.dispose()</span><br><span class="line">    <span class="keyword">case</span> .completed:</span><br><span class="line">    	onCompleted?()</span><br><span class="line">    	disposable.dispose()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>여기서 생성되는 <code>Observer</code>는 <code>AnonymousObsever</code>로 생성자 함수 인자로 클로저를 받는다. 여기서 받는 클로저는 우리가  <code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code> 메소드의 인자로 받은 클로저들을 이벤트에 알맞게 호출해주는 행위를 정의하고 있다. </p>
<p>그리고 위에서 생성된 <code>disposable</code>을 사용하고 있는 것에 주목하자. </p>
<p>그럼 <code>AnonymousObserver</code>는 무엇이고 생성자로 전달된 클로저는 어떻게 사용되는 걸까 <code>AnonymousObserver</code>를 살펴보자.</p>
<p><strong>AnonymousObservable</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObserver</span>&lt;<span class="title">Element</span>&gt;: <span class="title">ObserverBase</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">EventHandler</span> = (<span class="type">Event</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _eventHandler : <span class="type">EventHandler</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> eventHandler: @escaping <span class="type">EventHandler</span>) &#123;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">TRACE_RESOURCES</span></span><br><span class="line">        <span class="number">_</span> = <span class="type">Resources</span>.incrementTotal()</span><br><span class="line">#endif</span><br><span class="line">        <span class="keyword">self</span>._eventHandler = eventHandler</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">onCore</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._eventHandler(event)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#<span class="keyword">if</span> <span class="type">TRACE_RESOURCES</span></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="number">_</span> = <span class="type">Resources</span>.decrementTotal()</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>먼저 <code>AnonymousObserver</code>는 <code>ObserverBase</code> 클래스를 상속받고 있다. 그리고 <code>ObserverBase</code> 클래스의 <code>onCore(_:)</code> 메소드를 오버라이딩하고 있고 그 내부에서 우리가 생성자로 넘겨준 클로저를 호출하고 있는 것을 확인할 수 있다. </p>
<p>그러면 이벤트가 흘러들어왔을 때 결국이 <code>onCore(_:)</code> 메소드가 호출되어야 우리가 넘겨준 클로저들도 호출될 텐데 <code>onCore(_:)</code>는 어디서 호출되는지 <code>ObserverBase</code> 클래스로 가보자. </p>
<p><strong>ObserverBase</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverBase</span>&lt;<span class="title">Element</span>&gt; : <span class="title">Disposable</span>, <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _isStopped = <span class="type">AtomicInt</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .next:</span><br><span class="line">            <span class="keyword">if</span> load(<span class="keyword">self</span>._isStopped) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.onCore(event)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .error, .completed:</span><br><span class="line">            <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isStopped, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.onCore(event)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onCore</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">        rxAbstractMethod()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fetchOr(<span class="keyword">self</span>._isStopped, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onCore(_:)</code> 메소드는<code>on(_:)</code> 메소드에서 호출되는 것을 확인할 수 있다. 그럼 다시 <code>on(_:)</code> 메소드가 호출되는 곳을 찾아야 하는데 이는 잠시 후에 밑에서 좀 더 알아보도록 하자. 일단 <strong><code>on(_:)</code> 메소드가 호출되어야 한다는</strong> 사실만 기억하고 있자. </p>
<p><code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code> 메소드 내부에서 마지막으로 살펴볼 코드는 다음과 같다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="type">Disposables</span>.create(</span><br><span class="line">  <span class="keyword">self</span>.asObservable().subscribe(observer),</span><br><span class="line">  disposable</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code> 메소드 정의에서 볼 수 있듯이 <code>Disposable</code>을 반환하는데 위와 같이 생성해서 반환한다. </p>
<p>그럼 여기서 이제 나는 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.asObservable().subscribe(observer)</span><br></pre></td></tr></table></figure>

<p>이 코드를 먼저 살펴보려 한다. 먼저 <code>asObservable()</code>은 <code>Observable.swift</code> 파일에서 확인할 수 있다. <code>ObservableType</code> 프로토콜 메소드로 기본 구현되어 있는 메소드를 <code>Observable</code> 메소드는 아래와 같이 정의했다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asObservable</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>프로토콜인 <code>ObservableType</code>이 아닌 <code>Observable</code> 타입을 반환하기 위한 메소드이다.</p>
<p>그다음으로 살펴볼 것은 바로 <code>ObservableType.swift</code> 파일에 정의되어있는 <code>func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element</code> 메소드다. 우리는 위에서 생성된 <code>AnonymousObserver</code> 객체를 이 메소드 안에 넣어주었다.  </p>
<p>파일에 설명된 정의를 살펴보면 다음과 같다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Subscribes &#96;observer&#96; to receive events for this sequence.</span><br><span class="line">이 시퀀스에 대한 이벤트를 수신하기 위해선 &#96;observer&#96;를 구독해라.</span><br><span class="line"></span><br><span class="line">* sequences can produce zero or more elements so zero or more &#96;Next&#96; events can be sent to &#96;observer&#96;</span><br><span class="line">*시퀀스는 0개 혹은 그 이상의 요소들을 생산할 수 있고 그렇기 때문에 0개 혹은 그 이상의 &#96;Next&#96; 이벤트들은 &#96;observer&#96;에 전해질 수 있다.</span><br><span class="line"></span><br><span class="line">* once an &#96;Error&#96; or &#96;Completed&#96; event is sent, the sequence terminates and can&#39;t produce any other elements</span><br><span class="line">* &#96;Error&#96; 혹은 &#96;Completed&#96; 이벤트가 전달되면, 시퀀스는 종료되고 다른 요소를 생산할 수 없다. </span><br><span class="line"></span><br><span class="line">It is possible that events are sent from different threads, but no two events can be sent concurrently to &#96;observer&#96;.</span><br><span class="line">다른 스레드로부터 이벤트가 전달될 수 있다. 하지만 두 이벤트가 동시에 &#96;observer&#96;에 전달될 순 없다. </span><br><span class="line"></span><br><span class="line">When sequence sends &#96;Complete&#96; or &#96;Error&#96; event all internal resources that compute sequence elements will be freed.</span><br><span class="line">시퀀스가 &#96;Complete&#96; 혹은 &#96;Error&#96; 이벤트를 보내면 내부에서 시퀀스 요소들을 연산하던 자원들은 모두 자유로운 상태가 된다. </span><br><span class="line"></span><br><span class="line">To cancel production of sequence elements and free resources immediately, call &#96;dispose&#96; on returned subscription.</span><br><span class="line">시퀀스 요소 생산을 취소하고 자원을 즉시 자유롭게하고 싶다면, 반환되는 구독 객체의 &#96;dispose&#96; 메소드를 호출해라.</span><br><span class="line"></span><br><span class="line">returns: Subscription for &#96;observer&#96; that can be used to cancel production of sequence elements and free resources.</span><br><span class="line">반환값: &#96;observer&#96;에 대한 구독 객체로 시퀀스 요소 생산을 취소하거나 자원을 자유롭게 하는데 사용된다.</span><br></pre></td></tr></table></figure>

<p>여기서 제일 위의 설명을 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">이 시퀀스에 대한 이벤트를 수신하기 위해선 &#39;observer&#39;를 구독해라</span><br></pre></td></tr></table></figure>

<p>그리고 <a href="http://reactivex.io/documentation/observable.html">리액티브 공식 사이트</a>에서 설명하고 있는 <code>Observable</code>의 정의를 살펴보자. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In ReactiveX an observer subscribes to an Observable. Then that observer reacts to whatever item or sequence of items the Observable emits</span><br><span class="line">ReactiveX에서 observer는 Observable을 구독한다. 그럼 그 observer는 Observable이 방출하는 아이템에 반응한다.</span><br></pre></td></tr></table></figure>

<p>여기서 내가 이해한 것은 <code>Observer</code>는 <code>Observable</code>을 구독하고 그 구독 객체를 우리가 관찰하는 것으로 이해했다. </p>
<blockquote>
<p>음.. 구독에 대한 반응을 구독하는…? 그런 느낌으로 이해하고 있는데 이에 대해 피드백을 부탁드립니다. 😭</p>
</blockquote>
<p>결국 우리가 <code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code>을 호출하는 대상은 <code>func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element</code>가 반환하는 구독 객체다. </p>
<p><code>Observable</code>을 바로 구독하고 있던 것이 아니였다!</p>
<p>그럼 이번엔 위에서도 보았던 <code>Disposable</code>에 대해 조금 살펴보도록 하자. 먼저 <code>Disposable</code>이 <code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code> 안에서 여러 방식으로 생성되고 사용되고 있는 것을 확인할 수 있다.  <code>Disposable</code>을 생성하는 방법은 몇 가지가 있다. 오늘은 위에서 확인할 수 있었던 세 가지 방법에 대해서만 살펴보도록 하자. </p>
<p><strong>AnonymousDisposable</strong></p>
<p><code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code> 내부에서 살펴볼 <code>Disposable</code> 생성 방법 첫번째는 <code>AnonymousDisposable</code>이다. <code>AnonymousDisposable.swift</code>을 살펴보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousDisposable</span> : <span class="title">DisposeBase</span>, <span class="title">Cancelable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">DisposeAction</span> = () -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> _isDisposed = <span class="type">AtomicInt</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _disposeAction: <span class="type">DisposeAction?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// - returns: Was resource disposed.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isDisposed: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isFlagSet(<span class="keyword">self</span>._isDisposed, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Constructs a new disposable with the given action used for disposal.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// - parameter disposeAction: Disposal action which will be run upon calling `dispose`.</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">init</span>(<span class="number">_</span> disposeAction: @escaping <span class="type">DisposeAction</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>._disposeAction = disposeAction</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Non-deprecated version of the constructor, used by `Disposables.create(with:)`</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">init</span>(disposeAction: @escaping <span class="type">DisposeAction</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>._disposeAction = disposeAction</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Calls the disposal action if and only if the current instance hasn't been disposed yet.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// After invoking disposal action, disposal action will be dereferenced.</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isDisposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>._disposeAction &#123;</span><br><span class="line">        <span class="keyword">self</span>._disposeAction = <span class="literal">nil</span></span><br><span class="line">        action()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Disposables</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Constructs a new disposable with the given action used for disposal.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// - parameter dispose: Disposal action which will be run upon calling `dispose`.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(with dispose: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Cancelable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AnonymousDisposable</span>(disposeAction: dispose)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>가장 먼저 보이는 것은 <code>AnonymousDisposable</code>은 <code>DisposeBase</code> 클래스를 상속받고 <code>Cancelable</code>을 체택하고 있다는 것이다. 그리고 <code>create(with:) -&gt; Cancelable</code>을 보면 알 수 있듯이 <code>Cancelable</code> 프로토콜 타입으로 생성 결과를 반환한다. 그리고 <code>dispose</code> 메소드가 호출될 때 생성 인자로 받은 액션 클로저를 실행하는 것을 확인할 수 있다. </p>
<p><code>AnonymousDisposable</code>은 <code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code>에서 <code>onDisposed</code>에 인자가 넘어오면 생성된다. 즉 <code>diposed</code>될 때 추가적으로 해주어야 할 동작이 넘어오면 해당 동작을 실행시킬 수 있는 <code>AnonymousDisposable</code>을 생성하는 것이다. </p>
<p><strong>NopDisposable</strong></p>
<p>그 다음으로 살펴볼 방법은 <code>NopDisposable</code>이다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">NopDisposable</span> : <span class="title">Disposable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">static</span> <span class="keyword">let</span> noOp: <span class="type">Disposable</span> = <span class="type">NopDisposable</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">init</span>() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Does nothing.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Disposables</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  Creates a disposable that does nothing on disposal.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NopDisposable</span>.noOp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>코드를 살펴보면 알 수 있듯이 어떠한 추가적인 행동을 하지 않는다. <code>dispose</code> 메소드 안도 비어있다. <code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code>에서 <code>onDisposed</code>가 <code>nil</code>일때 <code>NopDisposable</code>을 생성한다. 즉 어떤 추가적인 행동을 취할 필요가 없을 때 <code>NopDisposable</code>을 생성하는 것으로 이해할 수 있다. </p>
<p><strong>BinaryDisposable</strong></p>
<p>마지막으로 살펴볼 방법은 <code>BinaryDisposable</code>을 통한 생성이다. <code>BinaryDisposable</code>은 두 개의 <code>Disposable</code> 객체를 인자로 받아 생성된다. 그리고 <code>dispose</code> 호출시 두 개의 <code>Disposable</code>의 <code>dispose</code> 메소드를 호출해준다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryDisposable</span> : <span class="title">DisposeBase</span>, <span class="title">Cancelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> _isDisposed = <span class="type">AtomicInt</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _disposable1: <span class="type">Disposable?</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _disposable2: <span class="type">Disposable?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// - returns: Was resource disposed.</span></span><br><span class="line">  <span class="keyword">var</span> isDisposed: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isFlagSet(<span class="keyword">self</span>._isDisposed, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Constructs new binary disposable from two disposables.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// - parameter disposable1: First disposable</span></span><br><span class="line">  <span class="comment">/// - parameter disposable2: Second disposable</span></span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> disposable1: <span class="type">Disposable</span>, <span class="number">_</span> disposable2: <span class="type">Disposable</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>._disposable1 = disposable1</span><br><span class="line">    <span class="keyword">self</span>._disposable2 = disposable2</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Calls the disposal action if and only if the current instance hasn't been disposed yet.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// After invoking disposal action, disposal action will be dereferenced.</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> fetchOr(<span class="keyword">self</span>._isDisposed, <span class="number">1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>._disposable1?.dispose()</span><br><span class="line">      <span class="keyword">self</span>._disposable2?.dispose()</span><br><span class="line">      <span class="keyword">self</span>._disposable1 = <span class="literal">nil</span></span><br><span class="line">      <span class="keyword">self</span>._disposable2 = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Disposables</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Creates a disposable with the given disposables.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> disposable1: Disposable, <span class="number">_</span> disposable2: Disposable)</span></span> -&gt; <span class="type">Cancelable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">BinaryDisposable</span>(disposable1, disposable2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code>의 결과로 반환되는 <code>Disposable</code>은 <code>BinaryDisposable</code>이다. 그리고 이 <code>BinaryDisposable</code>은 <code>onDisposed</code> 인자값의 상태에 따라 만들어진 <code>Disposable</code> (<code>AnonymousDisposable</code> 혹은 <code>NopDisposable</code>)과 <code>Observable</code>에 대한 <code>Observer</code>의 구독 객체를 의미하는 <code>Disposable</code>로 만들어진다. <code>Observable</code>에 대한 <code>Observer</code>의 구독 객체는 우리가 <code>Observable</code>을 어떻게 생성하냐에 따라 다르다. </p>
<p>그럼 <code>just</code>를 통해 생성된 <code>Observable</code>을 예로 살펴보자. </p>
<p><strong>just</strong></p>
<p><code>just</code>를 통해 생성된 <code>Observable</code>은 인자로 받은 단일 이벤트를 그 즉시 방출하고 바로 완료되어 <code>Observable</code>의 시퀀스가 종료된다. </p>
<p>먼저 <code>just</code> 메소드부터 살펴보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ObservableType</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  Returns an observable sequence that contains a single element.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  - parameter element: Single element in the resulting observable sequence.</span></span><br><span class="line"><span class="comment">  - returns: An observable sequence containing the single specified element.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">just</span><span class="params">(<span class="number">_</span> element: Element)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Just</span>(element: element)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Just</code> 객체를 <code>just(_:)</code> 인자로 받은 <code>Element</code>로 생성하여 반환한다. 그럼 <code>Just</code> 정의부를 살펴보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Just</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> _element: <span class="type">Element</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(element: <span class="type">Element</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>._element = element</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;Observer: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: Observer)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">Observer</span>.<span class="type">Element</span> == <span class="type">Element</span> &#123;</span><br><span class="line">    observer.on(.next(<span class="keyword">self</span>._element))</span><br><span class="line">    observer.on(.completed)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>먼저 <code>Just</code>는 클래스로 <code>Producer</code>를 상속받는다.</p>
<blockquote>
<p><code>Producer</code>는 <code>Observable</code>을 상속받는다. 여기선 이 정도만 알고 넘어가자. 끝까지 들어가니 머리가 뒤죽박죽이라 현재는 제대로 이해를 하지 못했다.😭</p>
</blockquote>
<p>그리고 <code>func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element</code>  메소드를 오버라이딩하고 있다. </p>
<p><code>just</code>가 단일 이벤트를 방출하고 바로 종료된다는 뜻을 위의 코드를 통해 이해할 수 있을 것이다. 그리고 <code>just</code>는 <code>NopDisposable</code>을 생성한다. 그리고 <code>Observable</code>은 구독이 일어나기 전까지 이벤트를 방출하지 않는다는 의미를 여기서 코드로 이해할 수 있다. </p>
<p><code>func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element</code>가 호출됨에 따라 <code>on(_:)</code> 메소드가 호출되고 <code>func subscribe&lt;Observer: ObserverType&gt;(_ observer: Observer) -&gt; Disposable where Observer.Element == Element</code> 메소드는 <code>subscribe(onNext: ,onError: ,onCompleted: ,onDisposed:) -&gt; Disposable</code> 메소드가 호출되어야 호출되는 메소드기 때문이다. </p>
<blockquote>
<p>그럼 위에서 “ 일단 <strong><code>on(_:)</code> 메소드가 호출되어야 한다는</strong> 사실만 기억하고 있자. “ 라고 했던 말을 여기서 확인할 수 있다. </p>
</blockquote>
<p>뭔가 흐름이 잡힌 것 같으면서도 잡히지 않은 것 같은 느낌이 든다. 아직 왜 여기서 <code>BinaryDisposable</code>을 사용하는 이유는 잘 이해가 가질 않는다. 그래도 <code>Observable</code>의 생성되고 이벤트에 반응하는 것까지의 흐름을 파악할 수 있어서 유익한 시간이었다. 아직 100프로 이해하지 못한 부분들에 대해서는 추후에 계속해서 이해해보려 노력할 것이다. </p>
<h3 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h3><hr>
<ul>
<li><a href="https://medium.com/@rkdthd0403/rxswift-observer-fdc8d2772d6c">[RxSwift] Observer</a><ul>
<li>나와 같이 <code>Observer</code> 존재에 대한 의문을 갖고 글을 작성하셨다. 덕분에 어디부터 어떻게 살펴보아야 할지 감을 잡을 수 있었다. </li>
</ul>
</li>
<li><a href="https://medium.com/cashwalk/rxswift-disposable-fbfb4114fa6e">RxSwift Disposable</a><ul>
<li>역시 RxSwift의 코드를 열어보면서 코드들의 존재 이유에 대해 서술해주신 글이다.</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-06-06T08:02:43.000Z" title="2019-06-06T08:02:43.000Z">2019-06-06</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a></span><span class="level-item">14 minutes read (About 2076 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/06/Specifying-the-Scenes-Your-App-Support/">Specifying the Scenes Your App Support</a></h1><div class="content"><p>WWDC19에서 iOS 13이 발표되고 새로운 것들이 다수 생겼다. 바인딩을 지원하는 <code>Combine</code>, 선언형 UI 방식으로 UI를 구현할 수 있는 <code>SwiftUI</code> 프레임워크까지 많은 것들이 나왔다. </p>
<p>이와 함께 앱 생명주기와 관련된 새 공식 문서가 등장했는데 여기서 <code>Scene</code>이라는 개념이 등장한다. <a href="https://developer.apple.com/documentation/uikit/app_and_scenes/managing_your_app_s_life_cycle">Managing Your App’s Life Cycle</a> 문서를 살펴보기 전에 <a href="https://developer.apple.com/documentation/uikit/app_and_scenes/specifying_the_scenes_your_app_supports">Specifying the Scenes Your App Support</a> 문서를 먼저 살펴보며 Scene의 등장에 대한 이유를 이해하고자 한다. </p>
<blockquote>
<p>참고로 아직은 베타 문서라 추후에 내용이 변경되거나 사용되는 클래스, 프로토콜 그리고 메소드 등의 이름이 변경될 수 있다.</p>
</blockquote>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><hr>
<p>iOS 13과 그 이상에서는 사용자가 앱 UI의 사본을 여러 개 만들어 앱 스위처 내에서 서로 전환할 수 있다. iPad에서 사용자는 또한 앱 UI의 사본과 사본을 나란히 디스플레이할 수 있다. 각각의 앱 UI 사본에 대해 Scene 객체를 사용하여 UI를 화면에 띄우는 윈도우, 뷰 그리고 뷰 컨트롤러를 관리한다. </p>
<blockquote>
<p>WWDC19 키노트에서는 이를 Multi-Window Capability라 설명하며 동일한 메모 앱 두 개를 나란히 실행시키는 모습을 보여주었다.</p>
</blockquote>
<p>사용자가 새 Scene을 요청할 때, UIKit은 이에 해당하는 Scene 객체를 만들고 이것의 초기화 설정을 다룬다. 이를 위해 UIKit은 당신이 제공한 정보에 의존한다. 앱은 반드시 자신이 지원하는 Scene의 유형과 해당 Scene을 관리하는데 사용하는 객체를 선언해야 한다. 이 작업은 앱의 <code>Info.plist</code>에 정적으로 정의하거나, 런타임에 동적으로 정의할 수 있다.</p>
<blockquote>
<p><strong>중요</strong></p>
<p>Scene을 앱에서 지원하는 것은 선택이지만, 앱의 UI 사본들을 동시에 보여주고 싶다면 반드시 지원해야 한다. </p>
</blockquote>
<h3 id="Enable-Scene-Support-in-Your-Project-Settings"><a href="#Enable-Scene-Support-in-Your-Project-Settings" class="headerlink" title="Enable Scene Support in Your Project Settings"></a>Enable Scene Support in Your Project Settings</h3><hr>
<p>앱은 앱의 구성 설정을 갱신하여 Scene을 명시적으로 선택해야 한다. </p>
<ol>
<li>Xcode 프로젝트를 연다.</li>
<li><code>General Settings</code>로 이동한다.</li>
<li><code>Deployment Info</code>  섹션에서 “Support multiple windows” 체크박스를 활성화한다. </li>
</ol>
<p>멀티플 윈도우 옵션을 활성화하면 Xcode는 앱의 <code>Info.plist</code> 파일에 <a href="https://developer.apple.com/documentation/bundleresources/information_property_list/uiapplicationscenemanifest">UIApplicationSceneManifest</a> 키를 추가한다. 이 키의 존재는 시스템에게 당신의 앱이 Scene을 지원한다는 사실을 전달한다. 이 키의 값은 딕셔너리로 초기에는 오직 <a href="https://developer.apple.com/documentation/bundleresources/information_property_list/uiapplicationscenemanifest/uiapplicationsupportsmultiplescenes"><code>UIApplicationSupportsMultipleScenes</code></a> 키만 포함하고 있는 상태다. </p>
<p><code>UIApplicationSupportMultipleScenes</code> 키의 값은 당신의 앱이 실제로 동시에 여러 Scene을 지원하는지를 시스템에게 알린다. Xcode는 이 값을 기본적으로 <code>true</code>로 지정한다. 하지만 한 번에 하나의 Scene만 보여주고 싶으면 비활성화하면 된다. 멀티플 Scene을 지원하기 위해선 서로 다른 Scene들이 서로를 침범하지 않도록 방지하기 위한 추가 작업이 필요하다. 예를 들어 Scene에서 동일한 공유 데이터 구조를 사용하는 경우 앱 데이터 무결성을 유지하기 위해 해당 구조에 대한 접근을 조정해야 한다. </p>
<h3 id="Configure-the-Details-for-Each-Scene"><a href="#Configure-the-Details-for-Each-Scene" class="headerlink" title="Configure the Details for Each Scene"></a>Configure the Details for Each Scene</h3><hr>
<p>UIKit은 당신이 제공한 정보를 사용해 앱의 Scene 생성을 담당한다. 가장 간단한 방법은 이 정보를 앱의 <code>Info.plist</code>를 사용하는 것이다. </p>
<ol>
<li>Xcode를 열고 <code>Info.plist</code> 파일을 선택한다. </li>
<li><code>Application Scene Manifest</code> 항목의 (+) 버튼을 누른다. 이 항목은 <code>UIApplicationSceneManifest</code> 키에 해당한다. 없는 경우 프로젝트 설정에서 위에서 언급한 대로 이를 추가하면 된다. </li>
<li>메뉴가 등장하면 <code>Scene Configuration</code>을 선택한다. </li>
<li><code>Scene Configuration</code> 항목에서 (+) 버튼을 클릭한다.</li>
<li>당신의 앱에 메인 Scene을 추가하기 위해 <code>Application Session Role</code>을 선택한다. </li>
<li>제공된 항목에 Scene의 상세 정보를 기입한다. </li>
</ol>
<p>대부분의 앱은 오직 하나의 메인 Scene만 필요하지만 멀티플 Scene을 추가하고 각각을 다르게 구성할 수 있다. 예를 들어 알림과 관련된 컨텐츠를 보여주기 위한 두 번째 Scene을 포함시킬 수 있다. UIKit은 각 Scene에 대해 다음 정보를 필요로 한다.</p>
<ul>
<li><a href="https://developer.apple.com/documentation/uikit/uiwindowscene"><code>UIWindowScene</code></a> 클래스의 이름</li>
<li>당신의 앱이 Scene을 관리하는데 사용하는 사용자 정의 델리게이트 객체 클래스의 이름. 이 클래스는 반드시  <a href="https://developer.apple.com/documentation/uikit/uiwindowscenedelegate"><code>UIWindowSceneDelegate</code></a> 프로토콜을 따라야 한다. </li>
<li>앱에서 Scene을 내부적으로 식별하는데 사용하는 고유한 이름</li>
<li>Scene의 초기 UI를 포함하는 스토리보드의 이름. <code>.storyboard</code> 파일 확장자를 제외한 이름을 명시한다. </li>
</ul>
<p>Scene을 구성하는데 필요한 정보 추가적인 정보는 <a href="https://developer.apple.com/documentation/bundleresources/information_property_list/uiapplicationscenemanifest/uisceneconfigurations">UISceneConfigurations</a>를 참고하라.</p>
<h3 id="Create-the-Interface-for-Your-Scene"><a href="#Create-the-Interface-for-Your-Scene" class="headerlink" title="Create the Interface for Your Scene"></a>Create the Interface for Your Scene</h3><hr>
<p>스토리보드를 사용해 Scene의 UI를 지정한다.  <a href="https://developer.apple.com/documentation/bundleresources/information_property_list/uiapplicationscenemanifest/uisceneconfigurations/uiwindowscenesessionroleapplication/uiscenestoryboardfile"><code>UISceneStoryboardFile</code></a> 키에 지정한 스토리보드는 Scene을 보여주는데 사용되는 초기 뷰 컨트롤러를 포함한다. Scene 객체를 생성하는 것 외에도 UIKit은 Scene에 대한 윈도우를 생성하고 Scene의 스토리보드에서 초기 뷰 컨트롤러 지정한다. <a href="https://developer.apple.com/documentation/uikit/uiwindowscenedelegate"><code>UIWindowSceneDelegate</code></a> 객체의 메소드를 사용해서 코드로 이 뷰 컨트롤러를 교체할 수 있다. </p>
<blockquote>
<p><strong>중요</strong></p>
<p>스토리보드의 초기 뷰 컨트롤러를 지정하는 것을 잊지 말아야 한다. UIKit는 UI를 구성할 때 이 뷰 컨트롤러의 존재에 의존한다. </p>
</blockquote>
<h3 id="Change-Your-Scene’s-Configuration-Dynamically"><a href="#Change-Your-Scene’s-Configuration-Dynamically" class="headerlink" title="Change Your Scene’s Configuration Dynamically"></a>Change Your Scene’s Configuration Dynamically</h3><hr>
<p>실제로 Scene 객체를 생성하기 전에 UIKit은 앱 델리게이트의 메소드인 <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/3197905-application"><code>application(_:configurationForConnecting:options:)</code></a>를 호출하여 당신이 Scene과 연관된 상세 정보를 수정할 수 있도록 한다. 이 방법을 사용하여 UIKit에서 제공하는 옵션에 따라 Scene 구성을 조정할 수 있다. 예를 들어 시스템이 Scene에 알림 응답(Notification response)을 전달할 때 알림과 연관된 인터페이스와 함께 다른 스토리보드를 지정할 수 있다. </p>
<p>동적으로 Scene 구성을 구현하지 않으면 UIKit은 Scene을 생성하는데 <code>Info.plist</code>의 정보를 사용한다. </p>
<h3 id="Adopt-Scene-Based-Life-Cycle-Semantices"><a href="#Adopt-Scene-Based-Life-Cycle-Semantices" class="headerlink" title="Adopt Scene-Based Life-Cycle Semantices"></a>Adopt Scene-Based Life-Cycle Semantices</h3><hr>
<p>Scene에 대한 지원을 추가하면 앱이 생명 주기 이벤트에 대응하는 방식이 변경된다. Scene을 사용하지 않는 앱에선 앱 델리게이트 객체가 포그라운드 혹은 백그라운드로의 전환을 담당한다. 앱에서 Scene을 지원하게 되면 UIKit은 이러한 책임을 당신이 지정한 Scene 델리게이트 객체에 위임한다. Scene 생명 주기는 다른 Scene에 독립적이고, 앱 자체와도 독립적이다. 그러므로 당신이 지정한 Scene 델리게이트 객체가 이러한 전환을 담당해야 한다. </p>
<p>만일 앱이 iOS 12를 지원한다면 앱 델리게이트와 Scene 델리게이트 객체 모두에서 생명 주기 전환을 처리할 수 있다. UIKit은 오로지 하나의 델리게이트 객체에만 생명 주기 관련 이벤트 알림을 보낸다. iOS 13 이상에선 UIKit은 Scene 델리게이트 객체에 알림을 보내고, iOS 12 이하에선 UIKit은 앱 델리게이트에 해당 알림을 보낸다. </p>
<p>생명 주기 이벤트를 어떻게 다루는지에 대한 추가적인 정보는 <a href="https://developer.apple.com/documentation/uikit/app_and_scenes/managing_your_app_s_life_cycle">Managing Your App’s Life Cycle</a>를 참고하라.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-23T11:12:09.000Z" title="2019-03-23T11:12:09.000Z">2019-03-23</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">8 minutes read (About 1196 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/23/OptionSet/">OptionSet</a></h1><div class="content"><p>오늘은 회사 과제를 진행하던 중 처음 접한 스위프트의 <code>OptionSet</code>이라는 친구를 살펴보려 한다. 처음 접한 개념이지만 알아보니 그렇게 어렵지 않은 개념이면서도 유용하게 사용할 수 있을 것 같은 개념이어서 이렇게 기록해보려 한다. </p>
<hr>
<p>먼저 그 개념을 공식 문서를 통해 살펴보도록 하자. </p>
<p><code>OptionSet</code> 프로토콜은 비트들 각각이 집합의 요소를 표현하는 비트 집합 타입을 표현하는데 사용된다. 이 프로토콜을 채택한 사용자 정의 타입에선 요소 검사(해당 요소가 집합에 속하는지), 합집합, 교집합 연산과 같은 집한 연산들을 수행할 수 있다. </p>
<p>옵션 집합(<code>OptionSet</code> 프로토콜을 채택한 사용자 정의 타입)을 만들기 위해선 타입 선언 부분에 <code>rawValue</code>를 포함시켜야 한다. 사용자 정의 타입으로 만든 옵션 집합이 기본 집합 연산을 수행하기 위해선 <code>rawValue</code> 프로퍼티는 반드시 <code>FixedWidthInteger</code> 프로토콜을 따르고 있는 타입(<code>Int</code>, <code>UInt8</code> 등등)이어야 한다. 다음으로는 정적(<em>static</em>) 변수로 고유한 2의 거듭제곱 값(1, 2, 4, 8, …)을 <code>rawValue</code>로 갖는 옵션들을 생성한다. 이렇게 2의 거듭제곱 값을 <code>rawValue</code>로 가져야 각각의 옵션들은 단일 비트로 표현이 가능하기 때문이다.</p>
<p><code>OptionSet</code>은 다음과 같이 정의할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ShippingOptions</span>: <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rawValue: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> nextDay    = <span class="type">ShippingOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>) <span class="comment">// 0001</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> secondDay  = <span class="type">ShippingOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 0010</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> priority   = <span class="type">ShippingOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// 0100</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> standard   = <span class="type">ShippingOptions</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">3</span>) <span class="comment">// 1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> express: <span class="type">ShippingOptions</span> = [.nextDay, .secondDay] <span class="comment">// ?? </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> all: <span class="type">ShippingOptions</span> = [.express, .priority, .standard] <span class="comment">// ??</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>먼저 왜 2의 거듭제곱 값으로 표현되어야 할까?</p>
<p>그 이유는 위에서 언급되었듯이 단일 비트로 각각의 값을 표현할 수 있기 때문이다. (Bitmask)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0001 &#x2F;&#x2F; 1</span><br><span class="line">0010 &#x2F;&#x2F; 2</span><br><span class="line">0100 &#x2F;&#x2F; 4</span><br><span class="line">1000 &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure>

<p>만일 2의 거듭제곱이 아니라면 어떻게 될까? 이에 대해서는 밑에서 얘기해보자. </p>
<p>처음 <code>OptionSet</code>을 봤을 때 가장 먼저 든 생각은 *”열거형(enum)이랑 뭐가 다른거지!?”* 였다. 그 생각을 몇몇의 글들을 읽어보면서 정리해보았다.</p>
<p><strong>열거형과 <code>OptionSet</code>을 채택한 타입과의 가장 큰 차이점은 단일 타입 변수가 가질 수 있는 경우의 수의 차이다.</strong> 열거형 타입은 해당 타입의 케이스를 하나만 나타낼 수 있다. 하지만 <code>OptionSet</code> 여러 케이스를 하나의 변수로 표현할 수 있다. 열거형에서 이를 표현하려면 여러 케이스에 해당하는 열거형 타입을 배열과 같은 콜렉션 타입으로 표현해야 한다. </p>
<p><strong><code>OptionSet</code>은 여러 케이스를 하나의 변수로 담을 수 있기 때문에 각각의 케이스는 유일해야 한다.</strong> 그리고 이를 위해 우리는 비트 값으로 이를 표현한 것이고 2의 거듭제곱으로 표현한 것도 그와 같은 이유다. 실제로 <strong>여러 케이스를 표현한다고 여러 값을 갖고 있을 필요는 없다.</strong> 위의 <code>ShippingOptions</code>을 살펴보자. </p>
<p><code>express</code>는 <code>[.nextDay, .secondDay]</code>로 표현된다. 하지만 <code>[ShippingOptions]</code>이 아닌 <code>ShippingOptions</code> 타입 변수에 할당된다. 2의 거듭제곱으로 표현되고 있다는 걸 상기시켜보면 실제로 <code>express</code>의 값은 <code>.nextDay(0001)</code>과 <code>.secondDay(0010)</code>을 더한 <code>0011</code>인 것이다. 그리고 모든 원시 값이 2의 거듭제곱이기 때문에 <code>0011</code>만 보아도 <code>0001</code>과 <code>0010</code>의 조합인 걸 알 수 있다.   </p>
<p>여기서 2의 거듭제곱으로 해야 하는 이유가 나온다. 만일 2의 거듭제곱 값이 아닌 <code>0011</code> , 즉 3을 원시 값으로 갖는 케이스가 있다면 <code>.express</code>와 구분이 되지 않기 때문이다. </p>
<p>또한 서버에 값을 전송할 때 리스트 형태의 값을 전달하는 것보다 이렇게 비트 마스크로 표현된 값을 보내는 것이 더 수월할 수 있다. (물론 서버 개발자와의 확실한 상호 협의가 요구되지만)</p>
<p>그리고 위에서 언급했듯이 <code>OptionSet</code>을 따르는 프로토콜은 <strong>집합 연산</strong>을 수행할 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> normal: <span class="type">Pet</span> = [.nextDay, .secondDay]</span><br><span class="line"><span class="keyword">let</span> options2: <span class="type">Pet</span> = [.nextDay, .priority, .standard]</span><br><span class="line"><span class="keyword">let</span> intersection = options1.intersection(options2)</span><br><span class="line"><span class="built_in">print</span>(intersection) <span class="comment">// ShippingOptions(rawValue: 1) 👉 nextDay</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> union = options1.union(options2)</span><br><span class="line"><span class="built_in">print</span>(union) <span class="comment">// ShippingOptions(rawValue: 15) 👉 nextDay, secondDay, priority &amp; standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subtracting = options1.subtracting(options2)</span><br><span class="line"><span class="built_in">print</span>(subtracting) <span class="comment">// ShippingOptions(rawValue: 2) 👉 secondDay</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">contains</span> = options1.<span class="built_in">contains</span>(.standard)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">contains</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</b>

<p>오늘은 이렇게 간단히 <code>OptionSet</code>에 대해 알아보았다. 이를 사용한다면 보다 여러 케이스를 포함하는 상황에서 보다 적은 코드로  각각의 상황에 대응할 수 있을 것 같다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-10T04:31:44.000Z" title="2019-03-10T04:31:44.000Z">2019-03-10</time><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">13 minutes read (About 1910 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/10/Bitcode-in-iOS/">Bitcode in iOS</a></h1><div class="content"><p>오늘은 iOS의 <strong>비트코드(Bitcode)</strong>에 대해 알아보려 한다. 비트코드를 알아보게 된 계기는 현재 인턴을 진행하면서 기존 네이버 지도 API를 네이버 지도 V3 API로 교체를 해야 하는 작업을 과제로 받았다.  </p>
<p>이를 위해 데모 프로젝트와 문서를 보면서 샘플 프로젝트를 만드려는데 시뮬레이터에서는 정산적으로 빌드가 되고 실행이 되는 반면 실제 디바이스에서 테스트를 진행하려니 비트코드 에러가 발생하면서 빌드조차 되지 않았다. </p>
<p>이 에러를 해결 방법은 간단했는데 <code>Build Setting</code> 탭으로 들어가 <code>Enable Bitcode</code> 항목을 <code>No</code>로 지정해주면 되었다. 하지만 늘 그렇듯 어떤 문제를 했는데 그 해결 방법이 어떠한 방법으로 문제를 해결했는지에 대해 알지 못하는 것만큼 불안한 것은 없다. 특히 이렇게 빌드 세팅의 속성을 변경해주는 경우에는 더 그렇다. </p>
<p>그래서 이에 관해 조금 찾아보았고 그 정보들을 정리해서 기록해보려 한다. </p>
<h3 id="Bitcode"><a href="#Bitcode" class="headerlink" title="Bitcode"></a>Bitcode</h3><p>먼저 애플 <a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f">공식 문서</a>는 비트코드를 다음과 같이 설명하고 있다.</p>
<p>비트코드는 컴파일된 프로그램의 <strong>중간 표현(intermediate representation)</strong>이다. 비트코드를 포함한 앱을 앱 스토어에 업로드하면 앱은 컴파일되고 앱 스토어어와 링크될 것이다. 비트코드를 포함하면 새로운 버전의 앱을 앱 스토어에 다시 제출할 필요 없이 애플이 앱 바이너리(<em>컴퓨터가 실행할 수 있는 코드를 포함하고 있는 파일</em>)를 다시 최적화할 수 있다. </p>
<p>iOS 앱에서 비트코드는 기본으로 포함되지만 이를 선택할 수 있다. watchOS와 tvOS 앱에서 비트코드는 필수다. 만일 비트코드를 제공한다면 모든 앱과 앱 번들 안의 모든 프레임워크(프로젝트 안의 모든 타겟)는 비트코드를 포함해야 한다. </p>
<p>Xcode는 기본적으로 앱의 심볼을 숨기기 때문에 이는 애플이 읽을 수 없다. 앱을 앱 스토어에 올릴 때 심볼을 포함할 것인지에 대한 옵션이 주어진다. 심볼을 포함하면 테스트플라이트 혹은 앱 스토어를 통해 앱을 배포했을 때 애플은 앱에 대한 크래시 리포트를 제공한다. 만약 크래시리포트를 직접 수집하고 상징화(<em>Symbolication : 상징화는 크래시 로그의 메모리 주소를 사람이 읽을 수 있는 함수명과 라인 넘버로 교체하는 작업을 말한다.</em>)하기를 원한다면 심볼을 업로드할 필요 없다. 대신 앱 배포 후 <a href="https://help.apple.com/xcode/mac/current/#/devef5928039">비트코드 컴파일 dSYM 파일을 다운로드</a> 받을 수 있다.</p>
<p>모든 뜻을 이해할 순 없었지만 내 프로젝트에서 에러가 발생하는 이유는 추측할 수 있었다. Xcode를 통해 프로젝트를 생성하면 기본적으로 비트코드는 포함되도록 설정되어 있다. 하지만 네이버 지도 V3 API 프레임워크는 비트코드를 포함하고 있지 않기 때문에 문서의 내용 중 *”만일 비트코드를 제공한다면 모든 앱과 앱 번들 안의 모든 프레임워크(프로젝트 안의 모든 타겟)는 비트코드를 포함해야 한다.”*에 위배된다. 그래서 프로젝트의 빌드 세팅에서 비트코드 포함 옵션을 <code>No</code>로 지정하니 프로젝트가 정상적으로 빌드 되고 실행될 수 있던 것이다. </p>
<p>하지만 여전히 비트코드 이 자체에 대한 이해는 부족하다. 좀 더 자료를 찾아보자. 역시 나와 비슷한 사람은 많았고 누군가 <a href="https://www.quora.com/What-is-Apple-Bitcode">Quora</a>에 질문을 올렸고 이에 대한 답변이 애플의 공식 문서보다 친절하고 보다 명확하게 와닿았다. </p>
<p><strong>LLVM</strong></p>
<p>비트코드를 이해하기 위해선 먼저 LLVM(Low Level Virtual Machine)에 대해 알아야 한다. LLVM은 라이브러리로 코드를 중간 매체 혹은 기계 코드로 컴파일하는데 사용된다. LLVM을 통해 많은 컴파일러와 언어들을 만들어낸다. </p>
<p>이렇게 만들어진 컴파일러의 컴파일 과정은 세 단계로 나뉜다. </p>
<ol>
<li>컴파일러 프론트 엔드는 소스 코드를 중간 표현 단계로 변환한다. </li>
<li>이 중간 표현 단계는 불필요한 코드를 제거하고 하는 등의 최적하 과정을 겪는다. 이 과정은 소스 코드도 기계 코드도 아닌 중간 표현 단계에서 진행되는데 옵티마이저가 더욱 쉽게 해석할 수 있는 형태이기 때문이다.</li>
<li>컴파일러 백 엔드가 중간 표현 단계를 기반으로 기계 코드를 생성한다.</li>
</ol>
<p>비트코드는 LLVM을 통해 앱의 코드를 받아 이를 비트코드로 전환하고 주어진 지침을 통해 이를 실행 가능한 앱으로 전환하는 방법을 안다. 즉 비트코드는 어떤 아키텍쳐에서도 실행되기를 준비하는 중간 단계인 것이다. 간단히 말해서, 이러한 구조는 애플이 앱 스토어에 새로운 CPU 지원을 백엔드에 쉽게 추가할 수 있다는 것을 의미하며 이렇게 되면 비트코드는 이를 통해 새로운 아키텍처로 컴파일 하는 방법을 알 수 있는 것이다.</p>
<p>비트코드를 포함하지 않는다면 컴파일러는 머신 코드만을 포함하는 실행 파일을 생성할 것이다. </p>
<p><img src="https://www.guardsquare.com/files/media/guardsquare2017/Compiling-without-bitcode-enabled.png" alt=""></p>
<p>하지만 비트코드를 포함한다면 비트코드는 기계 코드와 나란히 실행 파일에 포함될 것이다. </p>
<p><img src="https://www.guardsquare.com/files/media/guardsquare2017/Compiling-with-bitcode-enabled.png" alt=""></p>
<p>비트코드의 형태로 앱 스토어에 제출하면 앱 스토어는 해당 앱을 다운로드 받는 디바이스 환경에 맞춰 최적화를 진행하여 내려보낼 것이다. 이 과정은 <strong>앱 시닝(App Thinning)</strong>에 포함된다. 앱 시닝에 대한 내용은 추후에 살펴보고 포스팅할 예정이다.</p>
<p>일례로 살펴보면 애플은 2013년에 아이폰 5s부터 64비트 칩셋으로 교체할 것이라고 발표했고 앱 개발자들은 이를 위해 앱을 다시 컴파일해서 제출해야 했다. 그 이유는 비트코드가 아닌 실행 가능한 코드 자체를 올렸기 때문에 이는 새로운 아키텍쳐 칩셋 환경에서 동작할 수 없었기 때문이다. 이제는 비트코드가 포함된 실행 파일을 올려도 새로운 디바이스 환경에서 앱이 동작할 수 있게 되었다. </p>
<hr>
<p>참고 자료</p>
<ul>
<li><p><a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f">What is app thinning? (iOS, tvOS, watchOS)</a></p>
</li>
<li><p><a href="https://www.quora.com/What-is-Apple-Bitcode">What is Apple Bitcode?</a></p>
</li>
<li><p><a href="https://www.guardsquare.com/zh-hans/blog/it-safe-enable-bitcode">Is it safe to enable bitcode?</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-03-09T12:44:58.000Z" title="2019-03-09T12:44:58.000Z">2019-03-09</time><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">17 minutes read (About 2491 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/09/ABI-Stability/">ABI Stability</a></h1><div class="content"><p>스위프트 5.0에서 가장 많이 주목을 받고 있는 부분이 바로 ABI 안정화(Stability)이다. 대체 ABI가 안정화된다는 것이 무엇을 의미하는지, 왜 ABI 안정화를 지원하게 됬는지 ABI 자체가 무엇인지에 대해 알아보려 한다. </p>
<p>기본적으로 <a href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md">Swift ABI Stability Manifesto</a> 글을 기반으로 각종 블로그 글들을 참고하면서 나름대로 정리해보았다. </p>
<hr>
<h3 id="The-Big-Picture"><a href="#The-Big-Picture" class="headerlink" title="The Big Picture"></a>The Big Picture</h3><p>현재 스위프트의 가장 최우선 순위는 향후 스위프트 버전과의 <strong>호환성(compatibilty)</strong>이다. 호환성은 다음의 두 가지 목표를 갖고 있다.</p>
<ol>
<li><strong>소스 호환성(Source compatibility)</strong>은 새 컴파일러가 구 버전의 스위프트를 컴파일 할 수 있다는 것을 의미한다. 이는 새 스위프트 버전이 나오면 스위프트 개발자들이 직면했던 마이그레이션의 고통을 줄여주는 목적을 갖고 있다. 소스 호환성 없이는 프로젝트는 <strong>버전 잠금(version-lock)</strong>에 직면하는데 이는 프로젝트와 패키지 내부의 모든 소스코드가 동일한 스위프트 버전으로 작성되어야 한다는 것을 의미한다. 소스 호환성이 존재한다면 패키지 작성자는 그들의 사용자가 새로운 버전의 스위프트를 사용할 수 있도록 하며 여러 스위프트 버전을 단일 코드 기반으로 유지할 수 있다. </li>
<li><strong>바이너리 프레임워크와 런타임 호환성(Binary framwork &amp; runtime compatibility)</strong>은 다양한 스위프트 버전에서 동작할 수 있는 바이너리 형태의 프레임워크 배포를 가능하게 한다. 바이너리 프레임워크는 프레임워크 API의 소스-레벨 정보와 통신하는 <em>스위프트 모듈 파일(Swift module file)</em>과 런타임 중 로드되는 컴파일된 구현체인 <em>공유 라이브러리(shared library)</em>를 포함한다. 따라서 바이너리 프레임워크 호환성(binary framework compatibility)은 두 가지 목적을 갖고 있다. <ul>
<li><strong>모듈 포맷 안정성(Module format stability)</strong>은 컴파일러가 프레임워크의 공개 인터페이스를 나타내는 모듈 파일을 안정화시킨다. 이는 API의 선언과 inlineable 코드를 포함한다. 이 모듈 파일은 컴파일러가 프레임워크를 사용하는 클라이언트 코드를 컴파일 할 때 타입 검사, 코드 생성 등과 같은 필수 작업을 진행하는데 사용된다. </li>
<li><strong>ABI 안전성(ABI stability)</strong>은 서로 다른 스위프트 버전으로 컴파일된 어플리케이션과 라이브러리 사이의 바이너리 호환성을 가능하게 한다. </li>
</ul>
</li>
</ol>
<h3 id="What-is-ABI"><a href="#What-is-ABI" class="headerlink" title="What is ABI?"></a>What is ABI?</h3><p>런타임 중에 스위프트 프로그램 바이너리는 ABI를 통해 다른 라이브러리와 요소들과 상호작용한다. ABI는 Application Binary Interface를 의미하며 독립적으로 컴파일된 바이너리 엔티티(실체)들이 서로 연결되고 실행되기 위해서 반드시 따라야 규격이다. 이러한 바이너리 엔티티들은 함수를 호출하는 방법, 메모리에서 데이터가 표현되는 방법 그리고 그들의 메타데이터가 어디에 존재해야하는지 그리고 어떻게 접근해야하는지 등의 저수준의 상세 사항들을 따라야 한다. </p>
<blockquote>
<p>API를 사용할 때 우리는 사용하려는 기능의 내부 로직은 크게 신경쓰지 않고 API의 원하는 기능을 취할 수 있다.  라이브러리가 업데이트되어도 우리가 호출하는 API의 메소드의 외형은 동일하게 사용할 수 있어야 한다. 라이브러리가 업데이트될 때마다 외형이 변경된다면 우리는 계속해서 우리의 코드를 이에 맞춰 수정해야 한다. </p>
<p>ABI도 마찬가지라고 생각한다. ABI의 안정화 없이 스위프트 버전이 올라가게 되면 우리는 프로젝트에서 사용되는 스위프트를 새 버전의 스위프트로 계속해서 마이그레이션 해야 한다. </p>
</blockquote>
<h3 id="What-is-ABI-Stability"><a href="#What-is-ABI-Stability" class="headerlink" title="What is ABI Stability?"></a>What is ABI Stability?</h3><p>ABI 안정화란 향후 새로운 버전의 컴파일러가 안정환된 ABI 규격을 따르는 바이너리를 생성할 수 있는 수준으로 만드는 것을 의미한다. </p>
<p>ABI 안정화는 오직 외부에 노출되는 공공 인터페이스와 심볼의 불변성에만 영향을 미친다. 내부 심볼, 컨벤션 그리고 레이아웃은 ABI 규격을 깰 필요 없이 지속해서 변경할 수 있다. 예를 들어 미래의 컴파일러는 공개되어 있는 공공 인터페이스를 유지하는한 내부 함수 호출의 호출 규칙을 자유롭게 변경할 수 있다.</p>
<h3 id="What-Does-ABI-Stability-Enable"><a href="#What-Does-ABI-Stability-Enable" class="headerlink" title="What Does ABI Stability Enable?"></a>What Does ABI Stability Enable?</h3><p>ABI 안정화는 OS 공급자가 운영체제에 스위프트 표준 라이브러리와 구 버전 혹은 새 버전의 스위프트로 만들어진 어플리케이션과의 호환성을 갖는 런타임을 내장할 수 있도록 한다. 이렇게 되면 이러한 플랫폼 상의 앱을 배포할 때 표준 라이브러리를 앱 내에 포함시켜 배포할 필요가 없어진다. 이는 도구의 의존성을 줄여주고 운영체제에 보다 우수한 조화를 가능하게 한다. </p>
<blockquote>
<p>기존의 iOS 앱 번들에는 해당 앱을 만드는데 사용한 버전의 스위프트 표준 라이브러리를 포함하고 있었다. 즉 스위프트 4.2로 만들어진 앱은 스위프트 4.2 ABI를 포함하는 스위프트 4.2 동적 라이브러리를 앱 번들 내에 포함하고 있었고 스위프트 3.0으로 만들어진 앱은 3.0 ABI를 포함하는 동적 라이브러리를 앱 번들 내에 포함하고 있었다는 것이다. </p>
<p>즉 각각의 언어는 각각의 OS 버전과 서로 다른 ABI 규격을 갖고 있었기 때문에 다른 버전의 OS에서 앱이 실행되기 위해선 앱 번들 자체에 스위프트 동적 라이브러리를 포함했어야 했다.</p>
<p>ABI가 안정화되면 이렇게 앱 번들 내에 해당 버전의 스위프트 다이나믹 라이브러리를 포함할 필요가 없기 때문에 앱 사이즈는 줄어들 수 있다. 왜냐하면 OS와 스위프트의 버전 차이가 존재해도 ABI 규격은 동일하기 때문이다. 스위프트 표준 라이브러리와 스위프트 런타임이 OS에 내장되는 것이다. </p>
</blockquote>
<h3 id="Module-Stability"><a href="#Module-Stability" class="headerlink" title="Module Stability"></a>Module Stability</h3><p>ABI 안정화는 런타임 중의 스위프트 버전들의 혼용에 관한 것이다. 컴파일 시점은 어떤가? 스위프트는 “swiftmodule”이라는 불투명한 아카이브 포맷을 사용해 수동으로 작성된 헤더 파일이 아닌 “MagicKt” 프레임워크와 같은 라이브러이의 인터페이스를 나타낸다. 그러나 “swiftmodule” 포맷 역시 현재 컴파일러 버전에 묶여잇고 이는 만일 “MagicKit”이 다른 스위프트 버전으로 만들어졌다면 개발자는 <code>import MagicKit</code>을 통해 해당 프레임워크를 사용할 수 없다는 것을 의미한다. 즉 앱 개발자와 라이브러리 제작자는 반드시 같은 버전의 컴파일러를 사용해야 한다. </p>
<p>이러한 제한 사항을 없애기 위해 라이브러리 제작자는 현재 구현중인 현재는 구현되고 있는 <strong>모듈 안전성(module stability)</strong>라 불리는 기능을 필요로 한다. 이를 통해 라이브러리를 사용하는 개발자는 모듈이 어떤 컴파일러로 만들어졌는지 생각할 필요 없이 모듈을 사용할 수 있다. </p>
<p><img src="https://swift.org/assets/images/abi-stability-blog/module-stability.png" alt=""></p>
<p>예를들어 스위프트6 그리고 스위프트7 컴파일러는 스위프트6로 만들어진 프레임워크의 인터페이스를 읽을 수 있는 것이다. </p>
<h3 id="Libraray-Evolution"><a href="#Libraray-Evolution" class="headerlink" title="Libraray Evolution"></a>Libraray Evolution</h3><p>우리는 지금까지 컴파일러 교체에 관해 얘기했지만 스위프트 코드도 동일하다. 오늘날 스위프트 라이브러리가 변경되면 해당 스위프트 라이브러리를 사용하는 앱은 재컴파일 되어야 한다. 이는 몇 가지 장점이 있는데 컴파일러가 앱이 사용하는 라이브러리의 버전을 정확히 알고 있기 때문에 코드 크기를 줄일 수 있는 추가적인 가정(assumption)을 할 수 있고 앱을 보다 빠르게 실행시킬 수 있다. 하지만 이러한 가정은 다음 라이브러리 버전에는 맞지 않을 수 있다. </p>
<p><strong>Library Evolution</strong> 기능은 앱을 재컴파일 할 필요 없이 새로운 버전의 라이브러리의 기능을 사용할 수 있도록 하는 것이다. </p>
<p><img src="https://swift.org/assets/images/abi-stability-blog/library-evolution.png" alt=""></p>
<p>위의 예제에서 앱은 노란색 버전으로 만들어진 프레임워크로 만들어졌다. library evolution과 함께 노란색 버전을 가진 시스템에서의 실행은 물론이고 새롭게 개선된 빨간색 버전에서도 실행될 수 있다.</p>
<hr>
<p><strong>참고 자료</strong></p>
<ul>
<li><a href="https://swift.org/blog/abi-stability-and-more/">ABI Stability and More</a></li>
<li><a href="https://medium.com/swift-india/swift-5-abi-stability-769ccb986d79">Swift 5 ABI Stability</a></li>
<li><a href="https://zeddios.tistory.com/654">Zedd님의 ABI Stability</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-11-01T08:06:57.000Z" title="2018-11-01T08:06:57.000Z">2018-11-01</time><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">11 minutes read (About 1607 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/11/01/init-coder-init-nibName-bundle-awakeFromNib/">init?(coder:), init(nibName:, bundle:), awakeFromNib()</a></h1><div class="content"><p>평소에 뷰 컨트롤러나 뷰를 만들기 위해 스토리보드뿐만 아니라 <code>.xib</code>나 코드의 형태로 만들어 사용하기도 한다. 하지만 이들 각각의 방법으로 뷰 컨트롤러를 생성할 때 생성되는 시점이나 불리는 메소드를 명확히 알지 못해 매번 작성한 코드를 이리저리 움직여가며 동작을 확인했다. 오늘은 이렇게 정확하기 알지 못했던 개념을 개념을 더욱 명확하게 하기 위해 공부하고 기록한 내용이다. </p>
<hr>
<h4 id="xib-nib"><a href="#xib-nib" class="headerlink" title="xib? nib?"></a>xib? nib?</h4><ul>
<li><strong>nib</strong> - NeXT Interface Builder</li>
<li><strong>xib</strong> - XML Interface Builder</li>
</ul>
<p><code>.xib</code>와 <code>.nib</code>의 차이점은 무엇일까? 차이점이라기보단 <code>.xib</code> 파일은 빌드 시점에 <code>.nib</code> 파일의 형태로 바뀐다. 인터페이스 빌더로 작업한 UI는 <code>.xib</code> 파일의 형태로 저장되고 빌드 시점에 앱 번들로 복사되고 런타임에 로드된다. 또한 <code>.xib</code> 파일은 텍스트 기반의 파일로 바이너리 파일인 <code>.nib</code> 파일보다 소스 컨트롤에 용이하며 읽기에 용이하다.</p>
<h4 id="init-coder"><a href="#init-coder" class="headerlink" title="init?(coder:)"></a>init?(coder:)</h4><p><code>xib</code> 파일로 만든 뷰는 실제로 저장될 때 <strong>아카이빙</strong> 되어 저장된다. 그러므로 해당 뷰를 불러올 때는 <strong>언아카이빙</strong>를 통해 불러와야 한다. 스토리보드도 내부적으론 일종의 <code>xib</code> 파일들로 이루어져 있기 때문에 로그를 찍어보면 <code>init?(coder:)</code> 생성자가 불리는 것을 확인할 수 있다. 하지만 아직 이 시점에선 <code>@IBOutlet</code>이나 <code>@IBAction</code>은 준비되어 있지 않다. </p>
<h4 id="init-nibName-bundle"><a href="#init-nibName-bundle" class="headerlink" title="init(nibName:, bundle:)"></a>init(nibName:, bundle:)</h4><blockquote>
<p><code>nib</code> 파일명은 결국 우리가 생성해준 <code>xib</code> 파일이 바뀐 결과물이기 때문에 이 둘의 이름은 확장자를 제외하곤 동일하다.</p>
</blockquote>
<p><code>init(nibName:, bundle:)</code> 생성자는 코드로 <code>nib</code> 파일로 만들어진 뷰를 불러올 때 사용하는 생성자이다. 이는 본인도 적지 않게 사용해봤다. 사용법은 <code>nibName</code> 아규먼트에는 <code>nib</code>파일의 이름에 해당하는 값을 넣어주는데 본인은 언제나 두 아규먼트 모두에 <code>nil</code> 값을 할당해주었다. 그 이유가 궁금해서 찾아봤는데 공식 문서는 이를 다음과 같이 설명하고 있었다. </p>
<p><a href="https://developer.apple.com/documentation/uikit/uiviewcontroller/1621487-nibname"><strong>nibName</strong></a></p>
<p>이 프로퍼티는 <code>init(nibName:, bundle:)</code> 생성자에 의해 생성되는 시점에 지정된 값을 포함한다. 이 프로퍼티는 <code>nil</code>일 수 있다. </p>
<p>뷰 컨트롤러의 뷰를 저장하기 위해 <code>nib</code> 파일을 사용한다면 뷰 컨트롤러를 생성하는 시점에 생성자에 해당 이름을 명시해주는 것을 추천한다. 하지만 만일 <code>nib</code> 파일 명을 지정해주지 않고 <code>loadView</code>를 오버라이딩하지 않는다면 뷰 컨트롤러는 <code>xib</code> 파일을 다른 방법을 이용해 이를 찾아낼 것이다. 구체적으로 말하자면 적절한 파일 이름 (<code>.nib</code> 확장자를 제외한)의 <code>nib</code>를 찾고 뷰를 필요로 할 때 이를 로드하여 사용할 것이다. <strong>적절한</strong> 이름을 찾는 과정은 다음의 순서를 따라 찾는다. </p>
<ol>
<li>만일 뷰 컨트롤러 클래스의 이름이 <code>MyViewController</code>와 같이 <code>Controller</code> 끝난다면 <code>Controller</code>를 제외한 <code>MyView.nib</code> 파일을 찾을 것이다. </li>
<li>뷰 컨트롤러와 이름이 동일한 <code>nib</code> 파일을 찾는다. <code>MyViewController</code>라면 <code>MyViewController.nib</code></li>
</ol>
<p>위와 같은 이유로 생성 시점에 아규먼트를 넘겨줘야 한다면 다음과 같이 생성자를 정의해줄 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> prop: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(prop: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.prop = prop</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibBundle: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 사용자 정의 생성자를 작성해주었기 때문에 반드시 required 생성자를 구현해주어야 한다.</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="awakFromNib"><a href="#awakFromNib" class="headerlink" title="awakFromNib()"></a>awakFromNib()</h4><p>사실 <code>awakeFromNib()</code>는 생성자가 아니다. 근데 생각보다 이를 생성자라고 생각하고 사용하는 경우가 적지 않은데 이를 잘못 이해한다면 원하는 결과물을 얻을 수 없을 것이다. 그럼 <code>awakeFromNib</code>은 무엇일까?</p>
<p>이 메소드는 <code>init?(coder:)</code>를 통해 뷰가 모두 언아카이빙된 후 호출된다. <code>@IBOulet</code>과 <code>@IBAction</code>이 모두 자리가 잡힌 후 호출되는 것이다. <code>init?(coder:)</code>가 언아카이빙의 시작점이라면 <code>awakeFromNib()</code>은 끝나는 시점이라고 할 수 있다. </p>
<p>이 세 메소드들을 공부하면서 각각 로그를 찍어보았는데 한곳에서 알 수 없는 현상이 발생하였다. 이는 다음과 같은 상황이었다. <code>xib</code> 파일을 하나 만들고 <code>UIViewController</code>를 상속받는 뷰 컨트롤러를 생성하였고 이를 <code>xib</code> 파일의 <code>File&#39;s Owner</code>로 지정하였다. 그리고 뷰 컨트롤러의 <code>awakeFromNib()</code> 메소드에 로그를 출력하도록 코드를 추가해보았지만 <code>awakeFromNib()</code>은 호출되지 않았다. </p>
<p>그 이유를 찾아본 결과 <code>File&#39;s Owner</code>는 이렇게 언아카이빙 되는 뷰 객체와 관련성이 없다. 위에서 언급했듯이 <code>awakeFromNib()</code> 언아카이빙이 모두 끝난 후 호출되는 메소드이다. <code>File&#39;s Owner</code>는 언아카이빙이 시작되기 전에 이미 존재하고 언아카이빙이 모두 끝난 후 해당 객체와 연결되기 때문에 <code>File&#39;s Owner</code>인 뷰 컨트롤러 안에서의 <code>awakeFromNib()</code>의 호출은 무의미하다. </p>
<p>하지만 스토리보드와 뷰 컨트롤러에선 얘기가 좀 달라진다. 스토리보드에 뷰 컨트롤러를 올리고 로그를 찍어보면 정상적으로 찍히는 것을 확인할 수 있다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewController - init(coder:)</span><br><span class="line">ViewController - awakeFromNib</span><br></pre></td></tr></table></figure>

<p>그 이유는 해당 뷰 컨트롤러 객체 클래스를 <code>File&#39;s Owner</code>가 아닌 해당 뷰 컨트롤러 자체이기 때문이다. 그렇기 때문에 스토리보드 위에 올라가있는 뷰 컨트롤러는 언아키이빙 과정을 거치기 때문에 정상적으로 <code>awakeFromNib()</code>이 호출되는 것을 확인할 수 있다.</p>
<hr>
<p>참고자료</p>
<ol>
<li><a href="http://suho.berlin/engineering/ios/ios-initwithcoder-initwithnibnamebundle-awakefromnib-loadview/">iOS: initWithCoder:, initWithNibName:bundle:, awakeFromNib, loadView</a></li>
<li><a href="https://stackoverflow.com/questions/1068191/whats-up-with-the-nib-xib">What’s up with the .NIB -&gt; .XIB?</a></li>
</ol>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Corn"></figure><p class="title is-size-4 is-block line-height-inherit">Corn</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">30</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/protocorn93" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/RxSwift/"><span class="level-start"><span class="level-item">RxSwift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/"><span class="level-start"><span class="level-item">WWDC</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/WWDC/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-20T05:29:20.000Z">2020-09-20</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/20/Stacks-Grids-and-Outlines-in-SwiftUI/">Stacks, Grids, and Outlines in SwiftUI</a></p><p class="is-uppercase"></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-20T03:04:00.000Z">2020-09-20</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/20/Meet-WidgetKit/">Meet WidgetKit</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-23T07:22:27.000Z">2020-08-23</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/23/Embrace-Swift-type-inference/">Embrace Swift type inference</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/Swift/">Swift</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-26T08:37:48.000Z">2020-07-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/26/GeometryReader-in-SwiftUI/">GeometryReader in SwiftUI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-19T10:36:32.000Z">2020-07-19</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/19/App-essentials-in-SwiftUI/">App essentials in SwiftUI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">September 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/03/"><span class="level-start"><span class="level-item">March 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Binding/"><span class="tag">@Binding</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/State/"><span class="tag">@State</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ABI-Stability/"><span class="tag">ABI Stability</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AnyView/"><span class="tag">AnyView</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App/"><span class="tag">App</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Thinning/"><span class="tag">App Thinning</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bitcode/"><span class="tag">Bitcode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Custom-URL-Scheme/"><span class="tag">Custom URL Scheme</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GeometryReader/"><span class="tag">GeometryReader</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Group/"><span class="tag">Group</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Opaque-Type/"><span class="tag">Opaque Type</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OptionSet/"><span class="tag">OptionSet</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PreferenceKey/"><span class="tag">PreferenceKey</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Property-Wrappers/"><span class="tag">Property Wrappers</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxSwift/"><span class="tag">RxSwift</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scene/"><span class="tag">Scene</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift5/"><span class="tag">Swift5</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SwiftUI/"><span class="tag">SwiftUI</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Universal-Links/"><span class="tag">Universal Links</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/View/"><span class="tag">View</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC/"><span class="tag">WWDC</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC19/"><span class="tag">WWDC19</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WidgetKit/"><span class="tag">WidgetKit</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WindowGroup/"><span class="tag">WindowGroup</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/enum/"><span class="tag">enum</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS-13/"><span class="tag">iOS 13</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/some/"><span class="tag">some</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%9D%B4%EC%A7%81/"><span class="tag">이직</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Corn the blog" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>