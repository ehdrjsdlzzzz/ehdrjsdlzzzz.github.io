<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Tag: SwiftUI - Corn the blog</title><meta property="og:type" content="blog"><meta property="og:title" content="Corn the blog"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="Corn the blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://yoursite.com/images/avatar.png"><meta property="article:author" content="John Doe"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="images/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com"},"headline":"Corn the blog","image":["http://yoursite.com/images/avatar.png"],"author":{"@type":"Person","name":"John Doe"},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script data-ad-client="ca-pub-3144516292555438" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">SwiftUI</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-09-20T03:04:00.000Z" title="2020-09-20T03:04:00.000Z">2020-09-20</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></span><span class="level-item">22 minutes read (About 3320 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/20/Meet-WidgetKit/">Meet WidgetKit</a></h1><div class="content"><blockquote>
<p> <a href="https://developer.apple.com/videos/play/wwdc2020/10028/">링크</a></p>
</blockquote>
<h2 id="What-makes-a-greate-Widget"><a href="#What-makes-a-greate-Widget" class="headerlink" title="What makes a greate Widget?"></a>What makes a greate Widget?</h2><p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__12.58.16.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__12.58.16.png)</p>
<h3 id="Glanceable"><a href="#Glanceable" class="headerlink" title="Glanceable"></a>Glanceable</h3><p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__12.59.53.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__12.59.53.png)</p>
<p>위젯은 미니앱이 아니다. 단순히 앱의 컨텐츠를 보여주는 것이므로, 컨텐츠에 집중해야하며 한 눈에 볼 수 있는(<em>Glanceable</em>) 컨텐츠를 제공해야 한다. </p>
<h3 id="Relevant"><a href="#Relevant" class="headerlink" title="Relevant"></a>Relevant</h3><p>스마트 스택을 이용해 특정 시점에 적절한 위젯을 보여주어야 한다. 즉 연관성이 있어야 한다. </p>
<p>연관성을 뒷받침 하는 요소들은 다음과 같다. </p>
<ul>
<li>Stacks use on-device intelligence</li>
<li>Siri Shortcuts donation</li>
<li>WidgetKit API</li>
</ul>
<p><a href="https://developer.apple.com/videos/play/wwdc2020/10194/">관련 WWDC 세션 - Add Configuration and intelligence to Your Widgets</a></p>
<h3 id="Personalized"><a href="#Personalized" class="headerlink" title="Personalized"></a>Personalized</h3><p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.07.11.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.07.11.png)</p>
<p>위젯에는 세 가지 크기가 존재한다. 모든 크기를 지원할 필요는 없지만 최대한 많은 사이즈를 지원해 위젯의 개인화를 더욱 향상 시킬 수 있다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.12.09.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.12.09.png)</p>
<p>또한 Shortcut에서 사용했던 Intent를 이용해 구성 옵션(Configuration Option)과 구성 화면(Configuration UI)를 쉽게 구현할 수 있다.</p>
<h2 id="How-WidgetKit-works"><a href="#How-WidgetKit-works" class="headerlink" title="How WidgetKit works"></a>How WidgetKit works</h2><p>위젯은 멀티플랫폼을 지원해야 하기 때문에 SwiftUI로 만들어졌다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.20.58.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.20.58.png)</p>
<p>위젯은 위에서 언급했듯이 한 눈에 볼 수 있어야(<em>Glanceable</em>) 한다. 이를 위해 WidgetKit은 타임라인에 따른 연속된 뷰 계층을 반환해야 한다. 그렇기 때문에 이는 백그라운드 익스텐션에 속한다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.14.37.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.14.37.png)</p>
<p>타임라인에 따른 연속된 뷰 계층을 패키징하여 홈 스크린에 전달하면 홈 스크린은 주어진 타임라인에 따라 정해진 뷰를 그리게 된다. 우리는 이런 메커니즘을 통해 런치 프로세스, 뷰 로딩 등을 피할 수 있다. 이를 통해 위젯은 항상 적절한 컨텐츠를 즉시 볼 수 있게끔 준비되어 있다.</p>
<p>이렇게 미리 뷰가 준비되어 있다는 것은 다른 곳에서 이를 재사용할 수 있다는 것을 의미한다. 아래는 이렇게 준비된 뷰가 위젯 갤러리에서 사용되는 모습이다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.23.07.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.23.07.png)</p>
<p>이런 타임라인 메커니즘으로 우리는 위젯을 통해 항상 적절한 컨텐츠를 바로 볼 수 있다. </p>
<p>그리고 이런 타임라인은 메인 앱에서 사용자가 컨텐츠에 영향을 주는 데이터를 변경했을 때 갱신될 수 있다. 혹은 익스텐션에서 이러한 갱신을 스케쥴링해줄 수도 있다.</p>
<p>예를 들어 캘린더 위젯은 하루동안의 이벤트가 언제 일어날지에 대해 알고 있다. 익스텐션은 이 정보를 바탕으로 적절한 시간에 해당하는 뷰를 랜더링한다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.27.34.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.27.34.png)</p>
<h2 id="How-to-make-a-great-Widget"><a href="#How-to-make-a-great-Widget" class="headerlink" title="How to make a great Widget?"></a>How to make a great Widget?</h2><p>훌륭한 위젯을 만드는 방법을 아래 주제들을 통해 알아보자</p>
<ul>
<li>Defining a widget</li>
<li>Creating a glanceable experience</li>
<li>Views, timelines and reloads</li>
<li>Personaliztion and intelligence</li>
</ul>
<h3 id="Defining-a-widget"><a href="#Defining-a-widget" class="headerlink" title="Defining a widget"></a>Defining a widget</h3><p>위젯을 정의하기 위해선 몇 가지 컨셉에 대해서 짚고 넢어가야한다. </p>
<ul>
<li><code>kind</code></li>
<li><code>configuration</code></li>
<li><code>supportFamilies</code></li>
<li><code>placeholder</code></li>
</ul>
<p>처음 위젯을 설계할 때 하나의 익스텐션으로 다양한 유형의 위젯을 지원할 수 있는 메커니즘을 구상했다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.37.31.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.37.31.png)</p>
<p>주식 앱 익스텐션을 예로 들자면, 이는 몇 가지 종목에 대한 개요를 볼 수 있는 위젯을 제공한다. 하지만 추가로 한 가지 종목에 대한 상세 정보를 확인할 수 있는 위젯을 제공하거나 혹은 macOS의 알람 센터에서 확인할 수 있는 위젯을 제공한다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.39.35.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.39.35.png)</p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.39.42.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.39.42.png)</p>
<p>위젯의 종류(<code>kind</code>)는 자신들이 어떤 유형의 Configuration을 지원하는지를 나타내기도 한다. 이런 Configuration에는 두 가지가 존재한다. </p>
<ul>
<li><p><code>StaticConfiguration</code></p>
</li>
<li><p><code>IntentConfiguration</code></p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.46.15.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.46.15.png)</p>
</li>
</ul>
<p><strong><code>StaticConfiguration</code></strong></p>
<p>피트니스앱의 위젯은 단순히 현재 피트니스 상태를 알려주고, 딱히 사용자가 이를 구성할 수 있도록 지원할 필요는 없다. 이는 <code>StaticConfiguration</code> 타입이다.</p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.48.28.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.48.28.png)</p>
<p><strong><code>IntentConfiguration</code></strong></p>
<p>다시 알림앱은 목록을 사용자가 수정하고 개인화할 수 있다. 이는 <code>IntentConfiguration</code> 타입에 해당한다.</p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.49.04.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.49.04.png)</p>
<p>위젯은 하나 혹은 다수의 <code>supportedFamilies</code>를 지원할 수 있다. 기본적으로 위젯은 모든 <code>supportedFamilies</code> 타입을 지원한다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.49.18.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.49.18.png)</p>
<p><code>placeholder</code>는 위젯의 기본 컨텐츠(Default Content)가 된다. <code>placeholder</code>를 통해 위젯이 어떤 유형의 컨텐츠를 제공하는지만을 나타내야지 사용자 데이터가 포함되어 있어서는 안된다. </p>
<p>또한 <code>placeholder</code>는 자주 볼 수 있는 UI가 아니고 언제 보일지는 보장할 수 없다. 일반적으로 기기 환경 설정이 변경되었을 때 새 <code>placeholder</code>를 요청하곤 한다. </p>
<p>사용자에게 위젯이 어떤 유형의 컨텐츠를 제공하는지를 잘 나타내는 <code>placeholder</code>가 훌륭한 <code>placeholder</code>다.</p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.52.33.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.52.33.png)</p>
<p>아래의 코드는 위에서 살펴본 네 가지 키워드가 모두 담겨져있다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.59.44.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__1.59.44.png)</p>
<h3 id="Creating-a-glanceable-experience"><a href="#Creating-a-glanceable-experience" class="headerlink" title="Creating a glanceable experience"></a>Creating a glanceable experience</h3><p>아래는 glanceable한 위젯의 예들이다. 위젯은 유용한 정보를 제공하며 사용자로 하여금 위젯을 탭 하여 더 많은 정보를 볼 수 있게끔 유도하고 있다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.00.50.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.00.50.png)</p>
<p>한 눈에 보기 쉬운 위젯을 만들기 위한 요소 중 하나는 Stateless한 UI다. 이는 다음과 같은 특성을 갖는다. </p>
<ul>
<li>No Scrolling</li>
<li>No videos or animated images</li>
<li>Tap interactions</li>
</ul>
<p>위젯은 딥 링크를 지원하므로, 탭을 통해 메인 앱의 특정 컨텐츠로 사용자를 유도할 수 있다. 이런 딥 링크는 <a href="https://www.notion.so/bakedcorn/Meet-WidgetKit-01d8e3012b8b400298808b6017a14d08">widgetURL</a>를 이용해 구현할 수 있다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.09.55.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.09.55.png)</p>
<h3 id="Views-timelines-and-reloads"><a href="#Views-timelines-and-reloads" class="headerlink" title="Views, timelines and reloads"></a>Views, timelines and reloads</h3><p>뷰, 타임라인 그리고 갱신은 위젯의 엔진 역할을 한다. </p>
<p>뷰를 위한 세 가지 개념이 존재한다. </p>
<ul>
<li>Placeholder</li>
<li>Snapshot</li>
<li>Timeline</li>
</ul>
<p><strong><u>Snapshot</u></strong></p>
<p>Snapshot은 시스템이 위젯을 빠르게 제공하기 위해 필요한 단일 진입점이다. 이를 위해 익스텐션은 이 뷰를 최대한 빨리 반환해주어야 한다. 그리고 이렇게 반환된 Snapshot은 위젯 갤러리에서 확인할 수 있다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.16.28.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.16.28.png)</p>
<p>보통 Timeline의 첫 번째 진입점과 Snapshot은 동일한 진입점으로 반환될 수 있다. 그렇기 때문에 위젯 갤러리에서 보는 것은 사용자가 위젯을 디바이스에 추가했을 때의 보는 모습과 동일하다.</p>
<p>Snapshot이 단지 하나의 단일 진입점이라면, 제시간에 보여지는 다수의 연속된 뷰는 Timeline이라고 할 수 있다.</p>
<p><strong><u>Timeline</u></strong></p>
<p>Timeline은 뷰와 날짜의 조합으로 어떤 뷰가 언제 보여져야 하는지를 나타낸다. Timeline은 다크모드, 라이트모드 모두  반환해야 한다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.20.33.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.20.33.png)</p>
<p>익스텐션이 진입점을 제공하면 우리는 이 정보를 받아 디스크에 뷰 계층을 직렬화한다. 이를 통해 적절한 타이밍에 각 항목을 렌더링할 수 있다. 이런 방식으로 시스템은 수많은 Timeline을 통해 동시에 수많은 위젯에 이를 적용할 수 있다. </p>
<p>타임라인은 일반적으로 하루치 컨텐츠를 제공해야 한다. 그러나 주어진 시간에 따른 컨텐츠가 아닌 최신 정보를 보여주어야 할 때가 있다. 우린 이를 갱신(Reload)이라 부른다.</p>
<p><strong><u>Reload</u></strong></p>
<p>Reload란, 시스템이 익스텐션을 깨우고 각각의 위젯을 위한 새 Timeline을 요청하는 것을 말한다. Reload를 통해 사용자의 컨텐츠가 항상 최신 상태로 유지되도록 할 수 있다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.24.08.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.24.08.png)</p>
<p>아래는 <a href="https://developer.apple.com/documentation/widgetkit/timelineprovider"><code>TimelineProvider</code></a> 프로토콜로 WidgetKit에 언제 위젯을 갱신해주어여 하는지 알릴 때 사용된다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.29.48.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.29.48.png)</p>
<p><code>reloadPolicy</code></p>
<p>시스템에게 언제 다음 Timeline을 요청해야 하는지를 알려주는 일종의 갱신 정책이다. </p>
<ul>
<li><p><code>atEnd</code></p>
</li>
<li><p><code>after(date: Date)</code></p>
</li>
<li><p><code>never</code></p>
<p><a href="https://developer.apple.com/documentation/widgetkit/keeping-a-widget-up-to-date">관련 개발자 문서</a></p>
</li>
</ul>
<p><img src="https://docs-assets.developer.apple.com/published/2971813b6a098a34d134a04e38a50b83/1900/WidgetKit-Timeline-At-End@2x.png" alt="https://docs-assets.developer.apple.com/published/2971813b6a098a34d134a04e38a50b83/1900/WidgetKit-Timeline-At-End@2x.png"></p>
<p>시스템은 reloadPolicy를 받아 위젯을 갱신(reload)한다. 자주 보는 위젯은 더 자주 갱신될 것이고,  아닌 위젯은 덜 자주 갱실될 것이다. 또한 기기 환경 설정이 변경되면 시스템은 강제로 위젯을 갱신한다. </p>
<p>이렇게 시스템에 의한 위젯 갱신도 있지만 메인 앱 주도의 갱신도 존재한다. </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.40.27.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.40.27.png)</p>
<p>백그라운드 노티피케이션 혹은 앱 내의 데이터 변경에 의해 위젯이 갱신될 수 있는데 이때 우리는 <a href="https://developer.apple.com/documentation/widgetkit/widgetcenter"><code>WidgetCenter</code></a>를 사용해 위젯을 갱신해줄 수 있다.  </p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.43.16.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.43.16.png)</p>
<p>서버로부터 받아온 정보를 바탕으로 위젯을 갱신해주기 위해선 백그라운드 세션을 사용해야 한다. 또한 서버 통신으로 만들어진 payload는 <a href="https://developer.apple.com/documentation/widgetkit/intentconfiguration/onbackgroundurlsessionevents(matching:_:)-78bry">onBackgroundURLSesionEvents</a> 변경자를 통해 전달된다. 요청은 일괄처리하고, 서버 통신은 필요한만큼만 사용해야 한다. </p>
<p>위젯은 매초마다 수행되는 작업이 아니다. 실시간 실행 환경도 아니다. 상태에 맞는 갱신 정책을 통해 위젯을 효율적으로 갱신해야 한다.</p>
<p>![Meet%20WidgetKit%207bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.49.54.png](/Users/dongkunlee/Desktop/Meet WidgetKit/Meet WidgetKit 7bddad77d7984f7da4ab80b9b640dee0/_2020-09-14__2.49.54.png)</p>
<h3 id="Personalized-and-intelligence"><a href="#Personalized-and-intelligence" class="headerlink" title="Personalized and intelligence"></a>Personalized and intelligence</h3><p>위젯의 개인화와 지능은 두 가지 요소로 결정된다. </p>
<ul>
<li><strong>Intents</strong></li>
<li><strong>Relevance</strong></li>
</ul>
<p><strong><u>Intents</u></strong></p>
<p>Intent는 사용자가 위젯을 구성하는데 사용되는 메커니즘이다.</p>
<p>Intent를 통해 사용자에게 일종의 질문을 하고 (어떤 위치의 날씨 정보를 원하는지, 어떤 주식 종목을 원하는지) 시스템이나 앱은 이에 대한 응답으로 위젯을 갱신한다. 이를 통해 우린 위젯의 사용자화를 향상시킬 수 있다. </p>
<p><strong><u>Relevance</u></strong></p>
<p>스마트 스택의 지능에 영향을 미칠 수 있는 요인 중 하나다. </p>
<blockquote>
<p><em>When users perform actions in your app, your app can donate shortcuts.<br>If your widget is backed by the same INIntent, then your widget may be rotated to in the stack when the user would have typically perform that action.</em></p>
</blockquote>
<p>또한 <a href="https://developer.apple.com/documentation/widgetkit/timelineentryrelevance"><code>TimelineEntryRelevance</code></a> 구조체의 <code>score</code>와 <code>duration</code>을 이용해 관련성(Relevance)에 영향을 줄 수 있다.</p>
<p>[관련 WWDC 세션 - Add Configuration and intelligence to Your Widgets](</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-15T08:26:52.000Z" title="2020-02-15T08:26:52.000Z">2020-02-15</time><span class="level-item"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></span><span class="level-item">23 minutes read (About 3398 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/15/SwiftUI-under-the-hood/">SwiftUI under the hood</a></h1><div class="content"><p>요즘 SwiftUI를 공부하면서 느낀 점은 마냥 쉽지만은 않다는 것이다. 흔히 SwiftUI를 소개할 때 매우 쉽게 UI를 그릴 수 있는 프레임워크로 소개하곤 하는데, 완전히 틀린 말은 아니지만 그렇다고 완전히 맞는 말도 아닌 것 같다. SwiftUI를 공부하면서 처음 iOS를 공부했을 때, 더 나아가 처음 프로그래밍을 공부했을 때가 종종 생각나곤 한다. </p>
<p>당시 처음으로 프로그래밍 언어를 가르쳐 주신 강사님으로부터 기본적인 C 언어 문법을 배우고 모든 걸 배운 것처럼 기세등등했던 적이 있다. 자신감이 한없이 하늘을 찌르고 있을 때 강사님은 다음과 같은 말씀을 해주셨다. </p>
<p>*”원래 처음 프로그래밍을 배우고 기본 문법을 마친 사람들이 프로그래밍을 매우 쉽다고 생각하고 자만하게 됩니다. 하지만 공부를 하면 할수록 어렵게 느껴지고 자신감이 떨어질 수 있는 공부가 프로그래밍입니다.”*</p>
<blockquote>
<p>비단 프로그래밍에만 국한되는 이야기는 아닌 것 같다.</p>
</blockquote>
<p>당시에는 이해가 가질 않았으나, 본격적으로 학부 공부를 시작하고 취업 준비를 하면서 저 말이 계속해서 떠올랐고 자신감이 자주 떨어지곤 했다. SwiftUI를 공부하면서도 마찬가지였다. 처음 <code>VStack</code>, <code>List</code> 등을 사용하면서 그 간편함에 놀라고 매우 쉽다고 생각했다. 하지만 데이터의 흐름과 레이아웃이 결정되는 방식 등 깊게 파고들면 파고들수록 머릿속은 여러 개념들이 완전하지 않은 채  뒤엉키게 되었다. 그렇게 혼란스러워하던 중 한 컨퍼런스에서 Chris Eidhof가 “SwiftUI under the hood”란 주제로 발표한 영상을 보고 복잡하고 산발되어 있던 개념들이 어느 정도 정리가 되면서 여러 개념들의 존재 이유와 목적에 대해 감을 잡을 수 있었다. 오늘은 그 영상의 내용을 요약 및 정리해보는 시간을 가지려 한다. </p>
<blockquote>
<p>영상 : <a href="https://youtu.be/GuK6wwX8M0E">Chris Eidhof - SwiftUI under the hood</a></p>
</blockquote>
<p>영상에서 다루는 큰 주제는 레이아웃 알고리즘이다. 즉 SwiftUI가 어떤 방식으로 레이아웃을 그리는지에 대해 다룬다. 이를 설명하면서 <code>GeometryReader</code>, <code>Preference</code> 등 중요한 개념들이 자연스럽게 등장하며 설명을 돕는다.</p>
<p>서론이 너무 길었다. 바로 시작해보자.</p>
<hr>
<h3 id="Layout-Algorithm"><a href="#Layout-Algorithm" class="headerlink" title="Layout Algorithm"></a>Layout Algorithm</h3><p>파란색 배경의 원 안에 텍스트가 존재하는 뷰를 만든다고 상상해보자. 원이 아닌 다양한 도형이 될 수 있다. 즉 매우 흔한 상황이다. 우리가 원하는 결과물은 다음과 같을 것이다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/0.5.png" alt=""></p>
<p>매우 쉬워 보인다! 그럼 코드로 이를 만들어보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">	.background(</span><br><span class="line">    <span class="type">Circle</span>()</span><br><span class="line">    .fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>기대하던 모습이 나올까? 그렇지 않다. 그 모습은 우리가 기대하던 모습과 거리가 멀다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/1.png" alt=""></p>
<p>이유가 무엇일까? 그 이유를 알기 위해선 SwiftUI의 레이아웃 알고리즘에 대한 이해가 있어야 한다. 모든 레이아웃은 다음 4가지 단계를 통해 그려진다. </p>
<ol>
<li>컨테이너 뷰(직계 상위 뷰)가 사이즈를 제안한다. </li>
<li>하위 뷰가 자신의 사이즈를 결정한다. (하위 뷰는 상위 뷰가 제안한 사이즈를 그대로 사용하거나, 본인이 자신의 사이즈를 결정하기도 한다.)</li>
<li>하위 뷰가 컨테이너 뷰에 자신의 사이즈를 알린다. (2단계에서 결정된 사이즈로 컨테이너 뷰의 사이즈가 정해진다.)</li>
<li>컨테이너 뷰가 하위 뷰를 가운데 정렬 시킨다. (<code>alignment</code>)</li>
</ol>
<p>이는 아주 기본적인 절차이고 여러 값들의 재정의를 통해 변경될 수 있다. 그럼 이 알고리즘을 바탕으로 위의 코드를 분석해보자. 먼저 위의 코드로 그려진 뷰의 계층을 뷰 디버깅을 통해 살펴보고 아래 설명을 따라가면서 이해해보자.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/3.png" alt=""></p>
<ol>
<li><p>먼저 루트 뷰(root view)가 화면 전체 사이즈를 <code>background</code>에게 제안한다. 그리고 <code>background</code>는 이를 다시 <code>Text</code>에게 전달한다. </p>
<blockquote>
<p>Modifier는 새로운 뷰를 만들고 이전 뷰를 감싸서 반환한다는 것을 기억한다면 <code>background</code>가 <code>Text</code>를 감싸고 있다는 것을 이해할 수 있다. </p>
</blockquote>
</li>
<li><p>하지만 <code>Text</code>는 자신이 담고 있는 내용만큼만 필요하기 때문에 <code>&quot;Reset&quot;</code>만큼만 사용할 것을 <code>backgroud</code>에 알린다. </p>
</li>
<li><p>그럼 다시 <code>background</code>는 이를 하위 뷰인 <code>ShapeView</code>에 알리고 <code>ShapeView</code>는 이를 <code>Circle</code>에게 알린다. (<code>ShapeView</code>와 <code>Text</code>는 형제-자매(sibling) 관계다.) <code>Circle</code>는 받은 크기(<code>Text</code>의 크기)를 그대로 사용해서 그 크기에 딱 맞는 원을 그린다.</p>
</li>
<li><p>그리고 이를 <code>background</code>에게 전달하고 <code>background</code>는 다시 이 크기를 루트 뷰에 전달하고 루트 뷰는 해당 뷰를 가운데 정렬한다.</p>
</li>
</ol>
<p>뷰 계층과 알고리즘을 따라가보면 왜 우리가 원하는 레이아웃이 나오지 않았는지에 대해 이해할 수 있다. 그럼 우리가 원하는 레이아웃을 그리기 위해선 어떻게 해야 할까?</p>
<p>가장 먼저 떠오르는 생각은 <code>frame</code> 변경자를 사용하는 것이다. 사용하기에 앞서 <code>frame</code> 변경자의 특징을 알아야 한다. <strong><code>frame</code> 변경자는 상위 뷰에서 오는 크기 정보나, 하위 뷰에서 알려주는 크기 정보를 모두 무시하고 자신의 인자로 넘어온 크기 정보만 사용한다.</strong> 이 점을 기억하고 아래 코드를 살펴보자.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line"><span class="comment">//.frame(width: 75, height: 75) // --- 1</span></span><br><span class="line">	.background(</span><br><span class="line">    <span class="type">Circle</span>()</span><br><span class="line">    	.fill(<span class="type">Color</span>.blue)</span><br><span class="line"><span class="comment">//    .frame(width: 75, height: 75) // --- 2</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">//.frame(width: 75, height: 75) // --- 3</span></span><br></pre></td></tr></table></figure>

<p><code>frame</code> 연산자를 1, 2번 두 곳 중 한 곳에만 위치시켜도 원하는 레이아웃을 그릴 수 있다. 하지만 두 곳 모두 문제점을 갖고 있다. </p>
<ol>
<li><p>위에서 언급했듯이 <code>frame</code>은 하위 뷰에서 알려준 크기 정보도 무시한다. 즉 <code>Text</code>가 정한 크기도 무시한다는 뜻이다. 그렇기 때문에 이곳에 <code>frame</code>을 위치시면 길어진 문자열 크기를 <code>Text</code>가 아무리 <code>frame</code>에 알려도 <code>frame</code>은 자신의 정보로 크기를 결정하기 때문에 문자열은 75x75 영역 안에서 벗어날 수 없고, 해당 영역 안에 표시되지 못한 부분은 말 줄임표(<code>...</code>)로 나타나게 된다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/5.png" alt=""></p>
</li>
<li><p><code>frame</code> 영역은 <code>Circle</code>에만 영향을 주기 때문에 문자열이 길어지면 원의 영역을 벗어난다. </p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/6.png" alt=""></p>
</li>
</ol>
<p><code>frame</code>을 3번에 위치시키면 어떻게 될까? <code>frame</code>이 이 크기 정보(75x75)를 <code>background</code>에게 <code>background</code>가 다시 <code>Text</code>에 전달하지만 <code>Text</code>는 자신이 담고 있는 내용만큼만 사용한다고 <code>background</code>에 알리고 <code>background</code>는 이 정보를 다시 <code>Circle</code>에 전달하기 때문에 결과적으로 위에서 봤던 레이아웃과 동일한 것을 육안으로 확인할 수 있다.</p>
<p><img src="/2020/02/15/SwiftUI-under-the-hood/4.png" alt=""></p>
<p>육안으로 확인한 레이아웃이 같다고 실제로 그 둘이 같은 것은 아니다. 전체를 감싸고 있는 뷰의 크기 차이가 존재한다(파란 테두리가 감싸고 있는 영역). 그 이유는 위에서 언급했듯이 <code>frame</code>은 하위 뷰에서 보낸 정보도 무시하기 때문에 자신의 크기 정보(75x75)를 사용한다. 그렇기 때문에 전체를 감싸고 있는 뷰의 크기에 차이가 생기는 것이다.</p>
<p>문제를 해결하기 위해선 <code>frame</code> 안에 들어갈 값은 문자열의 길이에 따라 동적으로 변경되어야 한다. 정확히는 <code>Text</code>의 크기에 따라 변경되어야 한다. 그럼 <code>Text</code>의 크기는 어떻게 알 수 있을까? UIKit을 사용할 땐 객체에 직접 접근해 값을 가져올 수 있었다. 하지만 SwiftUI에선 불가능하다. 우리는 이 문제점을 <code>GeometryReader</code>를 사용해 해결해보려 한다. </p>
<h3 id="GeometryReader"><a href="#GeometryReader" class="headerlink" title="GeometryReader"></a>GeometryReader</h3><p><code>GeometryReader</code>는 SwiftUI에서 중요한 개념이지만 이번 포스팅에선 현재 상황에서 <code>GeometryReader</code>가 해결할 수 있는 부분에 대해서만 간단하게 설명해보고자 한다. </p>
<p><code>GeometryReader</code>는 컨테이너 뷰의 한 종류로 자신의 직계 상위 뷰의 기하학(Geometry) 정보(좌표, 크기 등)를 자신이 포함하는 자식 뷰에게 제공하는 역할을 한다. 그럼 바로 사용해보자. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">	.padding()</span><br><span class="line">	.fixedSize()</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span> </span><br><span class="line">    	<span class="comment">// proxy.size.width == Text("Reset")'s width               </span></span><br><span class="line">		&#125;</span><br><span class="line">  )</span><br><span class="line">	.frame(width: <span class="number">75</span>, height: <span class="number">75</span>)</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">Circle</span>()</span><br><span class="line">    	.fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>fixedSize</code> 변경자는 <code>Text</code>에만 존재하는 변경자로 아무리 문자열이 길어져도 1줄에 보여주도록 강제한다. 이를 사용하면 위에서 보았던 이미지처럼 주어진 크기 안에서 문자열이 길어질 때 여러 줄과 함께 말 줄임표로 보여주는 것이 아니라 영역을 벗어나더라도 문자열을 1줄에 보여줄 수 있다.</p>
</blockquote>
<p>단순히 직계 상위 뷰의 정보를 받아온다고 생각하지 말고 위에서 살펴보았던 레이아웃 결정 과정을 대입해서 생각해보자.</p>
<ol>
<li><code>background</code>는 루트 뷰로부터 크기를 제안받는다. </li>
<li><code>background</code>는 그 크기를 <code>Text</code>에게 제안한다.</li>
<li><code>Text</code>는 자신이 포함하는 내용만을 담을 수 있는 크기를 사용하기로 결정하고 이를 <code>background</code>에게 알린다.</li>
<li><code>background</code>는 그 정보를 <code>GeometryReader</code>에게 알린다. </li>
</ol>
<p>이런 순서로 <code>GeometryReader</code>는 직계 상위 뷰의 정보를 받아올 수 있는 것이다. 정확히 표현하자면 <code>Text</code>에 의해 결정된 크기를 사용하는 <code>background</code>의 크기 정보를 받아온 것이다. 그럼 우린 이 크기 정보를 사용하면 된다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> width: <span class="type">CGFloat?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">	.padding()</span><br><span class="line">	.fixedSize()</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span> </span><br><span class="line">      <span class="keyword">self</span>.width = proxy.size.width</span><br><span class="line">		&#125;</span><br><span class="line">  )</span><br><span class="line">	.frame(width: <span class="keyword">self</span>.width, height: <span class="keyword">self</span>.width)</span><br><span class="line">	.background(</span><br><span class="line">  	<span class="type">Circle</span>()</span><br><span class="line">    	.fill(<span class="type">Color</span>.blue)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>위와 같이 코드를 작성할 수 있을 것 같지만 실제로 이렇게 작성하면 에러가 발생한다. 왜냐하면 <code>GeometryReader</code>는 생성자로 <code>@ViewBuilder</code>를 받기 때문에 <code>self.width = proxy.size.width</code>와 같은 코드는 <code>@ViewBuilder</code> 안에 작성할 수 없다.</p>
<p>우린 이 시점에서 프록시(<code>GeometryProxy</code>)에 담긴 크기 정보를 바로 <code>width</code> 프로퍼티에 할당할 수 없다. 우린 이 정보를 뷰 계층 위로 전달해야 한다. 이렇게 하위 뷰에서 상위 뷰로 정보를 전달하기 위해서 사용하는 것이 바로 <code>Preference</code>다.</p>
<h3 id="Preference"><a href="#Preference" class="headerlink" title="Preference"></a>Preference</h3><p><code>Preference</code> 역시 <code>GeometryReader</code>와 마찬가지로 굉장히 중요한 개념 중 하나이다. 하지만 마찬가지로 현재 상황에서 <code>Preference</code>가 해결할 수 있는 부분에 대해서만 간단하게 설명해보고자 한다. </p>
<p><code>Preference</code>는 키-밸류 메커니즘으로 하위 뷰 정보를 상위 뷰에 전달할 수 있는 수단이다. 이를 위해선 먼저 <code>PreferenceKey</code> 프로토콜을 따르는 키를 정의해주어야 한다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SizeKey</span>: <span class="title">PreferenceKey</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">reduce</span><span class="params">(value: <span class="keyword">inout</span> CGFloat?, nextValue: <span class="params">()</span></span></span> -&gt; <span class="type">CGFloat?</span>) &#123;</span><br><span class="line">    value = nextValue()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>간단하게 설명하자면 <code>reduce</code> 메소드는 <code>SizeKey</code>를 사용하는 하위 뷰들을 순회하면서 상위 뷰가 접근할 수 있는 값을 만들기 위해 이들의 값(<code>SizeKey</code>를 사용하는 하위 뷰의 값) 취합하는 역할을 한다.</p>
<blockquote>
<p>이번 포스팅에선 단순히  <code>PreferenceKey</code>의 기능만을 소개하지만 추후 포스팅에서 더욱 자세히 다룰 예정이다. 하지만 당장 궁금하다면 <a href="https://swiftui-lab.com/communicating-with-the-view-tree-part-1/">이 글</a>을 참고하면 좋을 것이다.</p>
</blockquote>
<p>그리고 간단한 트릭(?)을 사용해서 우린 뷰 계층 위로 <code>proxy</code> 정보를 전달할 수 있다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">  @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> width: <span class="type">CGFloat?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Reset"</span>)</span><br><span class="line">    .padding()</span><br><span class="line">    .fixedSize()</span><br><span class="line">    .background(</span><br><span class="line">      <span class="type">GeometryReader</span> &#123; proxy <span class="keyword">in</span></span><br><span class="line">				<span class="type">Color</span>.clear.preference(key: <span class="type">SizeKey</span>.<span class="keyword">self</span>, value: proxy.size.width) <span class="comment">// --- 1</span></span><br><span class="line">			&#125;</span><br><span class="line">    )</span><br><span class="line">    .frame(width: <span class="keyword">self</span>.width, height: <span class="keyword">self</span>.width)</span><br><span class="line">    .background(</span><br><span class="line">      <span class="type">Circle</span>()</span><br><span class="line">      .fill(<span class="type">Color</span>.blue)</span><br><span class="line">    )</span><br><span class="line">    .onPreferenceChange(<span class="type">SizeKey</span>.<span class="keyword">self</span>) &#123; value <span class="keyword">in</span> <span class="comment">// --- 2</span></span><br><span class="line">			<span class="keyword">self</span>.width = value</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Color</code>도 <code>View</code> 프로토콜을 따른다. 그렇기 때문에 사용자는 볼 수 없는 <code>Color.clear</code>에 <code>preference</code>를 통해 <code>proxy.size.width</code>를 전달하고 있다. </li>
<li>상위 뷰(<code>Text</code>)에선 하위 뷰에서 전달한 정보를 <code>onPreferenceChange</code>를 통해 받을 수 있다. </li>
</ol>
<p>이제 진짜 우리가 원하던 레이아웃을 확인할 수 있을 것이다. </p>
<hr>
<h3 id="정리하며"><a href="#정리하며" class="headerlink" title="정리하며"></a>정리하며</h3><p>간단한 레이아웃(?)을 그려보면서 SwiftUI를 관통하는 여러 개념들을 자연스럽게 접해볼 수 있던 영상이었다. SwiftUI가 레이아웃을 그리는 알고리즘에 대해 이해하고 나니 왜 그렇게 그려지는지 이해가 가지 않았던 부분들이 어느정 도 머릿속에 정리가 되는 시간이었다.</p>
<blockquote>
<p>영상 말미에 한 가지 과제(?)를 주는데 이 부분은 <a href="https://github.com/ehdrjsdlzzzz/SwiftUI-practice/tree/master/SwiftUIUnderTheHood">github</a>에 올려놓았습니다.</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-26T12:10:52.000Z" title="2019-12-26T12:10:52.000Z">2019-12-26</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></span><span class="level-item">19 minutes read (About 2789 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/26/SwiftUI-Essentials-2/">SwiftUI Essentials (2)</a></h1><div class="content"><h2 id="Building-custom-views"><a href="#Building-custom-views" class="headerlink" title="Building custom views"></a>Building custom views</h2><p>SwiftUI로 커스텀 뷰를 만드는 방식에 대해 이야기 해보자. </p>
<p>주문 내역을 보여주는 <code>OrderHistory</code>를 살펴보자.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/1.png" alt=""></p>
<p>위의 코드에서 먼저 살펴볼 부분은 바로 <code>View</code> 프로토콜을 따르고 있는 <code>OrderHistory</code>가 구조체로 선언되어 있다는 점이다.</p>
<p>일반적으로 UIKit으로 뷰를 만들면 프로토콜을 따르는 구조체가 아닌 공통 부모 클래스로부터 상속받는 클래스를 작성하곤 한다. <code>OrderHistory</code>를 UIKit으로 만든다면 다음과 같은 상속 관계를 가질 것이다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/2.png" alt=""></p>
<p><code>UIView</code>는 <code>alpha</code>나 <code>backgroundColor</code> 같은 공통된 저장 프로퍼티(stored property)를 갖고 있다. <code>OrderHistory</code>는 자신의 <code>previousOrders</code> 프로퍼티와 더불어 부모 클래스의 프로퍼티까지 갖고 있게 된다. 반면에 SwiftUI는 어떨까? </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/3.png" alt=""></p>
<p>SwiftUI는 이런 공통된 저장 프로퍼티를 분리된 변경자로 관리하고 각각의 변경자는 자신들만의 뷰를 생성하게 된다. 그러므로 공통된 저장 프로퍼티는 뷰 계층 전반에 걸쳐 분산된다. 이러한 방식으로 뷰를 더 가볍게 해서 각 뷰의 고유 목적에 맞게 최적화한다.</p>
<p>이러한 방식 때문에 SwiftUI에서 뷰가 프로토콜이 된다고 할 수 있는 것이다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/4.png" alt=""></p>
<p>그럼 뷰는 무엇을 하는 것일까?</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/5.png" alt=""></p>
<p>뷰는 단지 UI의 한 조각을 정의할 뿐이고 우린 이런 뷰들을 이용하고 재사용하여 뷰 계층을 구성하는 것이다. <code>View</code> 프로토콜의 살펴보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/6.png" alt=""></p>
<p>위의 코드를 보고 있으면 어떤 생각이 드는가? 재귀적이지 않은가? </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/7.png" alt=""></p>
<p>하나의 뷰가 있고 그 뷰의 <code>body</code>가 다른 뷰를 나타내고 그 뷰의 <code>body</code>가 또 다른 뷰를 나타내는 이런 구조를 보일 수 있다고 생각할 수 있는데 이는 지속되지 않는다. 그 이유는 SwiftUI가 스스로 컨텐츠를 갖지 않고 다른 뷰를 구성하는 아토믹(atomic)한 뷰인 원시 뷰(primitive view)를 제공하고 위와 같은 <code>body</code> 사슬의 끝은 결국 이런 원시 뷰이기 때문이다.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/8.png" alt=""></p>
<p>우리가 위에서 보았던 <code>Text</code>나 <code>Image</code>와 더불어 드로잉에 사용되는 <code>Color</code>와 <code>Shape</code>, 레이아웃에 사용되는 <code>Spacer</code>와 같은 다양한 원시 뷰를 제공한다. </p>
<p>다시 <code>OrderHistory</code>로 돌아와 클래스가 아닌 구조체로 정의된 것에 주목해보자. 클래스로 정의한 것이 아니기 때문에 <code>OrderHistory</code>는 더 이상 이벤트 기반으로 동작하는 명령형 코드로 갱신되는 영구적인 객체가 아니다.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/9.png" alt=""></p>
<p>대신 뷰는 Input에 따라 결과가 달라지는 함수와 같이 선언형 코드로 정의된다. 이 말은 Input이 변경되면 SwiftUI가 <code>body</code> 프로퍼티를 다시 호출해서 뷰를 갱신한다.</p>
<p>만일 이벤트 기반의 명령형 코드였다면 Input의 변경(삭제, 삽입 등)에 따른 갱신 코드를 작성해주어야 했는데, SwiftUI에서는 선언형 코드로 인풋이 변경되면 SwiftUI가 내부적으로 이전 데이터와 새 데이터를 비교해서 무엇이 변경되었는지를 비교 후 효율적으로 뷰를 갱신하게 된다.</p>
<p><code>OrderHistory</code> 코드를 계속해서 살펴보자. 조건에 따라 뷰의 유무를 표시할 때 우리는 다음과 같이 뷰 빌더 클로저 안에 조건문을 통해 이를 구현할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/10.png" alt=""></p>
<p>하지만 이런 조건문도 상황에 따라 제대로 사용해야 한다. 다음 상황의 코드를 살펴보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/11.png" alt=""></p>
<p><code>flipped</code> 값에 따라 아이콘의 각도를 다르게 보여주고 싶을 때 위와 같이 작성할 수 있다. 하지만 이는 잘못된 방법이다. 이런 코드는 부자연스러운 애니메이션을 만들게 된다. 이 코드는 SwiftUI에게 서로 다른 뷰 중 하나를 선택하게 하는 것이고 이는 곧 뷰의 추가와 삭제를 의미한다. 뷰의 추가와 삭제는 fade 애니메이션이 적용되기에 부자연스러운 애니메이션을 보게 되는 것이다. </p>
<p>우리가 원하는 자연스러운 애니메이션을 위해선 다음과 같이 코드를 작성해야 한다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/12.png" alt=""></p>
<p>여기서 얻을 수 있는 교훈은 이런 조건에 따라 다른 값에 의한 뷰의 변화를 부드러운 애니메이션을 통해 제공하기 위해선 최대한 이를 변경자 내부에 위치시켜 SwiftUI가 변화를 감지하여 보다 부드러운 애니메이션을 제공하도록 해야 한다는 것이다.</p>
<p>또한 비대해진 <code>OrderHistory</code>를 우린 더 작은 뷰로 나누어 관리할 수도 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/13.png" alt=""></p>
<p>만일 <code>OrderHistory</code>에 조건에 따라 또 다른 뷰가 추가되어야 한다면 코드를 어떻게 작성해야할까</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/14.png" alt=""></p>
<p>위와 같은 방법은 확장성이 매우 떨어진다. 우리는 이런 상황에서 <code>ForEach</code> 뷰를 사용할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/15.png" alt=""></p>
<p><code>ForEach</code>는 하나의 뷰로 <code>List</code>와 마찬가지로 콜렉션 데이터 타입을 인자로 받는다. 그리고 뷰 빌더 클로저 안에 뷰를 나열하는데 이때 나열된 뷰는 <code>ForEach</code>에 추가되지 않고 <code>ForEach</code>의 상위 뷰에 추가된다.</p>
<p>지금까지 작성된 코드들을 보면 우리가 직접 작성하지 않고도 SwiftUI가 스스로 그리고 반응하며 갱신하는 것을 확인할 수 있었다. 이것이 바로 선언형 코드의 장점이라 할 수 있다.</p>
<h2 id="Composing-Controls"><a href="#Composing-Controls" class="headerlink" title="Composing Controls"></a>Composing Controls</h2><p>아보카도 토스트 주문을 넣는 화면을 다시 살펴보자. 이는 우리가 알고 있는 화면과 많이 다르다. 정확히 말하자면 정형화되지 않은 상태다. 이 뷰를 아래와 같이 우리가 익숙한 형태의 뷰로 변경해보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/16.png" alt=""></p>
<p>둘의 가장 큰 차이점은 컨테이너가 다르다는 것이다. </p>
<p>기존 뷰(왼쪽)의 컨테이너가 <code>VStack</code>이라면 우리가 익숙한 오른쪽 뷰의 컨테이너는 <code>Form</code>이다. <code>Form</code> 역시 뷰 컨테이너의 한 종류다. <code>VStack</code>과의 차이점에는 헤더, 섹션 등이 있어 보다 정형화된 그룹 스타일의 UI를 보다 쉽게 만들 수 있다.</p>
<p>그리고 이렇게 컨테이너가 바뀜에 따라 그 안에 속하는 컨트롤(버튼, 토글 등)도 그 모습이나 속성이 컨테이너에 따라 변한다. 또한 <code>Form</code>을 사용하면 서로 다른 플랫폼에서 다양한 룩앤필(Look and Feel)을 제공할 수 있다. 이렇게 SwiftUI가 UI를 그리기 때문에 우리는 기능에 보다 집중할 수 있다.</p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/17.png" alt=""></p>
<p>위의 화면에서 <code>Button</code>을 예로 들면 뷰 컨테이너가 바뀌면서 <code>Button</code>의 <code>padding</code>, <code>alignment</code> 등이 바뀐 것을 확인할 수 있다. </p>
<p>이번엔 <code>Button</code> 코드를 살펴보자. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/18.png" alt=""></p>
<p>위의 단일 코드로 여러 플랫폼에서 다양한 룩앤필을 제공할 수 있다. </p>
<p><code>Button</code>은 눌렸을 때 액션을 인자로 넣어주고 버튼의 상태와 목적을 나타내는 <code>label</code>을 뷰 빌더 클로저를 통해 제공해줄 수 있다. 그리고 앞에서 봐왔듯이 여러 변경자들을 통해 보다 쉽게 커스터마이징을 할 수 있다. 이를 통해 우리는 다양한 플랫폼의 다양한 버튼을 사용자에게 제공해줄 수 있다.</p>
<p>그렇기 때문에 SwiftUI에서 컨트롤은 적응형(adaptive) 컨트롤이라 할 수 있다. 적응형 컨트롤은 다음과 같은 특성을 갖는다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/19.png" alt=""></p>
<p>컨트롤은 그 자체로 모양이 아닌 역할을 나타낸다. 이렇게 컨트롤이 역할을 의미하기 때문에 여러 플랫폼에 거쳐 재사용될 수 있는 것이다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/20.png" alt=""></p>
<p>이렇게 컨트롤들은 역할이 있고 이런 역할은 목적에 의해 생겨나기 때문에 <code>Toggle</code>이나 <code>Button</code>들은 그들 각자의 목적이 존재한다. 그리고 이들은 사람이 읽을 수 있는 레이블을 포함하기 때문에 기본적으로 VoiceOver 기능을 지원한다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/21.png" alt=""></p>
<p>그리고 레이블이 <code>Text</code>가 아니라 <code>Image</code>어도 <code>Image</code>에 설명을 위한 <code>Text</code>를 함께 제공하여 VoiceOver 기능을 제공할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/22.png" alt=""></p>
<p>또한 커스텀 뷰는 <code>accessbility</code> 변경자를 통해 이런 기능을 제공할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/23.png" alt=""></p>
<p>이렇게 컨트롤은 플랫폼에 따라 모양은 다를 수 있지만 본연의 목적을 수행하는 데 이는 SwiftUI의 핵심이라고 할 수 있다. SwiftUI는 한 번만 작성하고 어디에서나 실행할 수 있는 수단 일뿐만 아니라 이러한 핵심 개념을 배우고 다양한 컨텍스트와 플랫폼에서 사용할 수 있는 프레임 워크다.</p>
<p>그리고 우리가 뷰에서처럼 컨트롤에서도 변경자를 사용할 수 있다. 그리고 이는 뷰에서와 동일한 특성을 갖는다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/24.png" alt=""></p>
<p>예를 들어 다음과 같이 컨트롤 계층 전반에 걸쳐 변경자를 공유할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/25.png" alt=""></p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/26.png" alt=""></p>
<p>다음으로 살펴볼 것은 환경(Environment)이다. 이는 일종의 모든 뷰에서 접근할 수 있는 특성의 집합으로 볼 수 있다. 그리고 자식 뷰는 부모 뷰의 환경 특성을 상속 받는다. 물론 필요에 따라 자식 뷰에서 이를 오버라이딩할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/27.png" alt=""></p>
<p>그리고 이 환경은 프리뷰에서 유용하게 사용되는데, 동일한 UI를 여러 문맥에 따라 다르게 보여주는 기능을 제공한다. 이를 통해 환경, 문맥에 따라 UI가 어떻게 바뀌는지 쉽게 확인할 수 있다. </p>
<h2 id="Navigating-your-app"><a href="#Navigating-your-app" class="headerlink" title="Navigating your app"></a>Navigating your app</h2><p>iOS에선 기본적으로 <code>NavigationView</code>를 통해 기본 내비게이션 스타일을 사용할 수 있으며 <code>navigationBarTitle</code> 변경자를 통해 타이틀을 지정할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/28.png" alt=""></p>
<p><code>navigationBarTitle</code>은 다른 변경자와 같이 아래를 향하지 않고 위를 향하는 특성을 갖는다. <code>OrderForm</code>에 변경자를 적용했지만, <code>NavigationView</code>에 반영된다는 것을 의미한다. </p>
<p>그리고 <code>NavigationButton</code>를 목적지와 함께 만들어 실질적인 화면 전환을 구현할 수 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/30.png" alt=""></p>
<p><code>TabbedView</code>를 통해 성격이 다른 두 뷰를 탭 뷰로 묶어 관리할 수도 있다. </p>
<p><img src="/2019/12/26/SwiftUI-Essentials-2/31.png" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-21T12:55:57.000Z" title="2019-12-21T12:55:57.000Z">2019-12-21</time><span class="level-item"><a class="link-muted" href="/categories/WWDC/">WWDC</a><span> / </span><a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></span><span class="level-item">17 minutes read (About 2490 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/21/SwiftUI-Essentials-1/">SwiftUI Essentials (1)</a></h1><div class="content"><h2 id="Views-and-modifiers"><a href="#Views-and-modifiers" class="headerlink" title="Views and modifiers"></a>Views and modifiers</h2><p><code>View</code>들은 UI를 구성하는 가장 기본적인 블록이다. UIKit의 <code>UIView</code>나 AppKit의 <code>NSView</code>와 같이 UI를 구성하는 기본적인 단위라고 할 수 있다. </p>
<p>다음 앱의 UI를 계층 구조로 살펴보자. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ViewHierarchy.png" alt=""></p>
<p>이 계층을 SwiftUI로 작성하면 다음과 같다.</p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/CodeHierarchy.png" alt=""></p>
<p>SwiftUI는 이러한 뷰의 계층을 코드로 표현한다. 왼쪽의 코드 구조는 오른쪽의 뷰 계층 구조와 상당히 흡사한 것을 확인할 수 있다. </p>
<p>또한 코드에서 살펴볼 수 있듯이 뷰 계층을 표현하는데 <code>addSubview</code>와 같은 메소드를 사용하지 않는다. SwiftUI는 하나의 계층 구조를 각 뷰 조각들로 구성하는 것이 아니라 계층 전체를 하나의 완전한 구조로 생성한다. 왜냐하면 <strong>SwiftUI는 뷰를</strong> 명령형(imperatively)과 반대인 <strong>선언형(declaratively)으로 정의</strong>하고 있기 때문이다. </p>
<p>명령형과 선언형의 차이점을 살펴보자. </p>
<ul>
<li>명령형 코드 : 명시적인 명령(explicit commands)을 통해 결과를 구성</li>
<li>선언형 코드 : 묘사(describing) 통해 결과를 구성. 단 이를 어떻게 생성할지는 다른 주체에 의해 결정</li>
</ul>
<p>둘의 차이가 정의로만은 부족할 수 있다. 상황을 예를 들어 둘의 차이를 살펴보자. </p>
<p>명령형 코드는 친구에게 아보카도 토스트를 만드는 방법을 알려주는 것과 같다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ImperativeToast1.png" alt=""></p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ImperativeToast2.png" alt=""></p>
<p>선언형 코드는 아보카도 토스트를 만드는 요리사에게 토스트 주문을 하는 것과 같다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/DeclarativeToast.png" alt=""></p>
<p>친구에게 토스트 만드는 방법을 설명할 때는 <code>7. 아보카도의 중심을 제거해라.</code>와 같이 내가 직접 단계별로 필요한 결과를 전달한다. </p>
<p>반면, 요리사에게는 내가 원하는 토스트의 모습을 묘사하여 전달하고 그것을 어떻게 만드는지는 전적으로 요리사의 몫이다. 그리고 요리사가 전문가라면 우리는 항상 최상의 품질을 보장받을 수 있다.</p>
<blockquote>
<p>이 두 상황을 통해 명령형 코드와 선언형 코드의 차이점을 보다 쉽게 이해할 수 있었다.</p>
</blockquote>
<p>SwiftUI가 요리사의 역할을 하는 것이다. 그럼 이제 SwiftUI의 요소들을 하나씩 살펴보자. </p>
<h3 id="View-Container-Syntax"><a href="#View-Container-Syntax" class="headerlink" title="View Container Syntax"></a>View Container Syntax</h3><p>뷰 컨테이너는 여러 다른 컨텐트 뷰(Content View)들로 구성되어 있다. 뷰 컨테이너에는 <code>VStack</code>, <code>HStack</code> 등이 존재한다. 뷰 컨테이너의 일반적인 문법은 다음과 같다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ViewContainerSyntax.png" alt=""></p>
<p><code>VStack</code>을 다음과 같이 사용할 수 있는 것과 같다. </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VStack</span> &#123; </span><br><span class="line">  <span class="type">Imgae</span>(...)</span><br><span class="line">  <span class="type">Text</span>(...)</span><br><span class="line">  <span class="type">Text</span>(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Image</code>, <code>Text</code>와 같은 컨텐트 뷰들은 뷰 빌더(View Builder)라는 클로저 안에 나열된다. 그리고 뷰 컨테이너의 생성자는 이 뷰 빌더 클로저를 인자로 받는다. <code>addSubview</code>와 같은 함수를 호출하는 대신 이 클로저 블록 안에 원하는 뷰를 순서대로 나열만 해주면 된다.</p>
<p>실제로 뷰 빌더가 내부적으로 어떻게 동작하는지 확인하기 위해 <code>VStack</code> API를 살펴보자. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ViewContainerSyntaxDetail.png" alt=""></p>
<p>생성자 인자 중 <code>content</code>에 <code>@ViewBuilder</code> 속성(attribute)이 붙어있는 것을 확인할 수 있다. 스위프트 컴파일러는 <code>@ViewBuilder</code> 속성이 붙어 있으면 해당 클로저를 우리가 나열한 컨텐트 뷰들이 포함된 단일 뷰를 반환하는 클로저로 변환한다. </p>
<p>이런 특수한 클로저를 뷰 컨테이너의 생성자에 전달해줌으로써 뷰 컨테이너와 컨텐트 뷰들은 들여 쓰기로 자연스레 구분될 수 있다. </p>
<p>또한 <code>VStack</code>은 <code>alignment</code>나 <code>spacing</code>과 같은 인자를 추가로 받아 정렬이나 간격을 조정해줄 수 있다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ExampleAppCode.png" alt=""></p>
<p>SwiftUI에서 <code>VStack</code>, <code>HStack</code>과 같이 컨트롤(Control)도 뷰 컨테이너의 종류로 다른 뷰를 컨텐트 뷰로 포함할 수 있다. <code>Control</code>에는 <code>Button</code>, <code>Toggle</code> <code>Slider</code> 등이 있다. 위의 코드에서처럼 <code>Text</code>뿐만 아니라 다른 뷰도 컨텐트 뷰로 포함할 수 있다.</p>
<blockquote>
<p>컨트롤은 사용자와 상호작용할 수 있는 요소들을 말한다. <a href="https://developer.apple.com/documentation/swiftui/views_and_controls">공식 문서</a>를 통해 컨트롤에 어떤 것들이 있는지 알 수 있다. </p>
</blockquote>
<p>컨트롤과 뷰 컨테이너는 추후에 더 자세히 살펴보도록 하고 이젠 <strong><code>$</code></strong> 싸인에 주목해보자. </p>
<h3 id="Binding-Syntax"><a href="#Binding-Syntax" class="headerlink" title="Binding Syntax"></a>Binding Syntax</h3><p><code>Stepper</code>를 선언하는 코드를 살펴보자. <code>order.quantity</code>를 넘기는데 <code>$</code> 싸인이 앞에 붙었다. 이는 단순히. <code>order.quantity</code> <strong>값</strong>을 넘기는 것이 아닌 <strong>바인딩</strong>을 넘기는 것이다. 그럼 여기서 말하는 바인딩이란 뭘까?</p>
<p>영상의 예제 앱에서 <code>Stepper</code>는 <code>OrderForm</code>이란 뷰에 포함되어 있다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/BindingSyntax.png" alt=""></p>
<p><code>OrderForm</code>은 현재 순서를 추적하기 위해 <code>Order</code> 타입에 의존하고 있다. 이 프로퍼티를 살펴보면 <code>@State</code>란 속성이 붙어있는 것을 확인할 수 있다. <code>@State</code> 속성이 붙어있으면 SwiftUI는 이를 보고 내부적으로 지속성 있는 상태(persistent state)를 생성하고 관리하며 상태의 값을 이 프로퍼티를 통해 접근하도록 한다.</p>
<p>우린 이 프로터티에 접근해 상태의 값을 읽거나 쓸 수 있다.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Quantity: \(order.quantity)"</span>)</span><br></pre></td></tr></table></figure>

<p><code>Stepper</code>는 정적인 뷰가 아닌 컨트롤이다. 그 말은 사용자가 <code>Stepper</code>의 버튼을 누르면 그 상태가 변경될 수 있다는 의미다. 이를 위해선 단순히 읽기 전용인 값을 전달하는 것이 아니라 바인딩을 전달해야 한다. </p>
<p>바인딩은 일종의 관리되는 참조(managed reference)로 이를 통해 하나의 뷰가 다른 뷰의 상태를 변경할 수 있다. 이 예제에선 <code>Stepper</code>가 <code>OrderForm</code>의 상태를 <code>$order.quantity</code>를 통해 변경하고 있는 것이다. </p>
<blockquote>
<p>SwiftUI에서의 데이터 흐름에 대한 자세한 내용은 <a href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=2ahUKEwjF6tvttsbmAhVRJaYKHXDyBggQwqsBMAB6BAgKEAQ&url=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2019%2F226%2F&usg=AOvVaw0HLHjam6QvNklY9QlJyvIA">Data Flow Through SwiftUI</a> 영상을 참고하자. </p>
</blockquote>
<p>다시 예제 앱으로 돌아와 우리가 아직 살펴보지 못한 문법을 살펴보자. </p>
<h3 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h3><p><img src="/2019/12/21/SwiftUI-Essentials-1/ModifierText.png" alt=""></p>
<p><code>Text(&quot;Avocado Toast&quot;)</code>에서 우린 <code>font(.title)</code>과 같은 메소드를 호출할 수 있다. 이 메소드가 하는 작업은 간단하다. 호출한 뷰로부터 새 뷰를 만들어내는 것이다. SwiftUI에서 이런 메소드를 변경자(Modifier)라 부른다. </p>
<p>이런 변경자에 의해 뷰 계층이 어떻게 변경되는지 살펴보자.  <code>Text(&quot;Avocado Toast&quot;)</code>을 포함하는 <code>VStack</code>은 다음과 같은 계층 구조를 가진다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/NoModifierViewHierarchy.png" alt=""></p>
<p>하지만 여기에 <code>font(.title)</code> 변경자를 적용하면 뷰 계층은 다음과 같이 변경된다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ModifierViewHierarchy.png" alt=""></p>
<p>이렇게 변경자로 생성된 뷰는 기존의 뷰를 감싸고 뷰 계층에 포함된다. 이런 변경자는 다수의 변경자들과 함께 체이닝될 수 있다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/MultipleModifierViewHierarchy.png" alt=""></p>
<p>이렇게 변경자를 추가하게 되면 계층 구조는 빠른 속도로 비대해진다. 우리는 이전까지 이렇게 뷰 계층이 비대해지면 성능 이슈에 대해서 고민하곤 했다. 기존의 뷰 계층은 최대한 작고 가벼워야 했다.</p>
<p>하지만 SwiftUI는 이러한 부분에 대한 걱정을 덜어도 된다. 위에서 언급했듯이 우리는 선언형 코드를 작성한다. 우리는 단지 원하는 모습을 묘사할 뿐이고, SwiftUI가 이를 최적화한다. 우리가 아무리 많은 변경자를 사용해 <code>Text</code>를 여러 뷰로 감싸도 SwiftUI가 이를 보다 효율적인 자료구조로 최적화한다. 그리고 이렇게 최적화된 자료구조는 렌더링 시스템이 렌더링 하는데 사용한다. </p>
<p>이렇게 변경자 체이닝 문법은 성능 이슈에 대해 걱정할 필요 없이 많은 이점을 제공한다. 그중 하나로 변경자 체이닝은 시각적 요소의 직관적인 순서를 강제한다. 즉 체이닝에 참여하는 변경자의 순서에 따라 최종 렌더링 되는 모습이 달라진다는 것이다. </p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/PaddingLast.png" alt=""></p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/PaddingFirst.png" alt=""></p>
<p>만약 이런 속성들을 변경자 체이닝으로 변경하는 것이 아닌 <code>Text</code>의 내부에 포함된 속성이라고 가정해보자. 우린 시행착오와 문서 없이는 각각의 속성들이 어떤 순서로 적용되는지 알 수 없을 것이다. 이런 속성들을 변경자를 통해 적용함으로써 우린 순서를 명시적으로 지정할 수 있다. </p>
<p>또한 이런 변경자들은 여러 뷰들에서 공유될 수 있다.</p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ModifierWithoutSharing.png" alt=""></p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/ModifierWithSharing.png" alt=""></p>
<p>이렇게 변경자를 공유함으로써 각각의 뷰들은 보다 단순해질 수 있고 자신들만의 인터페이스에 집중할 수 있다. 이것이 SwiftUI의 기본 원칙이다.</p>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/SwiftUIPrinciple.png" alt=""></p>
<p>더 작고 단일 목적의 뷰라는 원칙을 따름으로써 우리는 보다 이해하기 쉽고, 유지 보수가 쉬운 뷰를 만들 수 있다. </p>
<blockquote>
<p>재사용성 역시 증가한다.</p>
</blockquote>
<p><img src="/2019/12/21/SwiftUI-Essentials-1/SwiftUIPrinciple2.png" alt=""></p>
<p>그리고 이렇게 각자의 역할별로 작게 나누어진 뷰들을 통해 보다 큰 뷰를 효과적으로 구성할 수 있다. </p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Corn"></figure><p class="title is-size-4 is-block line-height-inherit">Corn</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">30</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/protocorn93" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/protocorn93"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/RxSwift/"><span class="level-start"><span class="level-item">RxSwift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/"><span class="level-start"><span class="level-item">WWDC</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/WWDC/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/WWDC/SwiftUI/"><span class="level-start"><span class="level-item">SwiftUI</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-09-20T03:04:00.000Z">2020-09-20</time></p><p class="title is-6"><a class="link-muted" href="/2020/09/20/Meet-WidgetKit/">Meet WidgetKit</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-23T07:22:27.000Z">2020-08-23</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/23/Embrace-Swift-type-inference/">Embrace Swift type inference</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/Swift/">Swift</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-26T08:37:48.000Z">2020-07-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/26/GeometryReader-in-SwiftUI/">GeometryReader in SwiftUI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-19T10:36:32.000Z">2020-07-19</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/19/App-essentials-in-SwiftUI/">App essentials in SwiftUI</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/WWDC/">WWDC</a> / <a class="link-muted" href="/categories/WWDC/SwiftUI/">SwiftUI</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-15T08:26:52.000Z">2020-02-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/15/SwiftUI-under-the-hood/">SwiftUI under the hood</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/SwiftUI/">SwiftUI</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">September 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">August 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/03/"><span class="level-start"><span class="level-item">March 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/11/"><span class="level-start"><span class="level-item">November 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Binding/"><span class="tag">@Binding</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/State/"><span class="tag">@State</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ABI-Stability/"><span class="tag">ABI Stability</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AnyView/"><span class="tag">AnyView</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App/"><span class="tag">App</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Thinning/"><span class="tag">App Thinning</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bitcode/"><span class="tag">Bitcode</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Custom-URL-Scheme/"><span class="tag">Custom URL Scheme</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GeometryReader/"><span class="tag">GeometryReader</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Group/"><span class="tag">Group</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Opaque-Type/"><span class="tag">Opaque Type</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OptionSet/"><span class="tag">OptionSet</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PreferenceKey/"><span class="tag">PreferenceKey</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Property-Wrappers/"><span class="tag">Property Wrappers</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RxSwift/"><span class="tag">RxSwift</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scene/"><span class="tag">Scene</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift5/"><span class="tag">Swift5</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SwiftUI/"><span class="tag">SwiftUI</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Universal-Links/"><span class="tag">Universal Links</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/View/"><span class="tag">View</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC/"><span class="tag">WWDC</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WWDC19/"><span class="tag">WWDC19</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WidgetKit/"><span class="tag">WidgetKit</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WindowGroup/"><span class="tag">WindowGroup</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/enum/"><span class="tag">enum</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS-13/"><span class="tag">iOS 13</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/some/"><span class="tag">some</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%EC%9D%B4%EC%A7%81/"><span class="tag">이직</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Corn the blog" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>